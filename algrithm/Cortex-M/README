###########################################################
### % interrupt
###########################################################
% Cortex-M3 SVC与PendSV
SVC（系统服务调用，亦简称系统调用）和PendSV（可悬起系统调用），它们多用在上了操作系统的软件开发中。

% SVC用于产生系统函数的调用请求。
例如，操作系统通常不允许用户程序直接访问硬件，而是通过提供一些系统服务函数，让用户程序使用SVC发出对系统服务函数的调用请求，
以这种方法调用它们来间接访问硬件。因此，当用户程序想要控制特定的硬件时，它就要产生一个SVC异常，然后操作系统提供的SVC异常服务程序得到执行，
它再调用相关的操作系统函数，后者完成用户程序请求的服务。


% 【使用PendSV控制上下文切换】
事件流：
1、任务A呼叫SVC来请求任务切换（例如，等到某些工作完成）；
2、OS接收到请求，做好上下文切换的准备，并且悬起一个PendSV异常；
3、当CPU退出SVC后，它立即进入PendSV，从而执行上下文切换；
4、当PendSV执行完毕后，将返回到任务B，同时进入线程模式；
5、发生了一个中断，并且中断服务程序已开始执行；
6、在ISR执行过程中，发生SysTick异常，并且抢占了该ISR；
7、OS执行必要的操作，然后悬起PendSV异常以作好上下文切换的准备；
8、当SysTick退出后，回到先前被抢占的ISR中，ISR继续执行；
9、ISR执行完毕并退出后，PendSV服务程序开始执行，并且在里面执行上下文切换；
10、当PendSV执行完毕后，回到任务A，同时系统再次进入线程模式。



 
###########################################################
### gcc内嵌汇编
###########################################################
% 使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，
% 并告诉GCC对这些操作有哪些限制条件。例如在下面的汇编语句：  
__asm__ __violate__  
("movl %1,%0" : "=r" (result) : "r" (input));  

“movl %1,%0”是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，内嵌汇编靠它们将C语言表达式与指令操作数相对应。

指令模板后面用小括号括起来的是C语言表达式，本例中只有两个：“result”和“input”，
他们按照出现的顺序分别与指令操作数“%0”，“%1，”对应；注意对应顺序：
第一个C表达式对应“%0”；第二个表达式对应“%1”，依次类推，操作数至多有10个，分别用“%0”，“%1”….“%9，”表示。

在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。

 
“result”前面的限制字符串是“=r”，其中“=”表示“result”是输出操作数，
“r”表示需要将“result”与某个通用寄存器相关联，先将操作数的值读入寄存器，
然后在指令中使用相应寄存器，而不是“result”本身，当然指令执行完后需要将寄存器中的值存入变量“result”，
从表面上看好像是指令直接对“result”进行操作，实际上GCC做了隐式处理，这样我们可以少写一些指令。

 
“input”前面的“r”表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。





###########################################################
###  % 数学中对映射一词的解释 
###########################################################
“映射”一词首先是在数学中接触到的.
映射的定义：  如果集合A中的每个元素在对应法则f的作用下，在集合B中都有唯一的一个元素与它对应，
            那么集合A，B及对应法则f称为集合A到集合B的一个映射，记作f : A→B。
            在映射f : A→B中，与A中的元素a对应的B中的元素b叫做a的象，a叫做b的原象。
            对应法则f、集合A及集合B称为映射的三要素。
            从映射的定义可以看出，映射是“一对一”或“多对一”的对应关系。
            微机中的“多对一”关系就是重映射。 



###########################################################
###  % 储器映射的三要素
###########################################################
从数学中映射的定义可以看出，要弄清楚存储器的映射或重映射前，需要找出存储器映射的三要素

存储器本身并没有地址信息，它的地址是由芯片厂商分配好的，一般不可修改。
给存储器编址的过程（CPU对芯片中或芯片外的FLASH、RAM、外设、BOOTBLOCK等进行编址，地址统一编入存储器中）
称为存储器映射，也称为存储器地址映射。其中，映射到端口寄存器的存储器单元（或存储器空间）称为存储器映射寄存器，
其地址（或地址空间）称为存储器映射寄存器地址（或存储器映射寄存器地址空间）。

所以，对应法则f是存储器映射寄存器地址，集合A是存储器，集合B是外设寄存器。
（外设有私有外设、片上外设及片外设备这三种外设，其中，片上外设有GPIO端口 、
ADC、 TIM、 SPI、 USART、CAN、I2C等，私有外设有NVIC等。
CPU通过存储器映射方式对这些功能模块进行统一编址，使得CPU通过访问内存单元达到对外设寄存器的访问）。
所以它们构成的映射为：存储器映射寄存器地址：
存储器存储单元→外设寄存器（或 存储器映射寄存器地址空间：存储器存储空间→外设寄存器），即存储器到外设寄存器的映射。

那么，重映射就是CPU将外设寄存器重复编址到存储器的过程，也就是某一个外设寄存器在存储器里被映射了多个地址空间。
实际上，真实的外设寄存器在物理上不属于存储器。由于真实的外设寄存器与其对应的存储器映射寄存器是通过线路相互连接的，
所以，逻辑上外设寄存器属于存储器。并且，真实的外设寄存器中的内容与存储器映射寄存器中的内容在任何时候都是相同的。

### 用片上外设中的IO端口寄存器举个例子：
一个IO端口的端口位x在存储器中有2个被映射的存储单元A和B，存储单元A的地址为m，存储单元B的地址为n。
这样，通过地址m访问A可以达到访问B，最终实现访问IO端口位x。
同样地，通过地址n访问B可以达到访问A的目的，最终实现访问IO端口位x。
也就是说存储单元A的内容变化了，那么存储单元B和端口位x的内容也就跟随着A变化成相同的值，
同样地，A和端口位x也会跟随着B变化而变化，并且A、B及端口位x中的内容始终相同。

在一些内核处理器预定义的存储器映射中，如Cortex-M3/M4内核，
有两个内核预定义存储空间“位带区和位带别名区”就是存储器的重映射的结果。
由于通过位带操作访问位带别名区来访问位带区的单个数据位，
所以，常常将它们相互映射关系称为“位带别名区到位带区的映射”。



###########################################################
###  % 存储器映射的意义
###########################################################
I/O端口有两种编址方式，即I/O端口与存储器统一编址和I/O端口与存储器独立编址。
I/O地址空间和存储器地址空间是两个不同的物理空间，
C/C++等高等语言中没有访问IO端口的指令（除非有专门的访问IO的汇编内核指令或者编译器提供的专门访问IO的函数），
不过C/C++语言具有对绝对地址（或物理地址）的单元内容读写的能力，也就是说具有直接访问物理地址的能力，
它是以指针方式访问物理地址单元内容的。所以，若采用I/O端口与存储器统一编址的方式，将存储器空间映射给IO空间，
那么就可以通过访问存储器实现对IO的访问。
注：物理地址/绝对地址指对存储器编址后存储单元的地址。



