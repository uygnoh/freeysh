###########################################################
### 消息队列的基本概念
###########################################################
% 队列又称消息队列，是一种用于任务间通信的数据结构
% 队列可以在任务与任务间， 任务与中断间传递消息
1 实现了任务接收来自其它任务或中断的不固定长度的消息
2 任务能够从队列中读取消息，当队列中的消息为空时，读取消息的任务被阻塞
3 用户还可以指定阻塞的任务时间xTaskToWait; 在这段时间内，如果队列为空，
  该任务将保持阻塞状态以等待队列数据有效
4 当队列中有新消息时，被阻塞的任务被唤醒并处理新消息；
  当等待的时间超过指定的阻塞时间，即使队列中尚无有效数据，
  任务也会自动从阻塞态转为就绪态。
  消息队列是一种异步通信方式。

% 通过消息队列服务，任务或中断服务例程可以将一条或多条消息放入消息队列中。
% 同样，一个或多个任务可以从消息队列中获得消息，
% 当有多个消息发送到消息队列时，通常是将先进入的消息先传给任务，
% 也就是说，任务先得到的是最先进入队列的消息，即先进先出原则，FIFO
% 但是也支持后进先出原则，LIFO

% FreeRTOS中使用队列数据结构实现异步通信工作，具体有如下特性
1 消息支持先进先出方式排队，支持异步读写工作方式
2 读写队列均支持超时机制
3 消息支持后进先出方式排队，向队首发送消息，LIFO
4 可允许不同长度（不超过队列节点最大值）的任意类型消息
5 一个任务能从任意一个消息队列接收和发送消息
6 多个任务能够从一个消息队列接收和发送消息
7 当队列使用结束后，可能通过删除队列函数进行删除



###########################################################
### 消息队列的动作机制
###########################################################
% 创建消息队列时FreeRTOS会先给消息队列分配一块内存空间
% 这块内存空间的大小等于 [消息队列控制块大小 + (单个消息队列空间大小*消息队列长度)]
% 下一步，初始化消息队列，此时消息队列为空

% FreeRTOS的消息队列有多个元素组成 
% 当消息队列被创建时，系统会为控制块分配对应的内存空间，用于保存消息队列一些信息
1 消息队列存储位置，头指针pcHead, 尾指针pcTail, 消息大小uxItemSize, 队列长度uxLength等
2 同时每个消息队列与消息空间在同一段连续的内存中
3 在创建成功时这些内存都被占用了，只有删除消息队列时这段内存才会被释放
4 创建成功时就已经分配好的消息空间与消息队列的容量无法更改
5 每个消息空间可以存放不大于消息大小（uxItemSize）的任意数据类型
6 所有消息队列中的消息空间总数即消息队列的长度，这个长度可以在消息队列创建时指定

% 任务或中断服务程序都可以给消息队列发送消息
1 当发送消息时，如果队列未满或者允许覆盖入队，
2 FreeRTOS会将消息复制到消息队列队尾，否则会根据用户指定的阻塞超时时间进行阻塞
3 在这段时间中， 如果队列一直不允许入队，该任务将保持阻塞状态以等待队列允许入队
4 当其它任务从其等待的队列中读取数据（队列未满）时，该任务自动由阻塞转为就绪
5 当等待的时间超过了指定的阻塞时间，即使队列中还不允许入队，任务也会从阻塞态转变为就绪态
6 此时发送消息的任务或者中断程序会收到一个错误代码 errQUEUE_FULL

% 发送紧急消息
1 发送紧急消息与发送消息几乎一样， 唯一不同的是
2 当发送紧急消息时，发送的位置是消息队列的队头而非队尾
3 这样，接收者就可以优先接收紧急消息，从而进行消息处理

% 当某一个任务试图读一个队列时，其可以指定一个阻塞时间
1 在这段时间如果队列为空，该任务将保持阻塞状态以等待队列数据有效
2 当其它任务或中断服务程序向其等待队列中写入了数据，该任务将由阻塞态变为就绪态
3 当等待时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动由阻塞态转换为就绪态

% 当队列不在被使用
1 应该将其删除以释放系统资源
2 一旦操作完成，消息队列将被永远删除



###########################################################
### 消息队列的阻塞机制
###########################################################
% 我们使用的消息队列一般不是属于某个任务队列，在很多的时候，我们创建
% 的队列是每个任务都可以读写操作的，但是为了保护每个任务读写的过程，
% 必须有阻塞机制，在某个任务对其进行读写操作时，必须保证该任务能够正
% 常的完成读写操作，而不受后来任务的影响

% 如何实现这个机制
1 每个对消息队列读写的函数都有这种机制，称为阻塞机制
2 假设一个任务A对某个队列进行读操作（也就是我们所说的出队）
3 发现它没有消息，那么此任务有3个选择
4 1，即然队列没有消息，那么队列不在等待，去处理其它操作，那么A就不会进入阻塞态
5 2， 任务A继续等待，此时任务A会进入阻塞态，等待消息到来，而任务A的等待时间由我们自己定义
6 21，比如设置为100个tick，在这个100个tick到来之前，任务A都处于阻塞态
7 22，若阻塞的这段时间任务A等到了队列消息，那么任务A就会由阻塞态转为就绪态
8 23，如果此时任务A比当前任务的优先级还要高，那么任务A就会得到消息并且运行
9 3，假如100个tick过去了队列中还没有消息，那么任务A就不等了，
103，从阻塞态中唤醒，返回一个没有等到的错误代码，然后继续执行任务A的其它代码
104，第3个选择，任务A一直等待，这们任务A就会进入阻塞态，直到完成读取队列的消息

% 而发送消息时， 为了保护数据 
1 当且仅当队列允许入队时，发送者才能成功发送消息
2 队列中无可以消息空间时，说明消息队列已满，
3 此时系统会根据用户指定的阻塞超时时间将任务阻塞
4 在指定的时间内如果还不能完成入队操作，
5 发送消息的任务或中断服务程序会收到一个错误代码，errQUEUE_FULL,然后解除阻塞态
6 当然只有在任务中发送消息才允许进入阻塞态，而在中断中发送消息则不允许有阻塞机制 
7 需要调用在中断中发送消息的API函数接口
8 假如，有多个任务阻塞在一个消息队列中，
9 那么阻塞的任务按照任务优先级进行排序，优先级高的任务将优先获得队列的访问权



###########################################################
### 消息队列控制块
###########################################################
typedef struct QueueDefintion {
    int8_t *pcHead;     /* pcHead指向队列消息存储区起始位置，即第1个消息空间 */
    int8_t *pcTail;     /* pcTail指向队列消息存储区结束位置地址 */
    int8_T *pcWriteTo;  /* pcWriteTo指向队列消息存储区下一个可用消息空间 */
    
    /* pcReadFrom和uxRecursiveCallCount是一对互斥变量
       使用联合体来确保两个互斥的结构体成员不会同时出现，
       当结构体用于队列时，pcReadFrom指向出队消息空间的最后一个，
       也就是读取消息时是从pcReadFrom指向的空间读取消息内容 
       当结构体用于互斥量时，uxRecursiveCallCount用于计数，
       记录递归互斥量被调用的次数 */
    union {
        int8_t *pcReadFrom;
        UBaseType_t uxRecursiveCallcount;
    } u;
    
    /* xTaskWaitingToSend发送消息阻塞列表，用于保存阻塞在此队列的任务，
    任务按照优先级进行排序，由于队列已满，想要发送消息的任务无法发送消息*/
    List_t xTaskWaitingToSend;
    /* xTaskWaitingToSend;获取消息阻塞列表，用于保存阻塞在此的任务，
    任务按照优先级排序，由于队列是空的，想要获取消息的任务无法获取消息*/      
    List_t xTadkWaitingToReceive;   
    
    /* uxMessageWaiting;用于记录当前消息队列的消息个数，如果消息队列
    用于信号量，这个值就表示有效信号量的个数*/
    volatile UBaseType_t uxMessageWaiting;
    
    UBaseType_t uxLength;   /* 表示队列的长度，也就是能存多少个消息 */
    UBaseType_t uxItemSize; /* 表示单个消息的大小 */
    
    /* 队列上锁后，存储从队列收到的列表项数目，也就是出队的数量
    如果队列没有上锁，则设置为 queueUNLOCKED */
    volatile eint8_t cRxLock;
    /* 队列上锁后，存储发送到队列的列表项数目，也就是入队的数量
    如果队列没有上锁，则设置为 queueUNLOCKED */
    volatile eint8_t cTxLock;
} xQUEUE;
typedef xQUEUE Queue_t;



