###########################################################
### 消息队列的基本概念
###########################################################
% 队列又称消息队列，是一种用于任务间通信的数据结构
% 队列可以在任务与任务间， 任务与中断间传递消息
1 实现了任务接收来自其它任务或中断的不固定长度的消息
2 任务能够从队列中读取消息，当队列中的消息为空时，读取消息的任务被阻塞
3 用户还可以指定阻塞的任务时间xTaskToWait; 在这段时间内，如果队列为空，
  该任务将保持阻塞状态以等待队列数据有效
4 当队列中有新消息时，被阻塞的任务被唤醒并处理新消息；
  当等待的时间超过指定的阻塞时间，即使队列中尚无有效数据，
  任务也会自动从阻塞态转为就绪态。
  消息队列是一种异步通信方式。

% 通过消息队列服务，任务或中断服务例程可以将一条或多条消息放入消息队列中。
% 同样，一个或多个任务可以从消息队列中获得消息，
% 当有多个消息发送到消息队列时，通常是将先进入的消息先传给任务，
% 也就是说，任务先得到的是最先进入队列的消息，即先进先出原则，FIFO
% 但是也支持后进先出原则，LIFO

% FreeRTOS中使用队列数据结构实现异步通信工作，具体有如下特性
1 消息支持先进先出方式排队，支持异步读写工作方式
2 读写队列均支持超时机制
3 消息支持后进先出方式排队，向队首发送消息，LIFO
4 可允许不同长度（不超过队列节点最大值）的任意类型消息
5 一个任务能从任意一个消息队列接收和发送消息
6 多个任务能够从一个消息队列接收和发送消息
7 当队列使用结束后，可能通过删除队列函数进行删除



###########################################################
### 消息队列的动作机制
###########################################################
% 创建消息队列时FreeRTOS会先给消息队列分配一块内存空间
% 这块内存空间的大小等于 [消息队列控制块大小 + (单个消息队列空间大小*消息队列长度)]
% 下一步，初始化消息队列，此时消息队列为空

% FreeRTOS的消息队列有多个元素组成 
% 当消息队列被创建时，系统会为控制块分配对应的内存空间，用于保存消息队列一些信息
1 消息队列存储位置，头指针pcHead, 尾指针pcTail, 消息大小uxItemSize, 队列长度uxLength等
2 同时每个消息队列与消息空间在同一段连续的内存中
3 在创建成功时这些内存都被占用了，只有删除消息队列时这段内存才会被释放
4 创建成功时就已经分配好的消息空间与消息队列的容量无法更改
5 每个消息空间可以存放不大于消息大小（uxItemSize）的任意数据类型
6 所有消息队列中的消息空间总数即消息队列的长度，这个长度可以在消息队列创建时指定

% 任务或中断服务程序都可以给消息队列发送消息
1 当发送消息时，如果队形未满或者允许覆盖入队，
2 FreeRTOS会将消息复制到消息队列队尾，否则会根据用户指定的阻塞超时时间进行阻塞
3 在这段时间中， 如果队列一直不允许入队



###########################################################
### 消息队列的阻塞机制
###########################################################





###########################################################
### 消息队列控制块
###########################################################



