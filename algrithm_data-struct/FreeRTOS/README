### FreeRTOS
% https:/RTOS代码的核心包含在三个文件中：[ tasks.c、queue.c、list.c ]
这三个文件位于FreeRTOS/Source目录。
在该目录下还包含三个可选的文件：timers.c、event_groups.c、croutine.c，分别实现软件定时、事件组和协程功能。


    FreeRTOS
        | +-- Source  FreeRTOS内核代码文件
        |   |+-- include          FreeRTOS内核代码头文件
        |   |+-- Portable         处理器特定代码
        |   |  |+--Compiler x     支持编译器x的所有移植包
        |   |  |+--Compiler y     支持编译器y的所有移植包
        |   |  |+--MemMang        内存堆实现范例
        

% 每个支持的处理器架构需要一小段与处理器架构相关的RTOS代码。
这个是RTOS移植层，它位于FreeRTOS/Source/Portable/[相应编译器]/[相应CPU架构]子目录。

% 对于FreeRTOS，堆栈设计也属于移植层。
FreeRTOS/Source/portable/MemMang目录下heap_x.c文件给出了多种堆栈方案，后续文章将会详细介绍堆栈操作。


% 移植层目录举例：
 如果在GCC编译器下使用TriCore1782：TriCore特定文件（port.c）位于FreeRTOS/Source/Portable/GCC/TriCore_1782目录下。
 FreeRTOS/Source/Portable 子目录下的所有文件，除了FreeRTOS/Source/Portable/MemMang目录外都可以忽略或删除
 
 
% FreeRTOS下载包中还包含各种处理器架构和编译器的演示例程。
大多数的演示例程代码对所有移植都是通用的，位于FreeRTOS/Demo/Common/Minimal目录。
FreeRTOS/Demo/Common/Full目录下的是历史遗留代码，仅用于PC。

      % FreeRTOS/Demo目录结构如下所示：
        FreeRTOS
          |+-- Demo
          |  |+-- Common          所有例程都可以使用的演示例程文件
          |  |+-- Dir x           用于x平台的演示例程工程文件
          |  |+-- Dir y           用于y平台的演示例程工程文件
 
 
% FreeRTOS/Demo目录下剩余的子目录包含预先配置好的工程，可以用于构建个人演示例程。
子目录的命名与移植平台和编译器相关。每一个RTOS移植包都有自己的说明文档。

      %演示例程目录举例：
    如果以英飞凌TriBoard开发板硬件构建TriCoreGCC演示例程：
    TriCore演示例程工程文件位于FreeRTOS/Demo/TriCore_TC1782_TriBoard_GCC目录。
    目录FreeRTOS/Demo下的所有子目录（Common目录除外）都可以忽略或删掉。 
 
 
 
 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++FreeRTOS学习笔记——链表 
% 习下FreeRTOS中有关链表的操作，查看源代码发现链表的代码貌似很精简，
有三个结构分别是xLIST_ITEM、xMINI_LIST_ITEM、xLIST，
其中xLIST_ITEM和xMINI_LIST_ITEM类似可以归为一类
/*
 * Definition of the only type of object that a list can contain.
 */
struct xLIST_ITEM
{
	configLIST_VOLATILE TickType_t xItemValue;			
	struct xLIST_ITEM * configLIST_VOLATILE pxNext;	
	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	
	void * pvOwner;										
	void * configLIST_VOLATILE pvContainer;				
};
typedef struct xLIST_ITEM ListItem_t;					
 
struct xMINI_LIST_ITEM
{
	configLIST_VOLATILE TickType_t xItemValue;
	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;
 
/*
 * Definition of the type of queue used by the scheduler.
 */
typedef struct xLIST
{
	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
	ListItem_t * configLIST_VOLATILE pxIndex;		
	MiniListItem_t xListEnd;						
} List_t; 



% xMINI_LIST_ITEM可以算是xLIST_ITEM的子类，两者可以相互转换，
% xLIST是我们需要关注的xLIST_ITEM和xMINI_LIST_ITEM都是基本结构都是有xLIST来管理，
% 在list.h文件中以宏定义定义了一些链表的操作 

#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
 
#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
 
 
#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
 
#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
 
#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
 
#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
 
#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
 
#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
 
#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
 
#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
 
#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
{																							\
List_t * const pxConstList = ( pxList );													\
	/* Increment the index to the next item and return the item, ensuring */				\
	/* we don't return the marker used at the end of the list.  */							\
	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
	{																						\
		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
	}																						\
	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
}
 
#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
 
#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
 
 
#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
 
#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
 
void vListInitialise( List_t * const pxList );
 
void vListInitialiseItem( ListItem_t * const pxItem );
 
void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem );
 
void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem );
 
UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ); 
 
这其中文档有提到xLIST_ITEM中pvOwner一般是指向TCB任务控制块的指针，而pvContainer一般是指向xLIST的指针，
链表的排序都是以xItemValue为基准降序排列，xLIST中的xListEnd是链表的末尾，在链表中是不含有有效数据的，





###
% 数据类型
    portCHAR    char
    portSHORT   short
    portLONG    long
    protTickType
    protBASE_TYPE long
    
    
% 变量名
   char  类型变量的前缀为 c 
   short 类型变量的前缀为 s 
   long  类型变量的前缀为 l
   portBASE_TYPE类型变量的前缀为 x
   char    类型无符号变量的前缀为 uc
   char    类型指针变量的前缀为   pc
   
   
% 函数名
    vTaskPrioritySet()      返回值为void类型
    xQueueReceive()         返回值为portBASE_TYPE类型
    vSemaphoreCreateBinary()返回值为void类型
    
% 宏
    前缀                                  宏定义的文件
    port  (例如, portMAX_DELAY)           portable.h
    task  (例如, taskENTER_CAITICAL)      task.h
    pd    (例如, pdTRUE)                  projdefs.h
    config(例如, configUSE_PREEMPTION)    FreeRTOSConfig.h
    err   (例如, errQUEUE_FULL)           projdefs.h
    
    
% 格式
1 个TAB键 == 4 空格















因此也不记录在uxNumberOfItems中整个链表的结构差不多是下面形式，关于xListEnd的处理可能不是很对 

 
