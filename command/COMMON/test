### =================================================================== [[ ]]
% 判断文件是否存在
% 中括号判断式两边必须有空格, [  ]或test
test -e /root/install.log   
[ -e /root/install.log ]

[ -e /etc ]             文件是否存在
[ -d /etc ]             目录文件
[ -f /etc/passwd ]      普通文件
[ -b 文件 ]             文件存在且为块特殊文件
[ -c 文件 ]             文件存在且为字符特殊文件

[ -d /root ] && echo "yes" || echo "no"

[ 文件1 -nt 文件2 ]     文件1 在修改时间上新于文件2
[ 文件1 -ot 文件2 ]     文件1 比文件2 更旧
[ 文件1 -ef 文件2 ]     文件1 和文件2 拥有相同的设备编号与 inode 编号




## =========================================================== 两个整数之间的比较
[ a -eq b ]             ==
[ a -ne b ]             !=
[ a -gt b ]             >
[ a -lt b ]             <
[ a -ge b ]             >=
[ a -le b ]             <=



## =================================================================== 判断字符串
[ -z 字符串 ]          为空返回真
[ -n 字符串 ]          非空返回真



## ================================================================= 多重条件判断
[ 判断1 -a 判断2 ]      逻辑与
[ 判断1 -o 判断2 ]      逻辑或
[ ! 判断 ]              逻辑非


## ==================================================================== 环境变量	
变量	                    说明
$0                      脚本名称
$n 	                    传给脚本/函数的第n个参数
$$ 	                    脚本的PID
$! 	                    上一个被执行的命令的PID(后台运行的进程)
$? 	                    上一个命令的退出状态(管道命令使用${PIPESTATUS})
$# 	                    传递给脚本/函数的参数个数
$@ 	                    传递给脚本/函数的所有参数(识别每个参数)
$* 	                    传递给脚本/函数的所有参数(把所有参数当成一个字符串)
___________________________________________________________
提示
使用$*很少是正确的选择。
$@能够处理空格参数，而且参数间的空格也能正确的处理。
使用$@时应该用双引号括起来，像”$@”这样

>>>
三个小于号(here-strings)。Here-字串和Here-document类似，
here-strings语法：command [args] <<<["]$word["]；
$word会展开并作为command的stdin。

\<...\>
词界符(word boundary)。
这个是用在正则表达式中的一个特殊分隔符，用来标记单词的分界。
比如：the会匹配there，another，them等等，
如果仅仅要匹配the，就可以使用这个词界符，\<the\>就只能匹配the了。




