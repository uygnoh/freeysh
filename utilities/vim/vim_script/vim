### % https://www.w3cschool.cn/vim/gsenvozt.html
" 插件管理
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif


### ========================================================= vimscript 一些概念
"buffer"、"window"、 "normal mode"、"insert mode"、"text mode"

   
% Buffer
Vim 中的 Buffer 是文件在内存中的缓存数据，一个 Buffer 总是也只能是对应一个文件。
当你使用 edit(e) 命令的时候，实际上就是将文件内容载入到 Buffer 里面。
bnext/bprevious/bdelete/bwipe 命令的操作对象都是 Buffer，
这也就是为什么执行 bnext 有时可以切换文件的原因。至于为什么是 “有时”，稍后再作解释。
现在你只需记住，这几个命令都是直接对于文件缓存的操作。


% Window
用习惯 Sublime 或者 VS Code（以下简称 Vsc）的人可能会习惯性地把 Window 理解为窗口，
把 split/vsplit 理解为分屏命令。但是这根本没办法解释为什么切换 Tab 的时候分屏会消失，
按照之前的经验，切换 Tab 应该不影响分屏的展示才对。

其实 Window 跟前面说的两款编辑器中的窗口根本不是一个概念，
在 Vim 中，Window 只负责展示 Buffer 的数据且不会影响 Buffer。
当我们执行 split 或者 vsplit 的时候，其实是打开了一个新的 Window 并载入当前的 Buffer，
而当我们使用 q 命令关闭一个窗口时，并不会关闭相应的 Buffer。
除此之外，使用 help 命令、使用 NERDTree 打开文件树、使用 Tagbar 打开标签界面的时候，都是打开了一个新的 Window。
一个 Window 在同一时间内只能展示一个 Buffer，一个 Buffer 可以同时被多个 Window 展示，
使用上一节中的命令可以切换 Window 中展示的 Buffer。



% Tab
理解了上面两个概念之后，Tab 就很好解释了。Tab 是一系列 Window 的集合，是一种 “布局”。
一个 Tab 上可以有多个 Window，不同 Tab 之间的 Window 互不影响。


% Buffer、Window 和 Tab 之间的关系
理解完上面这些概念之后，我想你大概已经明白了，在 Vim 中这三者的关系大概是这样的：
Buffer 负责保存数据，Window 负责展示数据，Tab 为 Window 提供排版布局，
Buffer 和 Tab 对 Window 总是一对多的关系。如果把 Vim 想象成一个机房的话，Buffer 就是主机，
Window 是显示器，而 Tab 是一个个显示器架子。只不过这个机房里面的显示器可以随意连接到别的主机上面，
一个主机可以被多个显示器连接。

% 为什么 bnext/bprevious 可以打开分屏？
前面提到过，尽管 Buffer 只是负责数据的保存，并不关心数据的展示，
而 bnext/bprevious 命令是用于切换 Buffer 的，
可是有时候调用 bnext/bprevious 命令却打开了一个新的 Window！这种奇怪的现象其实跟你的配置有关系，
Vim 里面有一个 hidden 配置项，它负责告诉 Vim 是否允许隐藏一个未保存的 Buffer。
当你 :set nohidden 时，Vim 会在切换 Buffer 的时候检测当前 Buffer 是否保存，
如果还未保存，则会以打开一个新 Window 的形式打开另一个 Buffer。
博主的建议是在 vimrc 中加入 set hidden，这样才不容易导致迷惑。


% 导致迷惑的根源
拿 Vsc 来作比较，就很容易理解为什么在 Vim 中这三者容易导致迷惑了。
在 Vsc 里面，一个 Tab 对应了一个文件（注：这里指双击打开的文件，而不是单击用浏览模式打开），
一个 Tab 永远都只会显示同一个文件。明白了吗？其实 Vsc 里面的 Tab 更像是 Vim 里 Window 的概念。
只不过 Vsc 中这两者是一种一经打开就无法修改的强一一对应的关系，而 Vim 却可以做到随意切换。
而 Vsc 的窗口分屏却有点类似于 Vim Tab 的概念，只不过 Vsc 的布局只能有一种，而 Vim 可以有多种布局，随意切换。

类似于 Vsc 这样的编辑器把布局和展示的概念简化了，通过建立一种只有一个布局（Vim 中的 Tab，Vsc 中的窗口），
展示（Vim 中的 Window，Vsc 中的 Tab）和数据强一一对应的机制，使得编辑器的使用更加简单，不容易出错。
而 Vim 却不会管那么多，它向你提供 Buffer、Window 和 Tab，具体要怎么用，是操作者应该考虑的问题。


% 孰优孰劣？
尽管 Vsc 这类编辑器操作更加友好，使用更加简单，但却没有 Vim 那么灵活，丧失了可定制性。
而 Vim 为了灵活性却导致了学习成本太高，使人望而生畏。
博主个人是比较倾向于 Vsc 那种操作逻辑的（以为我会夸 Vim？不存在的），
在我个人的日常工作中也是尽量简化了 Vim 里面这三者的使用。
不过还是推荐读者们根据个人习惯进行定制，毕竟自己用得顺手才是最好的。


% 个人使用经验
由于 Tmux 这种神器的存在，而且刚入职不久公司还没给配屏幕，
除非多项目切换频繁，博主一般不会使用多 Tab，也不使用分屏，
而是使用单 Tab、单 Window、多 Buffer 切换的模式，把分屏的工作交给 Tmux。
这样一来就可以大大简化会使用到的快捷键。下面奉上个人配置：

   
### ======================================================= %  vim 语法基本特征
### 创建Vimrc文件 
~/.vimrc文件包含了Vimscript代码，每次启动Vim时，Vim都会自动执行其中的代码
在Linux和Mac OS X中，这个文件位于你的home文件夹，并以.vimrc命名
在Windows中，这个文件位于你的home文件夹，并以_vimrc命名
% 在_任意_系统中，在Vim中执行以下命令可以快速得知这个文件的位置和名称
% 如果你的home文件夹没有这个文件，请自行创建一个
:echo $MYVIMRC


### Vimscript 打印信息 
Vimscript中，我们最先关注的是 echo和echom 命令。
你可以在Vim中执行[:help echo]和[:help echom]命令以查看其帮助文档。
读完本书之后， 再次遇到新的命令时，你应该先执行:help命令查看其帮助文档。
% 执行如下命令，体验echo命令：
:echo "Hello, world!"

:echom "Hello again, world!"
%执行如下命令，查看上述两个打印命令的区别：
:messages
% 你应该会看到一些消息。Hello, world!应该_不在_其中，但是Hello again, world! 在。

当你写更为复杂的Vimscript时，你可能会想"打印一些信息"以方便调试程序。
:echo命令 会打印输出，但是一旦你的脚本运行完毕，那些输出信息就会消失。
使用:echom打印的信息 会保存下来，你可以执行:messages命令再次查看那些信息。


### 继续之前，咱们先看看如何添加注释
% 当你写Vimscript脚本时(在你的~/.vimrc文件中或 其它任意文件)，
% 你可以通过"字符添加注释，例如：
" Make space more useful

"       注释
\       续行

阅读:help echo帮助文档。
阅读:help echom帮助文档。
阅读:help messages帮助文档。


### ======================================================= %Vimscript 设置选项
% Vim拥有很多选项可以设置以改变其展现方式。
% 主要有两种选项：布尔选项（值为"on"或"off"）和键值选项。
% 布尔选项, 执行如下命令： 那么现在你就会看见行号
:set number
% 执行命令：行号应该消失
:set nonumber

% number是一个布尔选项：可以off、可以on
通过:set number命令打开、 :set nonumber命令关闭。
所有的布尔选项都是这种配置方法。
:set <name>打开选项、:set no<name>关闭选项。

% 切换布尔选项你可以"切换"布尔选项的值，即从开启切为关闭或从关闭切为开启
执行命令：
:set number!

% 查看选项当前值, 你可以使用一个?
?符号向Vim获取一个选项的当前值。执行如下命令并查看每个命令的 返回结果
:set number?

% 键值选项, 有些选项并不只有off或on两种状态，它们需要一个值。
% numberwidth选项改变行号的列宽。
你可以通过 :set <name>=<value> 命令改变 非布尔选项的选项值，
你可以通过 :set <name>?        命令查看选项的当前值。
% 执行如下命令，查看返回结果：
:set number
:set numberwidth=10
:set numberwidth=4
:set numberwidth?

% 来看看vimscript一些常用选项的值：
:set wrap?
:set shiftround?
:set matchtime?

% 一次性设置多个选项, 最后，你可以在一个:set命令中设置多个选项的值。试试如下命令：
% 注意最后一个命令是如何一次性设置两个选项值的
:set numberwidth=2
:set nonumber
:set number numberwidth=6


% vimscript 帮助文档
阅读:help 'number'（注意有单引号）帮助文档。
阅读:help relativenumber帮助文档。
阅读:help numberwidth帮助文档。
阅读:help wrap帮助文档。
阅读:help shiftround帮助文档。
阅读:help matchtime帮助文档。


### =======================================================%Vimscript 负责任的编码
到目前为止我们已经介绍了一堆Vim命令，
这可以让你可以快速自定义Vim。
除了自动命令组外其他的命令都是单行的命令，
你可以不费吹灰之力就把它们添加到你的~/.vimrc文件中。
这本书的下一部分我们会开始专注于Vim脚本编程，
将其当作一个真正的编程语言对待，不过在此之前，
我会先讲一些在编写大量的Vim脚本时需要注意的东西。


% 注释
Vim脚本非常强大，但对于那些想进入这个领域的程序员而言，
在最近几年它似乎逐渐变得像一个弯弯曲曲的迷宫，让进入的人找不到归路。

Vim的选项和命令经常会比较简短生硬，并且难于阅读，另外处理兼容性问题也会增加代码的复杂度。
编写一个插件并且允许用户自定义又会让复杂度更进一级。

在编写大量Vim脚本时要保持防御意识。要养成习惯添加注释说明某段代码是干什么的，
如果有一个相关的帮助主题（help topic），最好在注释中说明！

这不仅会给你以后的维护带来方便，而且如果你将你的~/.vimrc文件分享到Bitbucket或者GitHub（强烈推荐你这么做），
这些注释也会帮助其他的人理解你的脚本。


% 分组
之前创建的映射可以让我们在使用Vim的同时方便快捷地编辑和加载~/.vimrc。
不幸的是这会导致~/.vimrc中的代码快速增长以至失去控制，并且变得难于阅读浏览。

我们用于对付这种情况的方法是使用Vim的代码折叠功能，将多行代码组织起来的作为一个部分然后对这部分的代码进行折叠。
如果你从来没有用过Vim的折叠功能，那么你现在应该尽快去瞄一瞄。很多人（包括我自己）都认为在日常编码工作中代码折叠是不可或缺的。
首先我们需要为Vim脚本文件设置折叠。在你的~/.vimrc文件中添加下面几行：
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END

这会告诉Vim对任何Vim脚本文件使用marker折叠方法。
现在在显示~/.vimrc文件的窗口中执行:setlocal foldmethod=marker。
如果你不执行这个命令，你会发现加载~/.vimrc文件后没什么效果，
这是因为Vim已经为这个文件设置了文件类型(FileType)，
而自动命令只会在设置文件类型的时候执行。这让你以后不需要手动来做这个事情。

现在在自动命令组开始和结束的地方添加两行，像下面这样：
" Vimscript file settings ---------------------- {{{
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}

切换到常用模式，将光标放到这些文字中的任意一行，然后敲击za。
Vim会折叠从包含{{{的行到包含}}}的行之间的所有行。再敲击za会展开所有这些行。

刚开始你可能会觉得为了代码折叠而对源代码进行注释会有些不合理，我刚开始也这么想。
对于大多数文件我现在仍然觉得这种做法并并不合适。因为不是所有人都使用相同的编辑器，
所以在代码中添加的折叠注释对于那些不用Vim的人而言就像是噪音。

不过Vim脚本文件比较特殊，因为一个不用Vim的人不太可能会读你的代码，
并且最重要的是如果不对代码进行分组处理，写着写着你就不知道写到哪里了，严重点可能会经脉尽断，吐血而亡。

先自己尝试尝试吧，说不定你会逐渐喜欢上它。
简短的名称(Short Names)

对于大多数命令和选项，Vim支持使用它们的缩写。例如，下面的两个命令做的事情完全一样：

:setlocal wrap
:setl wrap

我_强烈_提醒你不要在你的~/.vimrc或者是你编写的插件中使用这些缩写。
Vim脚本对于初学者而言本来就已经够晦涩难懂了；
从长远来看使用缩写只会使得它更难于阅读。即使_你_知道某个缩写的意思，其他人未必读得懂。

换句话说，缩写只在编码的过程中手动执行命令的时候会很有用。
在你按了回车键以后，就没人会看到你输入什么了，这样你也没必要输入更多的字符。

% 练习
检查你的~/.vimrc文件，将所有相关的行组织起来。
你可以这么开头：“基本设置(Basic Settings)“，
”文件类型相关设置(FileType-specific settings)”，“映射(Mappings)”，
和“状态条(Status Line)”。然后在每个部分添加折叠标记和标题。

想想怎么让Vim在第一次打开~/.vimrc文件的时候自动折叠所有设置了折叠注释的行。
阅读:help foldlevelstart你会知道怎么搞。

检查你的~/.vimrc文件，把所有的命令和选项的缩写改成全称。

检查你的~/.vimrc文件，确保里面没有什么敏感信息。
然后创建一个git或者Mercurial仓库，再将~/.vimrc文件放到里面，然后将这个文件链接到~/.vimrc。

提交你刚才创建的仓库，并把它放到Bitbucket或者GitHub上，
这样其他的人都可以看到和学习它。记住要经常提交和推送到仓库中，这样你所做的修改也会被记录下来。

如果你不只在一个机器上使用Vim，那你就可以克隆那个仓库，
然后像之前一样将这个文件链接到~/.vimrc文件。这样你就可以在所有的机器上都使用同样的Vim配置了。



### =========================================================== % vimscript 变量
到目前为止我们已经讲完了单行命令。
在本书后面的三分之一个章节中将会把Vim脚本当作一个脚本语言。
这部分东西不会像前面的你学到的东西一样马上可以学以致用，
不过这是为本书的最后一部分打基础，
最后一部分会讲解创建一个插件所需要的各个方面的东西。

我们开始吧。我们首先要了解的是变量。执行下面的命令。
:let foo = "bar"
:echo foo
% Vim会显示bar。foo现在是一个变量，我们将一个字符串"bar"赋值给它。现在执行这些命令：

:let foo = 42
:echo foo
Vim会显示42，因为我们将foo赋值为整型42。
从这些小例子似乎可以看出Vim脚本是动态类型的。事实并非如此，我们之后会说明。



% 作为变量的选项
% 你可以通过一种特殊语法将_选项_作为变量来设置。执行下面的命令：

:set textwidth=80
:echo &textwidth
Vim会显示80。在名称的前面加一个&符号是告诉Vim你正在引用这个选项，而不是在使用一个名称刚好相同的变量。


% 我们来看下Vim是怎么处理布尔选项的。执行下面的命令：
:set nowrap
:echo &wrap
Vim显示0。

% 然后再试试这些选项：
:set wrap
:echo &wrap
这次Vim会显示1。这些输出很明确提示Vim会将整型0当作"false"，整型1当作"true"。
我们可以更进一步假设Vim会将所有的非0值整型当作"truthy"，而事实确实如此。


% 我们也可以使用let命令来_设置_作为变量的选项。执行下面的命令：
:let &textwidth = 100
:set textwidth?
Vim会显示textwidth=100。


% 既然set可以搞定选项的设置，那我们为什么还要用let呢？执行下面的命令：
:let &textwidth = &textwidth + 10
:set textwidth?
这一次Vim显示textwidth=110。当你用set来设置某个选项，你只能给它设置一个常量值。
当你使用let并将它作为一个变量来设置，你可以使用Vim脚本的所有强大之处来决定它的值。


%本地选项
%如果你想将某个选项作为变量来设置它的_本地_值，而不是_全局_值，你需要在变量名前面加前缀。
在两个分隔的窗口中分别打开两个文件。执行下面的命令：
:let &l:number = 1
% 然后切换到另一文件，然后再执行下面的命令：
:let &l:number = 0
注意第一个窗口会出现行号，而第二个没有。



% 作为变量的寄存器(Register)
你也可以将_寄存器_当作变量来读取和设置。执行下面的命令：
:let @a = "hello!"
现在把光标放到文本中的某个地方然后敲击"ap。这个命令会告诉Vim“在这里粘贴寄存器a中的内容”。
我们设置了这个寄存器的内容，所以Vim会将hello!粘贴到你的文本中。

% 还可以读寄存器的内容。执行下面的命令：
:echo @a
Vim会输出hello!。

% 在你的文件中选择一个单词然后用y复制，再执行下面的命令：
:echo @"
Vim会输出你刚才复制的单词。"寄存器是“未命名(unnamed)”寄存器，
在复制的时候没有指定寄存器的文本都会放到这里。

% 在你的文件中执行搜索/someword，然后执行下面的命令：
:echo @/
Vim会输出你刚刚使用的搜索模式。这样你就可以通过编程来读_和修改_当前的搜索模式，有些时候这会很有用。


% 练习
检查你的~/.vimrc文件，
然后将其中的一些set和setlocal命令替换为它们的let形式。
记住布尔选项仍然需要被设置为某个值。
尝试将某个布尔选项设置为0和1之外的值，例如wrap。
当你将它设置为一个不同的数字时会怎么样？
如果设置为字符串又会是什么情况？
回到你的~/.vimrc文件，然后恢复所有的修改。
在set可以搞定的时候，永远都不要用let，这是因为let更难于阅读。
阅读:help registers，然后看看你可以进行读和写的寄存器列表。










### =====================================================%Vimscript Execute命令
execute命令用来把一个字符串当作Vimscript命令执行。
在前面的章节我们曾经跟它打过交道， 
不过随着对Vimscript中的字符串有更深入的了解，现在我们将再次认识它。


execute基本用法
% 执行下面的命令：
% Vim把echom 'Hello, world!'当作一个命令，而且尽职地在把它输出的同时将消息记录下来。 
% Execute是一个非常强大的工具，因为它允许你用任意字符串来创造命令。
:execute "echom 'Hello, world!'"



% 让我们试试一个更实用的例子。先在Vim里打开一个文件作为准备工作，
% 接着使用:edit foo.txt在同一个窗口创建新的缓冲区。 现在执行下面的命令：
% Vim将在第二个文件的右边打开第一个文件的竖直分割窗口(vertical split)。为什么会这样？
% 首先，Vim将"rightbelow vsplit"和bufname('#')调用的结果连接在一起，创建一个字符串作为命令。
% 我们过一段时间才会讲到相应的函数，现在姑且认为它返回前一个缓冲区的路径名。 你可以用echom来确认这一点。
% 待bufname执行完毕，Vim将结果连接成"rightbelow vsplit bar.txt"。 
% execute命令将此作为Vimscript命令执行，在新的分割里打开该文件。
:execute "rightbelow vsplit " . bufname("#")




% Execute危险吗？
在大多数编程语言中使用诸如"eval"来构造可执行的字符串是会受到谴责的(如果不会是更严重的后果)。
 因为两个原因，Vimscript中的execute命令能免于操这份心。
% 首先，大多数Vimscript代码仅仅接受唯一的来源——用户的输入。 
假设有用户想输入一个古怪的字符串来执行邪恶的命令，无所谓，反正这是他们自己的计算机！ 
然而在其他语言里，程序通常得接受来自不可信的用户的输入。
Vim是一个特殊的环境， 在此无需担心一般的安全性问题。
% 第二个原因是因为Vimscript有时候处理问题的方式过于晦涩难懂且稀奇古怪。 
这时execute会是完成任务的最简单，最直白的方法。 
在大多数其他语言中，使用"eval"不会省下你多少击键的生命，但在Vimscript里这样做可以化繁为简。



% 练习
浏览:help execute来明了哪些命令你可以用execute实现而哪些不可以。 
但当涉猎，因为我们很快将重新审视这个问题。
阅读:help leftabove，:help rightbelow，
:help :split和:help :vsplit(注意最后两个条目中额外的分号)。
在你的~/.vimrc中加入能在选定的分割(竖直或水平，
上/下/左/右方位)中打开前一个缓冲区的映射。



### =======================================================%Vimscript Normal命令
目前为止我们已经介绍了几个最为常用的Vimscript命令，
但都跟日常中在normal模式下处理文本的方式无关。 
有没有一种办法能把我们的脚本跟日常的文本编辑命令结合起来呢？
% 答案显然是肯定的。之前我们已经见过normal命令，是时候更详细地介绍它了。
% Vim将把你的光标移到当前文件的最后一行，就像是在normal模式里按下G。
:normal G

% Vim将移动到文件的第一行(gg)并删除它(dd)。
% normal命令简单地接受一串键值并当作是在normal模式下输入的。就是那么简单！
:normal ggdd


% 避免映射
执行下面的命令来映射G键到别的东西：
现在在normal模式按下G将删除一整行。
:nnoremap G dd

Vim将删除当前行。normal命令将顾及当前的所有映射。
这意味着我们需要给normal提供类似于nnoremap之于nmap的版本，
 否则我们没法使用它——考虑到我们猜测不了用户的映射方式。
:normal G

幸好Vim真的有这样的命令叫normal!。执行这个命令：
这次Vim将移动光标到文件底部，即使G已经被映射了。
在写Vim脚本时，你应该_总是_使用normal!，_永不_使用normal。不要信任用户在~/.vimrc中的映射。
:normal! G


% 特殊字符
如果你使用normal!一段时间了，就很可能注意到一个问题。试试下面的命令：
:normal! /foo<cr>

第一眼看上去它应该会开始搜索foo，但你将看到它不会正常工作。 问题在于normal!不会解析像<cr>那样的特殊字符序列。
于是，Vim认为你想要搜索字符串序列"foo"，没有意识到你甚至按下了回车来进行搜索！ 
(译注：原文为you even pressed return to perform the search! 
按后文的意思应该是没有按下return,待问作者) 我们将在下一章讨论如何应对这个问题。



% 练习
阅读:help normal。在最后部分，你将获得关于下一章主题的提示。


% 附加题
如果你还没准备好面对挑战，跳过这一节。如果你够胆，祝你好运！
重温:help normal关于undo的部分。尝试设计一个删除两行却能单独撤销每次删除的映射。
 建议从nnoremap <leader>d dddd开始吧。
这次你并不真的需要normal!(nnoremap就够了)， 但是它揭示了一点：
有时阅读一个Vim命令的文档可以激发关于别的内容的奇思妙想。
如果你未尝使用过helpgrep命令，那就是时候用上它了。阅读:help helpgrep。 留心关于怎样在匹配内容中浏览的部分。
暂时先别纠结模式(patterns)，我们很快就要谈到它们。 现在只需了解你可以用类似foo.*bar来查找文档中包括该正则模式的行。
不幸的是，helpgrep会不时给你带来挫折感，因为为了找到某些词，你需要懂得去搜索某些词。 
我会帮你省下些无用功，这次你得查找到一种手工修改Vim的撤销序列的方法， 这样你映射的两个删除才能独立地撤销。
在以后你要灵活变通(pragmatic)。有时在你迷惘徘徊的时候，Google一下，你就知道。






### =======================================================%Vimscript 执行normal!

既然已经学了execute和normal!，我们就可以深入探讨一个Vimscript惯用法。 执行下面的命令：
:execute "normal! gg/foo\<cr>dd"
% 这将移动到文件的开头，查找foo的首次出现的地方，并删掉那一行。
% 之前我们尝试过用normal!来执行一个搜索命令却无法输入必须的回车来开始进行搜索。 结合execute和normal!将解决这个问题。
% execute允许你创建命令，因而你能够使用Vim普通的转义字符串来生成你需要的"打不出"的字符。 尝试下面的命令：
:execute "normal! mqA;\<esc>`q"

% 这个命令做了什么？让我们掰开来讲：
% :execute "normal! ..."  ：执行命令序列，一如它们是在normal模式下输入的，忽略所有映射， 并替换转义字符串。
    mq      ：保存当前位置到标记"q"。
    A       ：移动到当前行的末尾并在最后一个字符后进入insert模式。
    ;       ：我们现在位于insert模式，所以仅仅是写入了一个";"。
    \<esc>  ：这是一个表示Esc键的转义字符串序列，把我们带离insert模式。
    `q      ：回到标记"q"所在的位置。
% 看上去有点绕，不过它真的很有用：它在当前行的末尾补上一个分号并保持光标不动。 
% 在写Javascript，C或其他以分号作为语句分隔符的语言时，一旦忘记加上分号，这样的映射将助你一臂之力。


% 练习
重读:help expr-quote(你之前应该看过)来提醒你怎么用execute通过转义字符串传递特殊字符给normal!。
在翻开下一章之前，放下本书休息一下。吃一个三明治或喝一杯咖啡(译注：或者茶！)， 喂一下你的宠物——如果你有的话。










### ================================================================% 变量作用域
%前缀            含义
g:varname      变量为全局变量
l:varname      变量的范围为当前的函数，局部变量
s:varname      变量的范围为当前的脚本文件，当前脚本可见的局部变量
w:varname      变量的范围为当前的编辑器窗口-windows
t:varname      变量的范围为当前的编辑器选项卡，tab的局部变量
b:varname      变量的范围为当前的编辑器缓冲区-buffer
a:varname      变量是当前函数的一个参数，函数参数变量
v:varname      变量是 Vim 的预定义的内部变量



### ===========================================================% Vimscript 伪变量
&varname 	    一个Vim 选项
&l:varname 	    本地变量(局部变量)
&g:varname 	    全局变量
@varname 	    一个 Vim 寄存器
$varname 	    一个环境变量





### ========================================================% 比较操作(condition)
% 在 Vimscript 中，比较函数始终执行数字比较，除非两个运算对象都是字符串。
% 特别的，如果一个运算对象是字符串，另一个是数字，
% 那么字符串将被转换为数字，然后再对两个数字进行数值比较
let ident = 'Vim'
if ident == 0       "Always true (string 'Vim' converted to number 0)

% 在这种情况下，一种更健壮的解决方案是： if ident == '0'
% 任何字符串比较函数都可以被显式地标记为大小写敏感
% (通过附加一个 #),显式地标记为大小写敏感  ,或大小写不敏感(通过附加一个 ?)
if name == ?'vim'
if name == #'Vim'


%%%%%%%%%%%%%%%%% 防御性编程
这意味着什么？意味着在为别人开发插件时，你_不能_信任==。 
一个不加包装的==_不能_出现在你的插件代码里。
这个建议就像是"nmap VS nnoremap"一样。_永远不要_猜测你的用户的配置。 
Vim既古老，又博大艰深。在写插件时，你_不得不_假定用户们的配置五花八门，千变万化。
所以怎样才能适应这荒谬的现实？好在Vim有额外两种比较操作符来处理这个问题。
执行下面的命令：
:set noignorecase
:if "foo" ==? "FOO"
:    echom "first"
:elseif "foo" ==? "foo"
:    echom "second"
:endif
% Vim显示first因为==?是"无论你怎么设都大小写不敏感"比较操作符。现在执行下面的命令：


:set ignorecase
:if "foo" ==# "FOO"
:    echom "one"
:elseif "foo" ==# "foo"
:    echom "two"
:endif
% Vim显示two因为==#是"无论你怎么设都大小写敏感"比较操作符。
故事的最后告诉我们一个道理：你应该_总是_用显式的大小写敏感或不敏感比较。 
使用常规的形式是_错的_并且它_终究_会出错。打多一下就能拯救你自己于焦头烂额中。
当你比较整数时，这点小不同不会有什么影响。 
不过，我还是建议每一次都使用大小写敏感的比较(即使不一定需要这么做)，好过该用的时候_忘记_用了。
在比较整数时使用==#或==?都可以，而且将来一旦你改成字符串间的比较，它还会正确工作。 
如果你真想用==比较整数也不是不行，不过要铭记，一旦被改成字符串间的比较,你需要修改比较操作符。





### ==================================================% 算术运算，注意整数和实数差别
let filecount = 234
echo filecount/100          " 显示2
echo filecount/100.0        " 显示2.34



### ==========================================================% vimscript 语句

% 赋值语句：let
let {variable} = {expression}

% 条件控制if 语句：
if {condition}
    {statements}
elseif {condition}
    {statements}
else
    {statements}
endif

% while 语句：
while {condition}
    {statements}
    [ continue ]
    [ break ]
endwhile

% for 语句：
for {varname} in {listexpression}
    {statements}
endfor







### ============================================================% vimscript 函数
一如大多数编程语言，Vimscript支持函数。
让我们看看如何创建函数，然后再讨论它们的古怪之处。
执行下面的命令：    
    :function meow()
% 你可能会认为这将定义函数meow。
% 不幸的是，情况不是这样的，我们已经掉进了Vimscript其中的一个坑。
% 没有作用域限制的Vimscript函数必须以一个大写字母开头！
即使你_真的_给函数限定了作用域(我们待会会谈到)，你最好也用一个大写字母开头。 
大多数Vimscript程序猿都是这么做的，所以不要破例。



% ok，是时候认真地定义一个函数了。执行下面的命令：
% 这次Vim愉快地定义了一个函数。让我们试试运行它：
:function Meow()
:  echom "Meow!"
:endfunction
:call Meow()


% 让我们试试令它返回一个值。执行下面的命令：
% 现在执行这个命令试试：
% Vim将调用这个函数并把结果传递给echom，显示Meow String!
:function GetMeow()
:  return "Meow String!"
:endfunction
:echom GetMeow()



% 这个函数涉及到我们之前学到的许多重要概念：
    if语句
    将选项作为变量
    访问特定作用域里的选项变量
    大小写敏感的比较
% 如果你对以上内容感到陌生，最好翻到前几章温习一遍。
% 现在我们已经定义了一个函数，该函数告诉我们当前缓冲区的textwidth会不会设得‘太过宽’。 
% 因为80字符的限制适用于除了HTML之外的任何代码文件)
:function TextwidthIsTooWide()
:  if &l:textwidth ># 80
:    return 1
:  endif
:endfunction



% 现在让我们使用它。执行下面的命令：
:set textwidth=80
:if TextwidthIsTooWide()
:  echom "WARNING: Wide text!"
:endif
% 在这里我们做了什么？
    一开始我们设置全局的textwidth为80。
    接着我们运行一个if语句判断TextwidthIsTooWide()是否为真。
    由于不满足条件，if语句体(译注：包括函数内的和函数外的)不会被执行。
% 因为我们没有显式返回一个值，Vim从函数中返回代表'falsy'的0。



% 试试改变一下。运行下面的命令：
:setlocal textwidth=100
:if TextwidthIsTooWide()
:  echom "WARNING: Wide text!"
:endif
这次函数中的if执行了它的语句体，返回1，并且我们手工输入的if语句也执行了_它_的语句体。






### =============================================================== 自定义函数
function {Name}({var1}, {var2}, ...)
    {body}
    [ return ]
endfunction

%  例：求两数中最小值函数：
function! s:Min(num1, num2)
    return a:num1 < a:num2 ? a:num1 : a:num2
endfunction


% Vimscript 函数参数
毫无疑问，Vimscript函数可以接受参数。执行下面的命令：
:function DisplayName(name)
:  echom "Hello!  My name is:"
:  echom a:name
:endfunction
% 执行下面的函数：
:call DisplayName("Your Name")
% Vim将显示两行：Hello! My name is: 和 Your Name。
% 注意我们传递给echom命令的参数前面的a:。
% 这表示一个变量的作用域，在前几章(译注：第20章)我们曾讲过。
在写需要参数的Vimscript函数的时候，你_总需要_给参数加上前缀a:，来告诉Vim去参数作用域查找


% 字符串长度
:echom strlen("foo")         

% Vim显示['one','two','three']。split函数把字符串切割成列表
echo split("one two tree")  

% 字符串连接，Vim将显示foo...bar。暂时不要在意列表语法
:echo join(["foo", "bar"], "...")

% split和join可以合作无间。执行下面的命令：
% Vim显示foo;bar。首先我们把"foo bar"切割成列表，接着用分号作为分隔符把列表连接成字符串
:echo join(split("foo bar"), ";")

% 大小写转换
% Vim有两个函数来转换字符串大小写。执行下面的命令：
:echom tolower("Foo")
:echom toupper("Foo")



### ================================================================= 函数可变参数
Vimscript函数可以设计为接受不定数目的参数，
就像Javascript和Python中的一样。执行下面命令：
:function Varg(...)
:  echom a:0
:  echom a:1
:  echo a:000
:endfunction

:call Varg("a", "b")
% 这个函数向我们展示了许多东西，让我们来逐一审视。
% 函数定义中的...说明这个函数可以接受任意数目的参数。就像Python函数中的*args
% 函数中的第一行为输出消息a:0，结果显示2。当你在Vim中定义了一个接受可变参数的函数，
% a:0将被设置为你额外给的参数数量(译注：注意是额外的参数数量)。 
刚才我们传递了两个参数给Varg，所以Vim显示2。(译注：2 - 0 ==# 2)

% 第二行为输出a:1，结果显示a。
你可以使用a:1,a:2等等来引用你的函数接受的每一个额外参数。 
如果我们用的是a:2，Vim就会显示"b"

% 第三行有些费解。
当一个函数可以接受可变参数，a:000将被设置为一个包括所有传递过来的额外参数的列表(list)。 
我们还没有讲过列表，所以不要太纠结于此。你不能对列表使用echom，因而在这里用echo代替。

% 你也可以将可变参数和普通参数一起用。执行下面的命令：
:function Varg2(foo, ...)
:  echom a:foo
:  echom a:0
:  echom a:1
:  echo a:000
:endfunction
:call Varg2("a", "b", "c")
我们可以看到Vim将"a"作为具名参数(named argument)a:foo的值，将余下的塞进可变参数列表中。





### ============================================================== vim 内置寄存器
% 首先对vim中的寄存器来进行个大致浏览，它主要分为这么几个部分：
　　　　1.无名寄存器,缓存最后一次操作的内容（"" ）
　　　　2.复制专用寄存器 （"0~"9）,"0寄存器缓存最近一次复制的内容
          “1～”9寄存器缓存最近9次删除的内容
　　　　3.系统剪贴板（X11视窗系统下的主剪贴板）（"*）("+)
　　　　4.行内删除寄存器,缓存行内删除的内容 （"_）
　　　　5.命名寄存器 （a-z）
　　　　6.表达式寄存器 （=）
　　　　7.其他的一些只读寄存器（"/寄存器特殊）

% 无名寄存器保存的是dd命令删除的内容，而复制专用寄存器（0）保存的是y命令复制的内容。
% 第三个是系统剪贴板寄存器(+)和X11视窗系统的主剪贴板寄存器(*)。
个人认为这个比较常用，所以就先说了。众所周知，任何操作系统都有一个剪贴版板，
而vim就是用+寄存器来代表这个剪贴版，我经常遇到的情况就是在浏览器中复制了一段文本，
然后需要在vim中粘贴，感觉这时候这个+寄存器就大显身手了



gedit       vim
_______________________________
剪切板 <===> vim       寄存器名
cut   <===> delete      "
copy  <===> yank        0
paste <===> put


% 查看当前寄存器的内容
:reg

% 查看指定寄存器值：
:reg {register_name}



% 调取寄存器值
    NORMAL Mode：@{register_name}
    COMMAND MODE：<C-r>+"寄存器名称 (输入<C-r>后VIM会自动打出"寄存器引用符号)
    INSERT MODE：<C-r>+寄存器名称(无需输入寄存器引用符号")




==================================================== 命令的记录与回放
1 q{register_name}      %将后续的动作记录到名为{register_name}的寄存器中，
                        %其中给出的寄存器名字必须是 a到z之间的一个字母。                       
2 在命令模式中，[ 输入q，在输入a ]; 
  vim提醒你当前已经进入记录状态,这个寄存器把它命名为“a”
3 此时你所输入的任意字符都会被记录下来 ,它记录到寄存器“a”中了
4 用“q”来结束记录
5 在按“Esc”,  用“@a” 来回放你的记录




### ================================================================ copy paste

set paste



每日一Vim（8）---Vim寄存器

先抛出一个问题：每次打开Vim，想找一段文本来练练手，于是打开网页copy了一段，
问题来了，怎样粘贴到vim的编辑器里头去呢？如果你还在CTRL+v的话，说明你还无法割舍Windows，
就像东方姑娘忘不了令狐冲):这里暂且告诉你如何粘贴：SHIFT+INSERT 两个键联合起来。再来看下面的原理 

寄存器是Vim用来存储文件的临时空间，当使用命令y（yank）或d（delete）复制删除文本时，
该文本就会被保存在寄存器中，通过p（put）命令插入刚删除或复制的内容。vim的寄存器分为不同的种类：

数字寄存器：
在normal模式下输入:reg，您是否看到很多“（双引号）开头的数字了呢，这些都是寄存器，
（如果暂时没看到，那么在对文本做几个操作，比如：dd,yy等），这些寄存器里保存了最近删除的和复制的文本。

数字寄存器有十个，分别是："0，"1，"2... "9（注意：数字前有个双引号），
寄存器"0保存上一次复制(y)操作的文本，"1到"9寄存器保存最近9次删除的文本行（注意这个“行”字），
"1保存的内容是最最近一次删除的内容（也就是说最后一次执行删除命令保存的内容）
"2保存的是倒数第二次删除的内容，依此类推，直到"9，如果又有新的操作，
那么"9的内容将会被"8的内容替换，先前”9的内容将被丢弃。 

那么p（put）命令粘贴是哪个寄存器中的内容呢？
有时候是粘贴的是"1寄存器的，有时粘贴的是"0寄存器中的，
但是总的原则就是粘贴最近一次删除或者复制的内容，
如果删除是最近的一次，就是粘贴"1的，也就是粘贴刚刚删除的文本，
如果复制是最近的一次操作，那么粘贴的内容是"0中的，也就是粘贴刚刚复制的内容。



字母寄存器：

"a，"b，"c...都是字母寄存器，也许你执行:reg的时候看不到这些命令，不要紧，稍后就有了。
之前粘贴我们用的都是p命令，如果我想粘贴其他寄存器里面的内容呢，
你想到了吗？答案就是：寄存器的名称+p。现在我们新建一个字母寄存器，
把当前三行保存到"a寄存器中去，具体操作如下：在normal模式下输入"a3yy，
这样当前三行就保存在"a中去了，粘贴同样在normal模式下，"3p 即可。
如果是大写字母的寄存器，如执行："Cdd：他的作用是把当前行删除，
再把内容追加到"c寄存器中，也就是说字母寄存器没有大写之分，只是功能上有区别，大写就是追加，小写是替换。


其他寄存器：
""：无名寄存器，p命令粘贴的内容，保存最近一次删除或复制的内容。
“-：（-是个减号）小删除寄存器（small delete register），
前面说过要您注意这个”行“字，也就是说并不是所有删除的文本都会保存在数字寄存器中，
如果你删除的只是一个单词或字母： dw或者x，那么这个单词并不会保存在"1寄存器中，
而是保存在"-寄存器里面。所有不包含换行符的删除都会保存在此寄存器中。

"* ：这个就是系统寄存器喽，最开始的问题的第二个答案知道了吧 




















