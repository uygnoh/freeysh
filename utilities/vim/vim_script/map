###
### =======================================================% Vimscript 基本映射
我们先从normal模式的键盘映射开始。
随意在文本中敲写几行文字，然后运行命令： 将光标置于文本中的某处，按下-。
注意Vim删除了当前光标下的字符，就好像你按了x一样, 我们本来就有个按键用于 "删除当前光标下的字符" 
    :map - x            % 将“-” 重新映射到 “x”
    :map - dd           % 将“-” 重新映射到 “dd”

% 特殊字符; 你可以使用<keyname>告诉Vim一个特殊的按键。
% 现在在键盘上按下Ctrl+d将执行dd命令。
:map <C-d> dd


% 特殊字符; 你可以使用<keyname>告诉Vim一个特殊的按键。
% 移动光标到一个单词上，按下空格键。Vim将高亮选中整个单词。
:map <Space> viw





### ======================================================% Vimscript 模式映射
上一章中我们谈论了如何在Vim中映射按键。
我们使用的命令map在normal模式下工作。 
如果阅读本章之前你自己已经折腾了，
可能会注意到这个映射在visual模式一样工作。
你可以使用nmap、vmap和imap命令分别指定
映射仅在normal、visual、insert模式有效。


% 在normal模式下，按下\。Vim会删除当前行。
% 现在进入Visual模式，再次按下\。什么都不会发生，
% 因为我们告诉了Vim这个映射仅在normal 模式下工作（同时\的默认行为是什么都不做）。
:nmap \ dd

% 进入visual模式并选中一些文字，按下\。Vim将把选中文本转换成大写格式。
% 分别在normal模式和visual模式测试\按键，注意不同模式下的效应。
:vmap \ U


% 你可能猜想这个命令的作用是在insert模式下通过按键Ctrl+d删除整行。这个映射很实用， 
% 因为你不必每次都要为了删除某些行而切回到normal模式。
% 好的我们试一下。它并不如我们想象那般工作，而仅仅是在文件中添加了两个d字符！ 它压根就没用。
% 问题就在于Vim只按我们说的做。这个例子中，我们说：“当我按下<C-d>时，相当于我 按了两次d”。
% 而当你在insert模式下，按下两次d的作用就是输入两个字符d。
:imap <C-d> dd


% 要想让这个映射按我们的期望执行，我们需要更加明确的指令。修改映射并运行如下命令：
% <Esc>告诉Vim按下ESC按键，即退出insert模式。
% 现在再试试这个映射。它能够正常工作，但是注意你是如何回到normal模式的。
% 这是因为我们 告诉Vim<C-d>要退出insert模式并删除一行，但是我们没有告诉它再回到insert模式。
:imap <C-d> <Esc>dd


% 运行如下命令，修复映射问题：
% 结尾的i告诉Vim进入insert模式，至此我们的映射才最终完成。
:imap <C-d> <Esc>ddi





### =======================================================% Vimscript 非递归映射
每一个*map系列的命令都有个对应的*noremap命令，
包括：*noremap/nnoremap、 vnoremap和inoremap
这些命令将不递归解释映射的内容, 
vim中键盘映射有三类：visual，insert和normal
inoremap是用于insert模式的非递归映射，
nnoremap是用于normal模式的非递归映射，
vnoremap是用于visual模式的非递归映射.

% 该何时使用这些非递归的映射命令呢？
% 答案是： 任何时候, 是的，没开玩笑， 任何时候 
% 在安装插件或添加新的自定义映射时使用*map系列命令纯属是给自己 找 麻烦。 
% 多敲几个字符以确保这个问题不会发生，救自己于火海。



% 一个更为复杂的Mapping
% 你已经见过很多简单的mappings了，是时候看看一些复杂的了。运行下面的命令：
    :nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel
%那是一个有趣的mappings！你自己可以先试试。
%进入normal模式，移动光标至一个单词， 输入<leader>" ,Vim将那个单词用双引号包围！
%它是如何工作的呢？我们拆分这个映射并逐个解释：
    viw<esc>a"<esc>hbi"<esc>lel

    viw     :高亮选中单词
    <esc>   :退出visual模式，此时光标会在单词的最后一个字符上
    a       :移动光标至当前位置之 后 并进入insert模式
    "       :插入一个 "
    <esc>   :返回到normal模式
    h       :左移一个字符
    b       :移动光标至单词头部
    i       :移动光标至当前位置之 前 并进入insert模式
    "       :插入一个"
    <esc>   :返回到normal模式
    l       :右移一个字符，光标置于单词的头部
    e       :移动光标至单词尾部
    l       :右移一个字符，置光标位置在第一个添加的引号上
% 记住：因为我们使用的是nnoremap而不是nmap，所以尽管你映射了字符序列中的字符 也不会有影响。
% Vim会将其中的字符按默认功能执行。希望你能看出Vim mappings的潜能及随之引发的阅读困难。



% ESC <=========> JK  [KEY-MAPPING]  减轻负担映射
% 让我们先创建一个mapping，这个mapping会为你的左手减轻很多负担。执行下面的命令：
% ok，现在进入插入模式然后敲击jk。Vim会返回到常用模式，就像你敲击了escape按键一样。
    :inoremap jk <esc>
% 这个命令会告诉Vim在插入模式下敲击escape按键后执行<nop>(no operation)，
% 这样escape按键在插入模式下就无效了。ok，现在你就_不得不_使用jk这个mapping来退出插入模式了。
    :inoremap <esc> <nop>



  
### =================================================== % Operator-Pending映射
这一章我们将来探索Vim映射系统中另外一个神奇的部分：
“Operator-Pending映射”。
开始之前，我们先解释下这里面的几个词含义。
一个Operator（操作）就是一个命令，
你可以在这个命令的后面输入一个Movement（移动）命令，
然后Vim开始对文本执行前面的操作命令，
这个操作命令会从你当前所在的位置开始执行，
一直到这个移动命令会把你带到的位置结束。

% 常用到的Operator有d，y和c。例如：
按键    操作       移动
----   --------  -------------
dw     删除       到下一个单词
ci(    修改       在括号内
yt,    复制       到逗号


% Movement映射
% Vim允许你创建任何新的movements，这些movements可以跟所有命令一起工作。执行下面的命令：
    :onoremap p i(
% 在缓冲区中输入下面的文字：
    return person.get_pets(type="cat", fluffy_only=True)
把光标放到单词“cat”上，然后敲击dp。结果会发生什么？Vim会删除括号内的所有文字。
你可以把这个新建的movements当作“参数”。
onoremap命令会告诉Vim当它在等待一个要附加在operator后面的movement的时候，
如果这个movement是p的话，它会把它当作i(。所以当我们在运行dp的时候，
就象是在对Vim说“delete parameters”，而Vim会把它理解为“在括号内删除”。

% 我们现在可以立马对所有的operators使用这个新建的映射。
% 再次在缓冲区中输入上面的文字（或者直接把之前修改恢复一下）。
    return person.get_pets(type="cat", fluffy_only=True)
把光标放到单词“cat”上，然后敲击cp。这次又会发生什么？
Vim会删除括号中的所有文字，不过这一次删除之后Vim会处于插入模式，
这是因为你使用的是“change”，而不是“delete”。



% 再看一个示例。执行下面的命令：
    :onoremap b /return<cr>
现在把下面的文字输入到缓冲区：
def count(i):
    i += 1
    print i

    return foo
把光标放到第二行的i上，然后按下db。会发生生么？
Vim把整个函数体中直到return上面的内容都删除了，
return就是上面的映射使用Vim的通用查找得到的结果。



% 当你想搞清楚怎么定义一个新的operator-pending movement的时候，你可以从下面几个步骤来思考：
        1    在光标所在的位置开始。
        2    进入可视模式(charwise)。
        3    ... 把映射的按键放到这里 ...
        4   所有你想包含在movement中的文字都会被选中。
% 你所要做的工作就是在第三步中填上合适的按键。



% 改变开始位置
% 你可能已经从上面所学的东西中意识到一个了问题。
% 如果我们定义的movements都是从光标所在的位置开始的话，那么这就会限制我们做一些我们想使用movement来做的事情。
% 但是Vim并不会限制你去做你想做的事情，所以对于这个问题肯定有解决办法。执行下面的命令：
    :onoremap in( :<c-u>normal! f(vi(<cr>
% 这个命令看起来有些复杂，不过我们还是先试试它能干什么。将下面的文字输入缓冲区：
    print foo(bar)
把光标放到单词print上面，然后敲击cin(。Vim会删除括号内的内容然后进入插入模式，并且光标会停留在括号的中间。
你可以将这个映射理解为“在下一个括号内(inside next parentheses)”。
它会对当前行光标所在位置的下一个括号内的文本执行operator。

% 我们再创建一个“在上一个括号内(inside last parentheses)”的movement进行对照。
% （在这里使用“前一个(previous)“可能更准确，但这会覆盖“段落(paragraph)”movement）
    :onoremap il( :<c-u>normal! F)vi(<cr>
% 先试试确保这个命令可以工作。那么这些映射是怎么工作的呢？
% 首先，<c-u>比较特殊，可以先不用管（你只需要相信我这个东西可以让这个映射在任何情况下都能正常工作）。
% 如果我们删除它的话，这个映射会变成这个样子：
    :normal! F)vi(<cr>
:normal!会在后面的章节谈到，现在你只需要知道它可以在常用模式下模拟按下按键。
例如，运行:normal! dddd会删除两行，就像按下dddd。映射后面的<cr>是用来执行:normal!命令的。

% 那么现在我们可以认为这个映射的关键是运行下面这些按键组成的命令： 
% F)vi(  This is fairly simple: 这个命令很容易理解：
        F): 向后移动到最近的)字符。
        vi(: 进入可视模式选择括号内的所有内容。
% 这个movement结束在在可视模式下选择中我们想操作的文本，然后Vim会对选中的文本执行操作，就像通常情况一样。

% 一般规则
下面两条规则可以让你可以很直观的以多种方式创建operator-pending映射：
    如果你的operator-pending映射以在可视模式下选中文本结束，Vim会操作这些文本。
    否则，Vim会操作从光标的原始位置到一个新位置之间的文本。
    
    
% 练习
为"around next parentheses"和"around last
 parentheses"创建operator-pending映射
为打括号创建类似的in/around next/last的mappings。
阅读:help omap-info，看看你可不可以搞清楚<c-u>是干啥的。


### ================================================== %更多Operator-Pending映射
Operators和movements所包含的理念是Vim中的一个非常重要的概念，
也是Vim之所以这么高效的最大原因所在。
在这一章我们会在这一块做更多的实践，
这会让Vim变得更强大。
假设你现在在往Markdown中写入一些文字。
如果你没有用过Markdown，
不要紧，对于我们现在要做的事情而言，
它很简单。把下面的文字输入到一个文件中：

Topic One
=========

This is some text about topic one.

It has multiple paragraphs.

Topic Two
=========

This is some text about topic two.  It has only one paragraph.


% 使用=作为“下划线”的行会被Markdown当作标题。我们现在创建一些映射，
% 这些映射可以让我们通过movements定位到标题。运行下面的命令：
% 这个映射有些复杂。现在把你的光标放到文本中的某个位置（不要放到标题上）,然后敲击cih。
% Vim会删除光标所在章节的标题，然后保持在插入模式，这可以称为"修改所在的标题(change inside heading)"
    :onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
    

% 这里使用了一些我们之前从来没有见过的东西，所以我们有必要单独分析下每一部分的含义。
% 这个映射的第一部分，:onoremap ih是映射命令，这个我们很熟悉了，无需多言。
% <c-u>上一章讲过，我们现在也不深究。
% 接着看看剩下的部分：
    :execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>

Normal ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% :normal命令的后面会跟着一串字符，无论这些字符表示什么含义，
% :normal命令都会执行它们，就像是在常用模式下敲击这些字符一样。
% 我们会在后面的章节中谈论关于:normal的更多细节，由于这个它已经出现多次，
% 所以我觉得有必要现在做一个简单的说明，算是浅尝辄止吧。执行下面的命令：
% Vim会将光标跳转到文件的顶部。
:normal gg

% 现在执行下面的命令：Vim将缩进当前行。
% 那normal后面的!是干啥的呢？先别管，以后再说。
:normal >>



Execute ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% execute命令后面会跟着一个Vim脚本字符串（以后会深究它的细节），
% 然后把这个字符串当作一个命令执行。执行下面的命令：
% Vim会写文件，就像你已经输入了:write<cr>一样
:execute "write"

% 现在执行下面的命令：
% Vim会执行:normal! gg，这个会将光标跳转到文件的顶部，跟之前一样。
:execute "normal! gg"


% 现在问题来了，我们为什么要搞得这么蛋疼，
% 又是execute，又是normal!，直接执行normal!不就可以搞定么？
% 看看下面的命令，猜猜它会干啥：
:normal! gg/a<cr>

% 这个命令似乎会做下面的一些事情：
1    将光标跳转到文件的顶部。
2    准备搜索。
3    把“a”当作目标字符串进行搜索。
4    按下return键执行搜索。
你自己执行一下，Vim会将光标跳转到了文件顶部，然后。。没有然后了！
之所以会这样是由于normal!的一个问题，这问题是normal!不能识别“特殊字符”，
例如这里的<cr>。这个问题有很多办法可以搞定，最简单的就是使用execute，另外使用execute也会让脚本更易读。
当execute碰到任何你想让它执行的字符串的时候。它会先替换这个字符串中的所有特殊字符。
在这个示例中，\r是一个转义字符，它表示的是"回车符（carriage return）"。
两个反斜线也是一个转义字符，它会将一个反斜线当作一般字符放到字符串中。



% 如果我们按照上面的分析替换这个映射中的特殊字符，然后就可以搞清楚这个映射会怎么执行：
:normal! ?^==\+$<cr>:nohlsearch<cr>kvg_
                ^^^^           ^^^^
                 ||             ||
这里的<cr>实际上是一个回车符，而不是由4个字符——“左尖括号”，“c“，”r“和“右尖括号”组成的字符串。
所以现在normal!会执行这些字符，如同我们是在常用模式下敲击了它们一样。我们以回车符对这些字符进行拆分，
然后看看它们是怎么执行的：
        ?^==\+$
        :nohlsearch
        kvg_
% 第一部分
第一部分?^==\+$会向后搜索任何由两个或多个等号组成的行，这些行不会包含除等号外的任何其他字符。
这个命令执行后会让光标停留在符合搜索条件的行的行首。
之所以使用向后搜索，是因为当你想“修改所在的标题(change inside heading)”的时候，
而当前光标是位于某一节的文本上，那么你最可能想做的是修改_这_一节的标题，而不是下一节的标题。

% 第二部分
第二部分是:nohlsearch命令。这个命令只是简单的清除之前的搜索结果的高亮显示，防止这些高亮显示分散我们的注意。

% 第三部分
最后一部分是三个常用模式下的命令的序列：
    k：向上移动一行。第一部分已经将光标定位到了等号符号组成的行的第一个字符，
       所以执行这个命令后光标就会被定位到标题的第一个字符上。
    v：进入可视模式(characterwise)。
    g_：移动到当前行的最后一个非空字符上。这里没有使用$，是因为$会选中换行符号，这不是我们所想要的。





% 再来看一个映射。执行下面的命令：
% 把光标放到某一节的文字上，然后敲击cah试试看。这一次Vim不仅会删除这一节的标题，
% 而且还会删除跟这个标题相连的等号组成的行。
% 你可以把这个movement当作是“_环绕_这一节的标题(around this section's heading)“。
    :onoremap ah :<c-u>execute "normal! ?^==\\+\r:nohlsearch\rg_vk0"<cr>

% 这个映射有什么不同呢？让我们对照之前的映射看一下：
:onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
:onoremap ah :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rg_vk0"<cr>

%唯一的不同是映射的后面用于选择文本的部分：
    inside heading: kvg_
    around heading: g_vk0
% 其他的部分都是一模一样的，所以我们现在从将光标定位到等号组成的行的第一个字符的那个部分开始进行讲解：
    g_：移动到当前行（译注：等号组成的行）的最后一个非空字符。
    v：进入可视模式(characterwise)。
    k：向上移动一行。这会将光标移动到包含标题文字的行上。
    0：移动到这一行（译注：标题行）的第一个字符。
% 这一系列命令的执行结果就是在可视模式下同时选中标题的文字和等号组成的行，然后Vim会在这两行上执行相应的操作。



% 练习
Markdown也可以用-字符来限定标题。
调整上面的正则表达式使得这些映射可以工作在不同类型的标题上。
你可能想查看:help pattern-overview。
记住正则表达是在一个字符串中，所以反斜线需要进行转义。
添加两个创建这些映射的自动命令到你的~/.vimrc文件中。
确保只对合适的缓冲区使用这些映射，
并且确保使用自动命令组来防止每次加载~/.vimrc的时候创建这些自动命令的副本。
阅读 :help normal。
阅读 :help execute。
阅读 :help expr-quote了解你可以在字符串中使用的转义序列。
创建一个“在下一个邮件地址内(inside next email address)”的operator-pending映射，
然后你就可以使用“修改在下一个邮件地址内(change inside next email address)”。
将in@作为映射的按键是个不错的选择。你可能还需要将这个按键映射为/...some regex...<cr>。

