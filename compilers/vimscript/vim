### % https://www.w3cschool.cn/vim/gsenvozt.html
" 插件管理
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif


### ========================================================= vimscript 一些概念
"buffer"、"window"、 "normal mode"、"insert mode"、"text mode"

   
% Buffer
Vim 中的 Buffer 是文件在内存中的缓存数据，一个 Buffer 总是也只能是对应一个文件。
当你使用 edit(e) 命令的时候，实际上就是将文件内容载入到 Buffer 里面。
bnext/bprevious/bdelete/bwipe 命令的操作对象都是 Buffer，
这也就是为什么执行 bnext 有时可以切换文件的原因。至于为什么是 “有时”，稍后再作解释。
现在你只需记住，这几个命令都是直接对于文件缓存的操作。


% Window
用习惯 Sublime 或者 VS Code（以下简称 Vsc）的人可能会习惯性地把 Window 理解为窗口，
把 split/vsplit 理解为分屏命令。但是这根本没办法解释为什么切换 Tab 的时候分屏会消失，
按照之前的经验，切换 Tab 应该不影响分屏的展示才对。

其实 Window 跟前面说的两款编辑器中的窗口根本不是一个概念，
在 Vim 中，Window 只负责展示 Buffer 的数据且不会影响 Buffer。
当我们执行 split 或者 vsplit 的时候，其实是打开了一个新的 Window 并载入当前的 Buffer，
而当我们使用 q 命令关闭一个窗口时，并不会关闭相应的 Buffer。
除此之外，使用 help 命令、使用 NERDTree 打开文件树、使用 Tagbar 打开标签界面的时候，都是打开了一个新的 Window。
一个 Window 在同一时间内只能展示一个 Buffer，一个 Buffer 可以同时被多个 Window 展示，
使用上一节中的命令可以切换 Window 中展示的 Buffer。



% Tab
理解了上面两个概念之后，Tab 就很好解释了。Tab 是一系列 Window 的集合，是一种 “布局”。
一个 Tab 上可以有多个 Window，不同 Tab 之间的 Window 互不影响。


% Buffer、Window 和 Tab 之间的关系
理解完上面这些概念之后，我想你大概已经明白了，在 Vim 中这三者的关系大概是这样的：
Buffer 负责保存数据，Window 负责展示数据，Tab 为 Window 提供排版布局，
Buffer 和 Tab 对 Window 总是一对多的关系。如果把 Vim 想象成一个机房的话，Buffer 就是主机，
Window 是显示器，而 Tab 是一个个显示器架子。只不过这个机房里面的显示器可以随意连接到别的主机上面，
一个主机可以被多个显示器连接。

% 为什么 bnext/bprevious 可以打开分屏？
前面提到过，尽管 Buffer 只是负责数据的保存，并不关心数据的展示，
而 bnext/bprevious 命令是用于切换 Buffer 的，
可是有时候调用 bnext/bprevious 命令却打开了一个新的 Window！这种奇怪的现象其实跟你的配置有关系，
Vim 里面有一个 hidden 配置项，它负责告诉 Vim 是否允许隐藏一个未保存的 Buffer。
当你 :set nohidden 时，Vim 会在切换 Buffer 的时候检测当前 Buffer 是否保存，
如果还未保存，则会以打开一个新 Window 的形式打开另一个 Buffer。
博主的建议是在 vimrc 中加入 set hidden，这样才不容易导致迷惑。


% 导致迷惑的根源
拿 Vsc 来作比较，就很容易理解为什么在 Vim 中这三者容易导致迷惑了。
在 Vsc 里面，一个 Tab 对应了一个文件（注：这里指双击打开的文件，而不是单击用浏览模式打开），
一个 Tab 永远都只会显示同一个文件。明白了吗？其实 Vsc 里面的 Tab 更像是 Vim 里 Window 的概念。
只不过 Vsc 中这两者是一种一经打开就无法修改的强一一对应的关系，而 Vim 却可以做到随意切换。
而 Vsc 的窗口分屏却有点类似于 Vim Tab 的概念，只不过 Vsc 的布局只能有一种，而 Vim 可以有多种布局，随意切换。

类似于 Vsc 这样的编辑器把布局和展示的概念简化了，通过建立一种只有一个布局（Vim 中的 Tab，Vsc 中的窗口），
展示（Vim 中的 Window，Vsc 中的 Tab）和数据强一一对应的机制，使得编辑器的使用更加简单，不容易出错。
而 Vim 却不会管那么多，它向你提供 Buffer、Window 和 Tab，具体要怎么用，是操作者应该考虑的问题。


% 孰优孰劣？
尽管 Vsc 这类编辑器操作更加友好，使用更加简单，但却没有 Vim 那么灵活，丧失了可定制性。
而 Vim 为了灵活性却导致了学习成本太高，使人望而生畏。
博主个人是比较倾向于 Vsc 那种操作逻辑的（以为我会夸 Vim？不存在的），
在我个人的日常工作中也是尽量简化了 Vim 里面这三者的使用。
不过还是推荐读者们根据个人习惯进行定制，毕竟自己用得顺手才是最好的。


% 个人使用经验
由于 Tmux 这种神器的存在，而且刚入职不久公司还没给配屏幕，
除非多项目切换频繁，博主一般不会使用多 Tab，也不使用分屏，
而是使用单 Tab、单 Window、多 Buffer 切换的模式，把分屏的工作交给 Tmux。
这样一来就可以大大简化会使用到的快捷键。下面奉上个人配置：

   
### ======================================================= %  vim 语法基本特征
### 创建Vimrc文件 
~/.vimrc文件包含了Vimscript代码，每次启动Vim时，Vim都会自动执行其中的代码
在Linux和Mac OS X中，这个文件位于你的home文件夹，并以.vimrc命名
在Windows中，这个文件位于你的home文件夹，并以_vimrc命名
% 在_任意_系统中，在Vim中执行以下命令可以快速得知这个文件的位置和名称
% 如果你的home文件夹没有这个文件，请自行创建一个
:echo $MYVIMRC


### Vimscript 打印信息 
Vimscript中，我们最先关注的是 echo和echom 命令。
你可以在Vim中执行[:help echo]和[:help echom]命令以查看其帮助文档。
读完本书之后， 再次遇到新的命令时，你应该先执行:help命令查看其帮助文档。
% 执行如下命令，体验echo命令：
:echo "Hello, world!"

:echom "Hello again, world!"
%执行如下命令，查看上述两个打印命令的区别：
:messages
% 你应该会看到一些消息。Hello, world!应该_不在_其中，但是Hello again, world! 在。

当你写更为复杂的Vimscript时，你可能会想"打印一些信息"以方便调试程序。
:echo命令 会打印输出，但是一旦你的脚本运行完毕，那些输出信息就会消失。
使用:echom打印的信息 会保存下来，你可以执行:messages命令再次查看那些信息。


### 继续之前，咱们先看看如何添加注释
% 当你写Vimscript脚本时(在你的~/.vimrc文件中或 其它任意文件)，
% 你可以通过"字符添加注释，例如：
" Make space more useful

"       注释
\       续行

阅读:help echo帮助文档。
阅读:help echom帮助文档。
阅读:help messages帮助文档。


### ======================================================= %Vimscript 设置选项
% Vim拥有很多选项可以设置以改变其展现方式。
% 主要有两种选项：布尔选项（值为"on"或"off"）和键值选项。
% 布尔选项, 执行如下命令： 那么现在你就会看见行号
:set number
% 执行命令：行号应该消失
:set nonumber

% number是一个布尔选项：可以off、可以on
通过:set number命令打开、 :set nonumber命令关闭。
所有的布尔选项都是这种配置方法。
:set <name>打开选项、:set no<name>关闭选项。

% 切换布尔选项你可以"切换"布尔选项的值，即从开启切为关闭或从关闭切为开启
执行命令：
:set number!

% 查看选项当前值, 你可以使用一个?
?符号向Vim获取一个选项的当前值。执行如下命令并查看每个命令的 返回结果
:set number?

% 键值选项, 有些选项并不只有off或on两种状态，它们需要一个值。
% numberwidth选项改变行号的列宽。
你可以通过 :set <name>=<value> 命令改变 非布尔选项的选项值，
你可以通过 :set <name>?        命令查看选项的当前值。
% 执行如下命令，查看返回结果：
:set number
:set numberwidth=10
:set numberwidth=4
:set numberwidth?

% 来看看vimscript一些常用选项的值：
:set wrap?
:set shiftround?
:set matchtime?

% 一次性设置多个选项, 最后，你可以在一个:set命令中设置多个选项的值。试试如下命令：
% 注意最后一个命令是如何一次性设置两个选项值的
:set numberwidth=2
:set nonumber
:set number numberwidth=6


% vimscript 帮助文档
阅读:help 'number'（注意有单引号）帮助文档。
阅读:help relativenumber帮助文档。
阅读:help numberwidth帮助文档。
阅读:help wrap帮助文档。
阅读:help shiftround帮助文档。
阅读:help matchtime帮助文档。



### =======================================================% Vimscript 基本映射
我们先从normal模式的键盘映射开始。
随意在文本中敲写几行文字，然后运行命令： 将光标置于文本中的某处，按下-。
注意Vim删除了当前光标下的字符，就好像你按了x一样, 我们本来就有个按键用于 "删除当前光标下的字符" 
    :map - x            % 将“-” 重新映射到 “x”
    :map - dd           % 将“-” 重新映射到 “dd”

% 特殊字符; 你可以使用<keyname>告诉Vim一个特殊的按键。
% 现在在键盘上按下Ctrl+d将执行dd命令。
:map <C-d> dd


% 特殊字符; 你可以使用<keyname>告诉Vim一个特殊的按键。
% 移动光标到一个单词上，按下空格键。Vim将高亮选中整个单词。
:map <Space> viw





### ======================================================% Vimscript 模式映射
上一章中我们谈论了如何在Vim中映射按键。
我们使用的命令map在normal模式下工作。 
如果阅读本章之前你自己已经折腾了，
可能会注意到这个映射在visual模式一样工作。
你可以使用nmap、vmap和imap命令分别指定
映射仅在normal、visual、insert模式有效。


% 在normal模式下，按下\。Vim会删除当前行。
% 现在进入Visual模式，再次按下\。什么都不会发生，
% 因为我们告诉了Vim这个映射仅在normal 模式下工作（同时\的默认行为是什么都不做）。
:nmap \ dd

% 进入visual模式并选中一些文字，按下\。Vim将把选中文本转换成大写格式。
% 分别在normal模式和visual模式测试\按键，注意不同模式下的效应。
:vmap \ U


% 你可能猜想这个命令的作用是在insert模式下通过按键Ctrl+d删除整行。这个映射很实用， 
% 因为你不必每次都要为了删除某些行而切回到normal模式。
% 好的我们试一下。它并不如我们想象那般工作，而仅仅是在文件中添加了两个d字符！ 它压根就没用。
% 问题就在于Vim只按我们说的做。这个例子中，我们说：“当我按下<C-d>时，相当于我 按了两次d”。
% 而当你在insert模式下，按下两次d的作用就是输入两个字符d。
:imap <C-d> dd


% 要想让这个映射按我们的期望执行，我们需要更加明确的指令。修改映射并运行如下命令：
% <Esc>告诉Vim按下ESC按键，即退出insert模式。
% 现在再试试这个映射。它能够正常工作，但是注意你是如何回到normal模式的。
% 这是因为我们 告诉Vim<C-d>要退出insert模式并删除一行，但是我们没有告诉它再回到insert模式。
:imap <C-d> <Esc>dd


% 运行如下命令，修复映射问题：
% 结尾的i告诉Vim进入insert模式，至此我们的映射才最终完成。
:imap <C-d> <Esc>ddi





### =======================================================% Vimscript 非递归映射
每一个*map系列的命令都有个对应的*noremap命令，
包括：*noremap/nnoremap、 vnoremap和inoremap
这些命令将不递归解释映射的内容, 
vim中键盘映射有三类：visual，insert和normal
inoremap是用于insert模式的非递归映射，
nnoremap是用于normal模式的非递归映射，
vnoremap是用于visual模式的非递归映射.

% 该何时使用这些非递归的映射命令呢？
% 答案是： 任何时候, 是的，没开玩笑， 任何时候 
% 在安装插件或添加新的自定义映射时使用*map系列命令纯属是给自己 找 麻烦。 
% 多敲几个字符以确保这个问题不会发生，救自己于火海。



% 一个更为复杂的Mapping
% 你已经见过很多简单的mappings了，是时候看看一些复杂的了。运行下面的命令：
    :nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel
%那是一个有趣的mappings！你自己可以先试试。
%进入normal模式，移动光标至一个单词， 输入<leader>" ,Vim将那个单词用双引号包围！
%它是如何工作的呢？我们拆分这个映射并逐个解释：
    viw<esc>a"<esc>hbi"<esc>lel

    viw     :高亮选中单词
    <esc>   :退出visual模式，此时光标会在单词的最后一个字符上
    a       :移动光标至当前位置之 后 并进入insert模式
    "       :插入一个 "
    <esc>   :返回到normal模式
    h       :左移一个字符
    b       :移动光标至单词头部
    i       :移动光标至当前位置之 前 并进入insert模式
    "       :插入一个"
    <esc>   :返回到normal模式
    l       :右移一个字符，光标置于单词的头部
    e       :移动光标至单词尾部
    l       :右移一个字符，置光标位置在第一个添加的引号上
% 记住：因为我们使用的是nnoremap而不是nmap，所以尽管你映射了字符序列中的字符 也不会有影响。
% Vim会将其中的字符按默认功能执行。希望你能看出Vim mappings的潜能及随之引发的阅读困难。



% ESC <=========> JK  [KEY-MAPPING]  减轻负担映射
% 让我们先创建一个mapping，这个mapping会为你的左手减轻很多负担。执行下面的命令：
% ok，现在进入插入模式然后敲击jk。Vim会返回到常用模式，就像你敲击了escape按键一样。
    :inoremap jk <esc>
% 这个命令会告诉Vim在插入模式下敲击escape按键后执行<nop>(no operation)，
% 这样escape按键在插入模式下就无效了。ok，现在你就_不得不_使用jk这个mapping来退出插入模式了。
    :inoremap <esc> <nop>




### =======================================================% Vimscript Leaders
VIM->LEADER 这就意味着你可以用一个你不常用的按键（如-）作为“前缀”
后接其它字符作为一个整体 进行映射。
你需要多敲一个按键以执行这些映射，多一个按键而已

% 如果你也认为这是个好方法，我可以告诉你，Vim已经支持这种机制。
% Leader，我们称这个“前缀”为“leader”。你可以按你的喜好设置你的leader键。运行命令：
:let mapleader = "-"

% 你可以替换-为你喜欢的按键。尽管会屏蔽一个有用的功能，但我个人使用的是,，因为这个键比较比较容易按到。
% 当你创建新的映射时，你可以使用<leader>表示“我设置的leader按键”。运行命令：
:nnoremap <leader>d dd
% 现在试试按下你的leader按键和d。Vim会删除当前行。
% 然而为何每次都要繁琐的设置<leader>？
% 为什么创建映射时不直接敲入你的“前缀”按键？ 原因主要有三个 @@@?
% 首先，你某天可能会想要更换你的“leader”。在一个地方定义它使得更方便更换它。
% 第二，其他人看你的~/.vimrc文件时，一旦看到<leader>就能够立即知道你的用意。
% 如果他们 喜欢你的~/.vimrc配置，即使他们使用不同的leader也可以简单的复制你的映射配置。
% 最后，许多Vim插件都会创建以<leader>开头的映射。如果你已经设置了leader，你会更容易上手 使用那些插件。



Local Leader ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% Vim有另外一个“leader”成为“local leader“。
% 这个leader用于那些只对某类文件 （如Python文件、HTML文件）而设置的映射。
% 本书将在后续章节讲述如何为特定类型的文件创建映射，但你可以现在创建一个“localleader”：
% 注意我们使用 ”\\“而不是”\“， 因为\在Vimscript中是转义字符。
% 现在你就可以在映射中使用<localleader>了，使用方法和<leader>一样（当然， 你要使用另外一个前缀）。
% 如果你不喜欢反斜线，请随意更改它。
:let maplocalleader = "\\"





### ===================================================% Abbreviations 缩写形式
Vim有个称为"abbreviations"的特性，与映射有点类似，
但是它用于insert、replace和 command模式。
这个特性灵活且强大，不过本节只会谈及最常用的用法。

% 本书只会讲述insert模式下的abbreviations。运行如下命令：
% 进入insert模式并输入：One adn two.
% 在输入adn之后输入空格键，Vim会将其替换为and。
:iabbrev adn and


% 诸如这样的输入纠错是abbreviations的一个很实用的用法。运行命令：
% 再次进入insert模式并输入： Well, I don't know waht we should do tehn.
% 注意 两个 abbreviations的替换时机，第二个没有输入空格却也替换了。
:iabbrev waht what
:iabbrev tehn then


% Keyword Characters
紧跟一个abbreviation输入"non-keyword character"后Vim会替换那个abbreviation。 
"non-keyword character"指那些不在iskeyword选项中的字符。
运行命令： :set iskeyword?
你将看到类似于iskeyword=@,48-57,_,192-255的结果。
% 这个格式很复杂，但本质上 "keyword characters"包含一下几种：
    下划线字符 (_).
    所有字母字符，包括大小写。
    ASCII值在48到57之间的字符（数字0-9）。
    ASCII值在192到255之间的字符（一些特殊ASCII字符）。
如果你想阅读这个选项格式的 完整 描述，你可以运行命令:help isfname，另外 阅读之前最好准备点吃的。
你只要记住输入非字母、数字、下划线的字符就会引发abbreviations替换。

% 更多关于abbreviations
% Abbreviations不仅仅只能纠错笔误。我们可以加几个日常编辑中常用的abbreviations。 
% 随意更换我的名字和邮箱地址为你的，然后试试这两个abbreviations吧~
% 这些abbreviations将你常用的一长串字符压缩至几个字符，省的每次都要那么麻烦。
% 运行如下命令：
:iabbrev @@    steve@stevelosh.com
:iabbrev ccopy Copyright 2013 Steve Losh, all rights reserved.



% Why Not Use Mappings? 为什么不用Mappings?
% 不错，abbreviations和mappings很像，但是他们的定位不同。看个例子：
% 运行命令：
:inoremap ssig -- <cr>Steve Losh<cr>steve@stevelosh.com
% 这个 mapping 用于快速插入你的签名。进入insert模式并输入ssig试试看。
% 看起来一切正常，但是还有个问题。进入insert模式并输入如下文字：
Larry Lessig wrote the book "Remix".
% 注意到Vim将Larry名字中的ssig也替换了！
% mappings不管被映射字符串的前后字符是什么-- 它只在文本中查找指定的字符串并替换他们。
+
% 运行下面的命令删除上面的mappings并用一个abbreviation替换它：
% 再次试试这个abbreviation。
% 这次Vim会注意ssig的前后字符，只会在需要的时候替换它。
:iunmap ssig
:iabbrev ssig -- <cr>Steve Losh<cr>steve@stevelosh.com


% Exercises
在你的~/.vimrc文件中为经常拼写错误的单词增加abbreviations配置。
一定要使用 上一章中你创建的mappings来重新打开读取~/.vimrc文件。
为你的邮箱地址、博客网址、签名添加abbreviations配置。
为你经常输入的文本添加abbreviations配置。




### ===================================================% 本地缓冲区的选项设置和映射
现在我们先花点时间复习一下我们已经谈论过的三个东西：
映射（mappings），缩写（abbreviations）和选项设置（options），
这个过程中会讲到一些新的东西。我们将在一个单一的缓冲区中同时设置它们。
这一章所讲到的东西会在下一章中真正的显示它们的作用，目前我们只需先打下基础。

% 在这一章中你需要在Vim中打开两个文件，两个文件是分开的。
% 我先将它们命名为foo和bar，你可以随便对它们命名。然后为每个文件输入一些文字。
% 映射, 选择文件foo，然后执行下面的命令：
:nnoremap          <leader>d dd
:nnoremap <buffer> <leader>x dd
% 现在保持在文件foo下面，确保当前处于常用模式下，然后敲击<leader>d。
% Vim会删除一行。这个之前讲到过，没什么新鲜的。
% 仍然保持在文件foo下面，敲击<leader>x。Vim也会删除一行。
% 这很正常，因为我们也将<leader>x映射到dd了。
+
% 现在切换到文件bar。在常用模式下敲击<leader>d。
% 同样的，Vim会删除当前行，也没有什么新鲜的。
ok，现在来点新鲜的：在文件bar下敲击<leader>x。
% Vim只删除了一个字符，而不是删除整个行！ 为什么会这样？
% 第二个nnoremap命令中的<buffer>告诉Vim这个映射只在定义它的那个缓冲区中有效：
% 当你在bar文件下敲击<leader>x，Vim找不到一个跟它匹配的映射，
% 它将会被解析了两个命令：<leader>（这个什么都不会干）和 x（通常会删除一个字符）。


% 本地Leader
% 在这个例子中，<leader>x是一个本地缓冲区映射，不过这种定义方式并不合适。
% 如果我们需要设定一个只会用于特定缓冲区的映射，一般会使用<localleader>，而不是<leader>。
% 使用两种不同的leader按键就像设置了一种命名空间，这会帮助你保证所有不同的映射对你而言更加清晰直接。
% 但你在编写一个会被其他人用到的插件的时候，这点显得尤其重要。
% 使用<localleader>来设置本地映射会防止你的插件覆盖别人用<leader>设置的全局映射，
% 因为他们可能已经对他们做设置的全局映射非常之习惯了。


% 设置在这本书的前面几个章节里，我们谈论了使用set来设置选项。
% 有一些选项总是会适用于整个Vim，但是有些选项可以基于缓冲区进行设置。
% 切回到文件foo，执行下面的命令：
:setlocal wrap
% 然后切换到文件bar，执行下面的命令：
% 把你的Vim窗口调小一些，你会发现有些行在foo中会自动换行，而在bar中则不会。
:setlocal nowrap

% 让我们来测试下另外一个选项。切换到foo执行下面的命令：
:setlocal number
% 现在切换到bar，然后执行下面的命令：
:setlocal nonumber
% 现在在文件foo中会出现行号，而在bar则没有。
% 不是所有的选项都可以使用setlocal进行设置。
% 如果你想知道某个特定的选项是否可以设置为本地选项，执行:help查看它的帮助文档。
% 对于本地选项如何_真正地_地工作，我说的有些简略。在练习中你会学到更多这方面的细节。


% 遮盖
% ok，在开始下一节之前，我们先来看关于本地映射的一个非常有趣的特性。
% 切换到文件foo，然后执行下面的命令：
    :nnoremap <buffer> Q x
    :nnoremap          Q dd
然后敲击Q，看看会发生什么？
当你敲击Q，Vim会执行第一个映射，而不是第二个，
因为第一个映射比起第二个要显得更具体，
这可以看成第二个映射被第一个映射遮盖了。
切换回文件bar，然后敲击Q，Vim会使用第二个映射。
这是因为在这个缓冲区中第二个映射没有被第一个映射遮盖。
阅读:help local-options
阅读:help setlocal
阅读:help map-local



### ========================================================% autocmd!  自动命令
现在我们谈论一个跟映射一样重要的东西：自动命令。
自动命令可以让Vim自动执行某些指定的命令，
这些指定的命令会在某些事件发生的时候执行。我们先看一个例子。
使用:edit foo打开一个新文件，然后立即使用:quit关闭。
查看你的硬盘，你会发现这个文件并不存在。
这是因为在你第一次保存这个文件之前，Vim_实际上_并没有真正创建它。


% 让我们对Vim做一些改变，使得Vim可以在你开始编辑文件的时候就创建它们。执行下面的命令：
% 这里面有很多需要进一步说明的，不过在此之前我建议你先感受下它是怎么工作的。
% 执行:edit foo，使用:quit关闭，然后查看硬盘。这个时候文件会存在（当然文件内容为空）。
% 你只有关闭Vim才能删除这个自动命令。我们会在后面的章节说明如何避免这种情况。
    :autocmd BufNewFile * :write

% 自动命令结构, 让我们来深入分析下我们刚才创建的自动命令：
:autocmd BufNewFile * :write
         ^          ^ ^
         |          | |
         |          | 要执行的命令
         |          |
         |          用于事件过滤的“模式（pattern）”
         |
         要监听的“事件”
% 这个命令的第一部分是我们想监听的事件的类型。Vim提供了_很多_可以监听的事件。这些事件包括：
        1    开始编辑一个当前并不存在的文件。
        2    读取一个文件，不管这个文件是否存在。
        3    改变一个缓冲区的filetype设置。
        4    在某段时间内不按下键盘上面的某个按键。
        5    进入插入模式。
        6    退出插入模式。

% 上面只举出了可用事件里面的很小一部分。还有很多其他的事件，你可以利用这些事件来做一些有趣的事情。
% 这个自动命令的下一部分是一个“模式”，这个模式可以进一步限定你要执行的命令的执行范围。
% 新开一个Vim实例，执行下面的命令：
    :autocmd BufNewFile *.txt :write
这个跟之前的那个自动命令基本一样，不过这个自动命令只对后缀为.txt的文件有效，
也就是说当你新建的文件为txt文件的时候，Vim会在文件创建的时候自动执行write命令将文件保存到硬盘上。
试试执行:edit bar，然后执行:quit，再执行:edit bar.txt，然后再执行:quit。
你会发现Vim会自动创建bar.txt，但不会创建bar，因为它的后缀名不是txt，不跟模式匹配。
这个自动命令的最后一部分是事件发生时我们想执行的命令。
这个部分很容易理解，跟我们执行其他命令一样，除了不能在这个命令中使用特殊的字符，
例如<cr>。我们会在本书后面的章节中谈论如何突破这个限制，现在你只需要遵守它就可以。    
    
    
    
% 再来一个示例
% 我们再定义一个自动命令，这次使用一个不同的事件。执行下面的命令：  
    :autocmd BufWritePre *.html :normal gg=G
这里用到了normal命令，我会在本书的后面的章节里面讲到它，这可能有点超前，
不过我觉得这是一个很好的使用自动命令的示例，所以请大家先忍受一下。
创建一个名为foo.html的新文件。用Vim编辑它，并输入下面的文本，请保证输入的文本完全一致，包括空白符：
    
<html>
<body>
 <p>Hello!</p>
                 </body>
                  </html>
                      
执行:w保存这个文件。看看会发生了什么？Vim似乎在文件保存之前重新进行了文本缩进处理。
ok，请先相信我文本缩进处理是:normal gg=G干的，先别纠结于为什么:normal gg=G可以干这个。
我们_应该_把注意力放在自动命令上。这个自动命令里面用到的事件是BufWritePre，
这个事件会在你保存_任何_字符到文件之前触发。
我们使用了*.html这个模式，这个模式会保证命令只会在编辑html文件的时候被执行。
这就是自动命令强大的地方，因为它可以专门针对特定类型的文件来执行我们想要执行的命令。ok，让我们继续探索它吧。    
    
    
    
% 多个事件
% 你可以创建一个绑定_多个_事件的自动命令，这些事件使用逗号分隔开。执行下面的命令：
    :autocmd BufWritePre,BufRead *.html :normal gg=G    
        
这个跟上面的自动命令基本一样，不同的是它会让Vim不仅在写html文件的时候进行缩进处理，
读html文件的时候也会进行缩进处理。如果你有些同事不喜欢把HTML文件格式搞得漂亮点，那么这个命令会很有用。
在Vim脚本编程中有一个不成文的规定，你应该同时使用 BufRead和BufNewFile
（译注：这里不是BufWritePre）这两个事件来运行命令，
这样当你打开某个类型的文件，不论这个文件是否存在命令都会执行。

% 下面的命令会使得无论你在什么时候编辑HTML文件自动换行都会被关闭
    :autocmd BufNewFile,BufRead *.html setlocal nowrap
 
    
    
 
% FileType事件
% 最有用的事件是FileType事件。这个事件会在Vim设置一个缓冲区的filetype的时候触发。
% 让我们针对不同文件类型设置一些有用的映射。运行命令：   
% 打开一个Javascript文件（后缀为.js的文件）,将光标移动到某一行，敲击<localleader>c，光标所在的那一行会被注释掉
% 现在打开一个Python文件（后缀为.py的文件）,将光标移动到某一行，敲击<localleader>c，同样的那一行会被注释掉
    :autocmd FileType javascript nnoremap <buffer> <localleader>c I//<esc>
    :autocmd FileType python     nnoremap <buffer> <localleader>c I#<esc>



     
% 练习
浏览:help autocmd-events查看自动命令可以绑定的所有事件。
你不需要现在就记住每一个事件。仅仅只需要了解下你可以使用这些事件做哪些事情。
创建一些FileType自动命令使用setlocal对你喜欢的文件类型做一些设置。
你可以针对不同的文件类型设置wrap、list、 spell和number这些选项。
对一些你会经常处理的文件类型创建一些类似“注释掉这一行”的命令。
把所有这些自动命令写到你的~/.vimrc文件里面。
记住使用前面章节中提到过的快速编辑和加载~/.vimrc文件的映射来做这个事情，这是必须的！    
    
    

### ====================================================% Vimscript 本地缓冲区缩写
现在以同样的方式来学习本地缓冲区的缩写 

% 打开你的foo和bar这两个文件，切换到foo，然后执行下面的命令：
    :iabbrev <buffer> --- &mdash;
% 在文件foo下进入插入模式输入下面的文本：
% 在foo中 Vim会为你将---替换为“&mdash;“。
% 在bar中替换不会发生，这是因为我们所定义的缩写被设置为只用于foo的本地缓冲区。
    Hello --- world.



% 自动命令和缩写
% 使用本地缓冲区的缩写和自动命令来创建一个简单的“snippet”系统。
% 打开一个Javascript文件然后输入iff缩写。然后再打开一个Python文件试试。
% Vim会依据文件类型在当前行执行合适的缩写。
% 执行下面的命令：
    :autocmd FileType python     :iabbrev <buffer> iff if:<left>
    :autocmd FileType javascript :iabbrev <buffer> iff if ()<left>


% 练习
% 为你经常编辑的文件创建更多的针对不同类型的文件的“snippet”缩写。
你可以为绝大多数语言创建return的缩写，为javascript创建function的缩写，
以及为HTML文件创建&ldquo;和&rdquo;的缩写。
将你创建的snippets加入到你的~/.vimrc文件中。
记住：最好的学习使用这些snippets的方法是_禁用_之前你做这些事情的方式。
执行 :iabbrev <buffer> return NOPENOPENOPE 会_强迫_你使用缩写，
这个命令在你输入return的时候不会输出任何东西。为了节省学习的时间，
为你刚才创建的snippets都创建一个上面的缩写来_强迫_你使用你创建的snippets。




### =======================================================% Vimscript 自动命令组 
% 前面几章我们学习了自动命令。执行下面命令：
    :autocmd BufWrite * :echom "Writing buffer!"
现在使用:write命令将当前缓冲区写入文件，
然后执行:messages命令查看消息日志。
你会看到Writing buffer!在消息列表中。
然后将当前缓冲区写入文件，执行:messages查看消息日志。
你会看到Writing buffer!在消息列表中出现了两次。

% 现在再次执行上面的自动命令：
    :autocmd BufWrite * :echom "Writing buffer!"
再次将当前缓冲区写入文件并执行:messages命令。
你会看到Writing buffer!在消息列表中出现了_4_次，这是怎么回事？
这是因为当你以上面的方式创建第二个自动命令的时候，Vim没办法知道你是想替换第一个自动命令。
在上面的示例中，Vim创建了两个_不同_的自动命令，并且这两个命令刚好做同样的事情。


% 这会有什么问题？
既然你现在知道了Vim可能创建两个完全一样的自动命令，你可能会想：“有什么大不了？只要别这么干就可以！”。
问题是当你加载你的~/.vimrc文件的时候，Vim会重新读取整个文件，包括你所定义的任何自动命令！
这就意味着每次你加载你的~/.vimrc文件的时候，Vim都会复制之前的自动命令，
这会降低Vim的运行速度，因为它会一次又一次地执行相同的命令。


% 你可以执行下面的命令模拟这种情况：
    :autocmd BufWrite * :sleep 200m
现在将当前缓冲区写入文件。你可能注意到Vim在写入文件的时候有点缓慢，
当然也你可能注意不到。现在执行上面的自动命令三次：
    :autocmd BufWrite * :sleep 200m
    :autocmd BufWrite * :sleep 200m
    :autocmd BufWrite * :sleep 200m
再次写文件。这次会更明显。
当然你不会创建任何只是进行sleep而不做任何事情的自动命令，
不过一个使用Vim的老鸟的~/.vimrc文件可以轻易达到1000行，
其中会有很多自动命令。再加上安装的插件中的自动命令，这肯定会影响Vim的速度。


% 把自动命令放到组中（Grouping Autocommands）
对于这个问题，Vim有一个解决方案。这个解决方案的第一步是将相关的自动命令收集起来放到一个已命名的组（groups）中。
%新开一个Vim实例，这样可以清除之前所创建的自动命令。然后运行下面的命令：
    :augroup testgroup
    :    autocmd BufWrite * :echom "Foo"
    :    autocmd BufWrite * :echom "Bar"
    :augroup END
中间两行的缩进没有什么含义，如果你不想输入的话可以不输。
将一个缓冲区写入文件然后执行:messages。你应该可以在消息日志列表中看到Foo和Bar。现在执行下面的命令：
    :augroup testgroup
    :    autocmd BufWrite * :echom "Baz"
    :augroup END
当你再次将缓冲区写入文件的时候猜猜会发生什么。
ok，你也许已经有结果了，重新写入缓冲区，然后执行:messages命令，看看你猜对了没。



% 清除自动命令组
% 当你写入文件的时候发生什么了？猜对了么？
% 如果你认为Vim会替换那个组，那么你猜错了。不要紧，很多人刚开始的时候都会这么想（我也是）。
% 当你多次使用augroup的时候，Vim每次都会组合那些组。
% 如果你想清除一个组，你可以把autocmd!这个命令包含在组里面。执行下面的命令：
    :augroup testgroup
    :    autocmd!
    :    autocmd BufWrite * :echom "Cats"
    :augroup END
现在试试写入文件然后执行:messages查看消息日志。这次Vim只会输出Cats在消息列表中。



% 在Vimrc中使用自动命令
% 既然我们现在知道了怎么把自动命令放到一个组里面以及怎么清除这些组，
% 我们可以使用这种方式将自动命令添加到~/.vimrc中，这样每次加载它的时候就不会复制自动命令了。
% 添加下面的命令到你的~/.vimrc文件中：
    augroup filetype_html
        autocmd!
        autocmd FileType html nnoremap <buffer> <localleader>f Vatzf
    augroup END
当进入filetype_html这个组的时候，我们会立即清除这个组，然后定义一个自动命令，
然后退出这个组。当我们再次加载~/.vimrc文件的时候，清除组命令会阻止Vim添加一个一模一样的自动命令。


% 练习
查看你的~/.vimrc文件，然后把所有的自动命令用上面组的方式包裹起来。
如果你觉得有必要，可以把多个自动命令放到一个组里面。
想想上一节的示例中的自动命令是干啥的。
阅读:help autocmd-groups。

  
### =================================================== % Operator-Pending映射
这一章我们将来探索Vim映射系统中另外一个神奇的部分：
“Operator-Pending映射”。
开始之前，我们先解释下这里面的几个词含义。
一个Operator（操作）就是一个命令，
你可以在这个命令的后面输入一个Movement（移动）命令，
然后Vim开始对文本执行前面的操作命令，
这个操作命令会从你当前所在的位置开始执行，
一直到这个移动命令会把你带到的位置结束。

% 常用到的Operator有d，y和c。例如：
按键    操作       移动
----   --------  -------------
dw     删除       到下一个单词
ci(    修改       在括号内
yt,    复制       到逗号


% Movement映射
% Vim允许你创建任何新的movements，这些movements可以跟所有命令一起工作。执行下面的命令：
    :onoremap p i(
% 在缓冲区中输入下面的文字：
    return person.get_pets(type="cat", fluffy_only=True)
把光标放到单词“cat”上，然后敲击dp。结果会发生什么？Vim会删除括号内的所有文字。
你可以把这个新建的movements当作“参数”。
onoremap命令会告诉Vim当它在等待一个要附加在operator后面的movement的时候，
如果这个movement是p的话，它会把它当作i(。所以当我们在运行dp的时候，
就象是在对Vim说“delete parameters”，而Vim会把它理解为“在括号内删除”。

% 我们现在可以立马对所有的operators使用这个新建的映射。
% 再次在缓冲区中输入上面的文字（或者直接把之前修改恢复一下）。
    return person.get_pets(type="cat", fluffy_only=True)
把光标放到单词“cat”上，然后敲击cp。这次又会发生什么？
Vim会删除括号中的所有文字，不过这一次删除之后Vim会处于插入模式，
这是因为你使用的是“change”，而不是“delete”。



% 再看一个示例。执行下面的命令：
    :onoremap b /return<cr>
现在把下面的文字输入到缓冲区：
def count(i):
    i += 1
    print i

    return foo
把光标放到第二行的i上，然后按下db。会发生生么？
Vim把整个函数体中直到return上面的内容都删除了，
return就是上面的映射使用Vim的通用查找得到的结果。



% 当你想搞清楚怎么定义一个新的operator-pending movement的时候，你可以从下面几个步骤来思考：
        1    在光标所在的位置开始。
        2    进入可视模式(charwise)。
        3    ... 把映射的按键放到这里 ...
        4   所有你想包含在movement中的文字都会被选中。
% 你所要做的工作就是在第三步中填上合适的按键。



% 改变开始位置
% 你可能已经从上面所学的东西中意识到一个了问题。
% 如果我们定义的movements都是从光标所在的位置开始的话，那么这就会限制我们做一些我们想使用movement来做的事情。
% 但是Vim并不会限制你去做你想做的事情，所以对于这个问题肯定有解决办法。执行下面的命令：
    :onoremap in( :<c-u>normal! f(vi(<cr>
% 这个命令看起来有些复杂，不过我们还是先试试它能干什么。将下面的文字输入缓冲区：
    print foo(bar)
把光标放到单词print上面，然后敲击cin(。Vim会删除括号内的内容然后进入插入模式，并且光标会停留在括号的中间。
你可以将这个映射理解为“在下一个括号内(inside next parentheses)”。
它会对当前行光标所在位置的下一个括号内的文本执行operator。

% 我们再创建一个“在上一个括号内(inside last parentheses)”的movement进行对照。
% （在这里使用“前一个(previous)“可能更准确，但这会覆盖“段落(paragraph)”movement）
    :onoremap il( :<c-u>normal! F)vi(<cr>
% 先试试确保这个命令可以工作。那么这些映射是怎么工作的呢？
% 首先，<c-u>比较特殊，可以先不用管（你只需要相信我这个东西可以让这个映射在任何情况下都能正常工作）。
% 如果我们删除它的话，这个映射会变成这个样子：
    :normal! F)vi(<cr>
:normal!会在后面的章节谈到，现在你只需要知道它可以在常用模式下模拟按下按键。
例如，运行:normal! dddd会删除两行，就像按下dddd。映射后面的<cr>是用来执行:normal!命令的。

% 那么现在我们可以认为这个映射的关键是运行下面这些按键组成的命令： 
% F)vi(  This is fairly simple: 这个命令很容易理解：
        F): 向后移动到最近的)字符。
        vi(: 进入可视模式选择括号内的所有内容。
% 这个movement结束在在可视模式下选择中我们想操作的文本，然后Vim会对选中的文本执行操作，就像通常情况一样。

% 一般规则
下面两条规则可以让你可以很直观的以多种方式创建operator-pending映射：
    如果你的operator-pending映射以在可视模式下选中文本结束，Vim会操作这些文本。
    否则，Vim会操作从光标的原始位置到一个新位置之间的文本。
    
    
% 练习
为"around next parentheses"和"around last
 parentheses"创建operator-pending映射
为打括号创建类似的in/around next/last的mappings。
阅读:help omap-info，看看你可不可以搞清楚<c-u>是干啥的。


### ================================================== %更多Operator-Pending映射
Operators和movements所包含的理念是Vim中的一个非常重要的概念，
也是Vim之所以这么高效的最大原因所在。
在这一章我们会在这一块做更多的实践，
这会让Vim变得更强大。
假设你现在在往Markdown中写入一些文字。
如果你没有用过Markdown，
不要紧，对于我们现在要做的事情而言，
它很简单。把下面的文字输入到一个文件中：

Topic One
=========

This is some text about topic one.

It has multiple paragraphs.

Topic Two
=========

This is some text about topic two.  It has only one paragraph.


% 使用=作为“下划线”的行会被Markdown当作标题。我们现在创建一些映射，
% 这些映射可以让我们通过movements定位到标题。运行下面的命令：
% 这个映射有些复杂。现在把你的光标放到文本中的某个位置（不要放到标题上）,然后敲击cih。
% Vim会删除光标所在章节的标题，然后保持在插入模式，这可以称为"修改所在的标题(change inside heading)"
    :onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
    

% 这里使用了一些我们之前从来没有见过的东西，所以我们有必要单独分析下每一部分的含义。
% 这个映射的第一部分，:onoremap ih是映射命令，这个我们很熟悉了，无需多言。
% <c-u>上一章讲过，我们现在也不深究。
% 接着看看剩下的部分：
    :execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>

Normal ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% :normal命令的后面会跟着一串字符，无论这些字符表示什么含义，
% :normal命令都会执行它们，就像是在常用模式下敲击这些字符一样。
% 我们会在后面的章节中谈论关于:normal的更多细节，由于这个它已经出现多次，
% 所以我觉得有必要现在做一个简单的说明，算是浅尝辄止吧。执行下面的命令：
% Vim会将光标跳转到文件的顶部。
:normal gg

% 现在执行下面的命令：Vim将缩进当前行。
% 那normal后面的!是干啥的呢？先别管，以后再说。
:normal >>



Execute ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% execute命令后面会跟着一个Vim脚本字符串（以后会深究它的细节），
% 然后把这个字符串当作一个命令执行。执行下面的命令：
% Vim会写文件，就像你已经输入了:write<cr>一样
:execute "write"

% 现在执行下面的命令：
% Vim会执行:normal! gg，这个会将光标跳转到文件的顶部，跟之前一样。
:execute "normal! gg"


% 现在问题来了，我们为什么要搞得这么蛋疼，
% 又是execute，又是normal!，直接执行normal!不就可以搞定么？
% 看看下面的命令，猜猜它会干啥：
:normal! gg/a<cr>

% 这个命令似乎会做下面的一些事情：
1    将光标跳转到文件的顶部。
2    准备搜索。
3    把“a”当作目标字符串进行搜索。
4    按下return键执行搜索。
你自己执行一下，Vim会将光标跳转到了文件顶部，然后。。没有然后了！
之所以会这样是由于normal!的一个问题，这问题是normal!不能识别“特殊字符”，
例如这里的<cr>。这个问题有很多办法可以搞定，最简单的就是使用execute，另外使用execute也会让脚本更易读。
当execute碰到任何你想让它执行的字符串的时候。它会先替换这个字符串中的所有特殊字符。
在这个示例中，\r是一个转义字符，它表示的是"回车符（carriage return）"。
两个反斜线也是一个转义字符，它会将一个反斜线当作一般字符放到字符串中。



% 如果我们按照上面的分析替换这个映射中的特殊字符，然后就可以搞清楚这个映射会怎么执行：
:normal! ?^==\+$<cr>:nohlsearch<cr>kvg_
                ^^^^           ^^^^
                 ||             ||
这里的<cr>实际上是一个回车符，而不是由4个字符——“左尖括号”，“c“，”r“和“右尖括号”组成的字符串。
所以现在normal!会执行这些字符，如同我们是在常用模式下敲击了它们一样。我们以回车符对这些字符进行拆分，
然后看看它们是怎么执行的：
        ?^==\+$
        :nohlsearch
        kvg_
% 第一部分
第一部分?^==\+$会向后搜索任何由两个或多个等号组成的行，这些行不会包含除等号外的任何其他字符。
这个命令执行后会让光标停留在符合搜索条件的行的行首。
之所以使用向后搜索，是因为当你想“修改所在的标题(change inside heading)”的时候，
而当前光标是位于某一节的文本上，那么你最可能想做的是修改_这_一节的标题，而不是下一节的标题。

% 第二部分
第二部分是:nohlsearch命令。这个命令只是简单的清除之前的搜索结果的高亮显示，防止这些高亮显示分散我们的注意。

% 第三部分
最后一部分是三个常用模式下的命令的序列：
    k：向上移动一行。第一部分已经将光标定位到了等号符号组成的行的第一个字符，
       所以执行这个命令后光标就会被定位到标题的第一个字符上。
    v：进入可视模式(characterwise)。
    g_：移动到当前行的最后一个非空字符上。这里没有使用$，是因为$会选中换行符号，这不是我们所想要的。





% 再来看一个映射。执行下面的命令：
% 把光标放到某一节的文字上，然后敲击cah试试看。这一次Vim不仅会删除这一节的标题，
% 而且还会删除跟这个标题相连的等号组成的行。
% 你可以把这个movement当作是“_环绕_这一节的标题(around this section's heading)“。
    :onoremap ah :<c-u>execute "normal! ?^==\\+\r:nohlsearch\rg_vk0"<cr>

% 这个映射有什么不同呢？让我们对照之前的映射看一下：
:onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
:onoremap ah :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rg_vk0"<cr>

%唯一的不同是映射的后面用于选择文本的部分：
    inside heading: kvg_
    around heading: g_vk0
% 其他的部分都是一模一样的，所以我们现在从将光标定位到等号组成的行的第一个字符的那个部分开始进行讲解：
    g_：移动到当前行（译注：等号组成的行）的最后一个非空字符。
    v：进入可视模式(characterwise)。
    k：向上移动一行。这会将光标移动到包含标题文字的行上。
    0：移动到这一行（译注：标题行）的第一个字符。
% 这一系列命令的执行结果就是在可视模式下同时选中标题的文字和等号组成的行，然后Vim会在这两行上执行相应的操作。



% 练习
Markdown也可以用-字符来限定标题。
调整上面的正则表达式使得这些映射可以工作在不同类型的标题上。
你可能想查看:help pattern-overview。
记住正则表达是在一个字符串中，所以反斜线需要进行转义。
添加两个创建这些映射的自动命令到你的~/.vimrc文件中。
确保只对合适的缓冲区使用这些映射，
并且确保使用自动命令组来防止每次加载~/.vimrc的时候创建这些自动命令的副本。
阅读 :help normal。
阅读 :help execute。
阅读 :help expr-quote了解你可以在字符串中使用的转义序列。
创建一个“在下一个邮件地址内(inside next email address)”的operator-pending映射，
然后你就可以使用“修改在下一个邮件地址内(change inside next email address)”。
将in@作为映射的按键是个不错的选择。你可能还需要将这个按键映射为/...some regex...<cr>。




### =======================================================%Vimscript 负责任的编码
到目前为止我们已经介绍了一堆Vim命令，
这可以让你可以快速自定义Vim。
除了自动命令组外其他的命令都是单行的命令，
你可以不费吹灰之力就把它们添加到你的~/.vimrc文件中。
这本书的下一部分我们会开始专注于Vim脚本编程，
将其当作一个真正的编程语言对待，不过在此之前，
我会先讲一些在编写大量的Vim脚本时需要注意的东西。


% 注释
Vim脚本非常强大，但对于那些想进入这个领域的程序员而言，
在最近几年它似乎逐渐变得像一个弯弯曲曲的迷宫，让进入的人找不到归路。

Vim的选项和命令经常会比较简短生硬，并且难于阅读，另外处理兼容性问题也会增加代码的复杂度。
编写一个插件并且允许用户自定义又会让复杂度更进一级。

在编写大量Vim脚本时要保持防御意识。要养成习惯添加注释说明某段代码是干什么的，
如果有一个相关的帮助主题（help topic），最好在注释中说明！

这不仅会给你以后的维护带来方便，而且如果你将你的~/.vimrc文件分享到Bitbucket或者GitHub（强烈推荐你这么做），
这些注释也会帮助其他的人理解你的脚本。


% 分组
之前创建的映射可以让我们在使用Vim的同时方便快捷地编辑和加载~/.vimrc。
不幸的是这会导致~/.vimrc中的代码快速增长以至失去控制，并且变得难于阅读浏览。

我们用于对付这种情况的方法是使用Vim的代码折叠功能，将多行代码组织起来的作为一个部分然后对这部分的代码进行折叠。
如果你从来没有用过Vim的折叠功能，那么你现在应该尽快去瞄一瞄。很多人（包括我自己）都认为在日常编码工作中代码折叠是不可或缺的。
首先我们需要为Vim脚本文件设置折叠。在你的~/.vimrc文件中添加下面几行：
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END

这会告诉Vim对任何Vim脚本文件使用marker折叠方法。
现在在显示~/.vimrc文件的窗口中执行:setlocal foldmethod=marker。
如果你不执行这个命令，你会发现加载~/.vimrc文件后没什么效果，
这是因为Vim已经为这个文件设置了文件类型(FileType)，
而自动命令只会在设置文件类型的时候执行。这让你以后不需要手动来做这个事情。

现在在自动命令组开始和结束的地方添加两行，像下面这样：
" Vimscript file settings ---------------------- {{{
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}

切换到常用模式，将光标放到这些文字中的任意一行，然后敲击za。
Vim会折叠从包含{{{的行到包含}}}的行之间的所有行。再敲击za会展开所有这些行。

刚开始你可能会觉得为了代码折叠而对源代码进行注释会有些不合理，我刚开始也这么想。
对于大多数文件我现在仍然觉得这种做法并并不合适。因为不是所有人都使用相同的编辑器，
所以在代码中添加的折叠注释对于那些不用Vim的人而言就像是噪音。

不过Vim脚本文件比较特殊，因为一个不用Vim的人不太可能会读你的代码，
并且最重要的是如果不对代码进行分组处理，写着写着你就不知道写到哪里了，严重点可能会经脉尽断，吐血而亡。

先自己尝试尝试吧，说不定你会逐渐喜欢上它。
简短的名称(Short Names)

对于大多数命令和选项，Vim支持使用它们的缩写。例如，下面的两个命令做的事情完全一样：

:setlocal wrap
:setl wrap

我_强烈_提醒你不要在你的~/.vimrc或者是你编写的插件中使用这些缩写。
Vim脚本对于初学者而言本来就已经够晦涩难懂了；
从长远来看使用缩写只会使得它更难于阅读。即使_你_知道某个缩写的意思，其他人未必读得懂。

换句话说，缩写只在编码的过程中手动执行命令的时候会很有用。
在你按了回车键以后，就没人会看到你输入什么了，这样你也没必要输入更多的字符。

% 练习
检查你的~/.vimrc文件，将所有相关的行组织起来。
你可以这么开头：“基本设置(Basic Settings)“，
”文件类型相关设置(FileType-specific settings)”，“映射(Mappings)”，
和“状态条(Status Line)”。然后在每个部分添加折叠标记和标题。

想想怎么让Vim在第一次打开~/.vimrc文件的时候自动折叠所有设置了折叠注释的行。
阅读:help foldlevelstart你会知道怎么搞。

检查你的~/.vimrc文件，把所有的命令和选项的缩写改成全称。

检查你的~/.vimrc文件，确保里面没有什么敏感信息。
然后创建一个git或者Mercurial仓库，再将~/.vimrc文件放到里面，然后将这个文件链接到~/.vimrc。

提交你刚才创建的仓库，并把它放到Bitbucket或者GitHub上，
这样其他的人都可以看到和学习它。记住要经常提交和推送到仓库中，这样你所做的修改也会被记录下来。

如果你不只在一个机器上使用Vim，那你就可以克隆那个仓库，
然后像之前一样将这个文件链接到~/.vimrc文件。这样你就可以在所有的机器上都使用同样的Vim配置了。



### =========================================================== % vimscript 变量
到目前为止我们已经讲完了单行命令。
在本书后面的三分之一个章节中将会把Vim脚本当作一个脚本语言。
这部分东西不会像前面的你学到的东西一样马上可以学以致用，
不过这是为本书的最后一部分打基础，
最后一部分会讲解创建一个插件所需要的各个方面的东西。

我们开始吧。我们首先要了解的是变量。执行下面的命令。
:let foo = "bar"
:echo foo
% Vim会显示bar。foo现在是一个变量，我们将一个字符串"bar"赋值给它。现在执行这些命令：

:let foo = 42
:echo foo
Vim会显示42，因为我们将foo赋值为整型42。
从这些小例子似乎可以看出Vim脚本是动态类型的。事实并非如此，我们之后会说明。



% 作为变量的选项
% 你可以通过一种特殊语法将_选项_作为变量来设置。执行下面的命令：

:set textwidth=80
:echo &textwidth
Vim会显示80。在名称的前面加一个&符号是告诉Vim你正在引用这个选项，而不是在使用一个名称刚好相同的变量。


% 我们来看下Vim是怎么处理布尔选项的。执行下面的命令：
:set nowrap
:echo &wrap
Vim显示0。

% 然后再试试这些选项：
:set wrap
:echo &wrap
这次Vim会显示1。这些输出很明确提示Vim会将整型0当作"false"，整型1当作"true"。
我们可以更进一步假设Vim会将所有的非0值整型当作"truthy"，而事实确实如此。


% 我们也可以使用let命令来_设置_作为变量的选项。执行下面的命令：
:let &textwidth = 100
:set textwidth?
Vim会显示textwidth=100。


% 既然set可以搞定选项的设置，那我们为什么还要用let呢？执行下面的命令：
:let &textwidth = &textwidth + 10
:set textwidth?
这一次Vim显示textwidth=110。当你用set来设置某个选项，你只能给它设置一个常量值。
当你使用let并将它作为一个变量来设置，你可以使用Vim脚本的所有强大之处来决定它的值。


%本地选项
%如果你想将某个选项作为变量来设置它的_本地_值，而不是_全局_值，你需要在变量名前面加前缀。
在两个分隔的窗口中分别打开两个文件。执行下面的命令：
:let &l:number = 1
% 然后切换到另一文件，然后再执行下面的命令：
:let &l:number = 0
注意第一个窗口会出现行号，而第二个没有。



% 作为变量的寄存器(Register)
你也可以将_寄存器_当作变量来读取和设置。执行下面的命令：
:let @a = "hello!"
现在把光标放到文本中的某个地方然后敲击"ap。这个命令会告诉Vim“在这里粘贴寄存器a中的内容”。
我们设置了这个寄存器的内容，所以Vim会将hello!粘贴到你的文本中。

% 还可以读寄存器的内容。执行下面的命令：
:echo @a
Vim会输出hello!。

% 在你的文件中选择一个单词然后用y复制，再执行下面的命令：
:echo @"
Vim会输出你刚才复制的单词。"寄存器是“未命名(unnamed)”寄存器，
在复制的时候没有指定寄存器的文本都会放到这里。

% 在你的文件中执行搜索/someword，然后执行下面的命令：
:echo @/
Vim会输出你刚刚使用的搜索模式。这样你就可以通过编程来读_和修改_当前的搜索模式，有些时候这会很有用。


% 练习
检查你的~/.vimrc文件，
然后将其中的一些set和setlocal命令替换为它们的let形式。
记住布尔选项仍然需要被设置为某个值。
尝试将某个布尔选项设置为0和1之外的值，例如wrap。
当你将它设置为一个不同的数字时会怎么样？
如果设置为字符串又会是什么情况？
回到你的~/.vimrc文件，然后恢复所有的修改。
在set可以搞定的时候，永远都不要用let，这是因为let更难于阅读。
阅读:help registers，然后看看你可以进行读和写的寄存器列表。










### =====================================================%Vimscript Execute命令
execute命令用来把一个字符串当作Vimscript命令执行。
在前面的章节我们曾经跟它打过交道， 
不过随着对Vimscript中的字符串有更深入的了解，现在我们将再次认识它。


execute基本用法
% 执行下面的命令：
% Vim把echom 'Hello, world!'当作一个命令，而且尽职地在把它输出的同时将消息记录下来。 
% Execute是一个非常强大的工具，因为它允许你用任意字符串来创造命令。
:execute "echom 'Hello, world!'"



% 让我们试试一个更实用的例子。先在Vim里打开一个文件作为准备工作，
% 接着使用:edit foo.txt在同一个窗口创建新的缓冲区。 现在执行下面的命令：
% Vim将在第二个文件的右边打开第一个文件的竖直分割窗口(vertical split)。为什么会这样？
% 首先，Vim将"rightbelow vsplit"和bufname('#')调用的结果连接在一起，创建一个字符串作为命令。
% 我们过一段时间才会讲到相应的函数，现在姑且认为它返回前一个缓冲区的路径名。 你可以用echom来确认这一点。
% 待bufname执行完毕，Vim将结果连接成"rightbelow vsplit bar.txt"。 
% execute命令将此作为Vimscript命令执行，在新的分割里打开该文件。
:execute "rightbelow vsplit " . bufname("#")




% Execute危险吗？
在大多数编程语言中使用诸如"eval"来构造可执行的字符串是会受到谴责的(如果不会是更严重的后果)。
 因为两个原因，Vimscript中的execute命令能免于操这份心。
% 首先，大多数Vimscript代码仅仅接受唯一的来源——用户的输入。 
假设有用户想输入一个古怪的字符串来执行邪恶的命令，无所谓，反正这是他们自己的计算机！ 
然而在其他语言里，程序通常得接受来自不可信的用户的输入。
Vim是一个特殊的环境， 在此无需担心一般的安全性问题。
% 第二个原因是因为Vimscript有时候处理问题的方式过于晦涩难懂且稀奇古怪。 
这时execute会是完成任务的最简单，最直白的方法。 
在大多数其他语言中，使用"eval"不会省下你多少击键的生命，但在Vimscript里这样做可以化繁为简。



% 练习
浏览:help execute来明了哪些命令你可以用execute实现而哪些不可以。 
但当涉猎，因为我们很快将重新审视这个问题。
阅读:help leftabove，:help rightbelow，
:help :split和:help :vsplit(注意最后两个条目中额外的分号)。
在你的~/.vimrc中加入能在选定的分割(竖直或水平，
上/下/左/右方位)中打开前一个缓冲区的映射。



### =======================================================%Vimscript Normal命令
目前为止我们已经介绍了几个最为常用的Vimscript命令，
但都跟日常中在normal模式下处理文本的方式无关。 
有没有一种办法能把我们的脚本跟日常的文本编辑命令结合起来呢？
% 答案显然是肯定的。之前我们已经见过normal命令，是时候更详细地介绍它了。
% Vim将把你的光标移到当前文件的最后一行，就像是在normal模式里按下G。
:normal G

% Vim将移动到文件的第一行(gg)并删除它(dd)。
% normal命令简单地接受一串键值并当作是在normal模式下输入的。就是那么简单！
:normal ggdd


% 避免映射
执行下面的命令来映射G键到别的东西：
现在在normal模式按下G将删除一整行。
:nnoremap G dd

Vim将删除当前行。normal命令将顾及当前的所有映射。
这意味着我们需要给normal提供类似于nnoremap之于nmap的版本，
 否则我们没法使用它——考虑到我们猜测不了用户的映射方式。
:normal G

幸好Vim真的有这样的命令叫normal!。执行这个命令：
这次Vim将移动光标到文件底部，即使G已经被映射了。
在写Vim脚本时，你应该_总是_使用normal!，_永不_使用normal。不要信任用户在~/.vimrc中的映射。
:normal! G


% 特殊字符
如果你使用normal!一段时间了，就很可能注意到一个问题。试试下面的命令：
:normal! /foo<cr>

第一眼看上去它应该会开始搜索foo，但你将看到它不会正常工作。 问题在于normal!不会解析像<cr>那样的特殊字符序列。
于是，Vim认为你想要搜索字符串序列"foo"，没有意识到你甚至按下了回车来进行搜索！ 
(译注：原文为you even pressed return to perform the search! 
按后文的意思应该是没有按下return,待问作者) 我们将在下一章讨论如何应对这个问题。



% 练习
阅读:help normal。在最后部分，你将获得关于下一章主题的提示。


% 附加题
如果你还没准备好面对挑战，跳过这一节。如果你够胆，祝你好运！
重温:help normal关于undo的部分。尝试设计一个删除两行却能单独撤销每次删除的映射。
 建议从nnoremap <leader>d dddd开始吧。
这次你并不真的需要normal!(nnoremap就够了)， 但是它揭示了一点：
有时阅读一个Vim命令的文档可以激发关于别的内容的奇思妙想。
如果你未尝使用过helpgrep命令，那就是时候用上它了。阅读:help helpgrep。 留心关于怎样在匹配内容中浏览的部分。
暂时先别纠结模式(patterns)，我们很快就要谈到它们。 现在只需了解你可以用类似foo.*bar来查找文档中包括该正则模式的行。
不幸的是，helpgrep会不时给你带来挫折感，因为为了找到某些词，你需要懂得去搜索某些词。 
我会帮你省下些无用功，这次你得查找到一种手工修改Vim的撤销序列的方法， 这样你映射的两个删除才能独立地撤销。
在以后你要灵活变通(pragmatic)。有时在你迷惘徘徊的时候，Google一下，你就知道。






### =======================================================%Vimscript 执行normal!

既然已经学了execute和normal!，我们就可以深入探讨一个Vimscript惯用法。 执行下面的命令：
:execute "normal! gg/foo\<cr>dd"
% 这将移动到文件的开头，查找foo的首次出现的地方，并删掉那一行。
% 之前我们尝试过用normal!来执行一个搜索命令却无法输入必须的回车来开始进行搜索。 结合execute和normal!将解决这个问题。
% execute允许你创建命令，因而你能够使用Vim普通的转义字符串来生成你需要的"打不出"的字符。 尝试下面的命令：
:execute "normal! mqA;\<esc>`q"

% 这个命令做了什么？让我们掰开来讲：
% :execute "normal! ..."  ：执行命令序列，一如它们是在normal模式下输入的，忽略所有映射， 并替换转义字符串。
    mq      ：保存当前位置到标记"q"。
    A       ：移动到当前行的末尾并在最后一个字符后进入insert模式。
    ;       ：我们现在位于insert模式，所以仅仅是写入了一个";"。
    \<esc>  ：这是一个表示Esc键的转义字符串序列，把我们带离insert模式。
    `q      ：回到标记"q"所在的位置。
% 看上去有点绕，不过它真的很有用：它在当前行的末尾补上一个分号并保持光标不动。 
% 在写Javascript，C或其他以分号作为语句分隔符的语言时，一旦忘记加上分号，这样的映射将助你一臂之力。


% 练习
重读:help expr-quote(你之前应该看过)来提醒你怎么用execute通过转义字符串传递特殊字符给normal!。
在翻开下一章之前，放下本书休息一下。吃一个三明治或喝一杯咖啡(译注：或者茶！)， 喂一下你的宠物——如果你有的话。










### ================================================================% 变量作用域
%前缀            含义
g:varname      变量为全局变量
l:varname      变量的范围为当前的函数，局部变量
s:varname      变量的范围为当前的脚本文件，当前脚本可见的局部变量
w:varname      变量的范围为当前的编辑器窗口-windows
t:varname      变量的范围为当前的编辑器选项卡，tab的局部变量
b:varname      变量的范围为当前的编辑器缓冲区-buffer
a:varname      变量是当前函数的一个参数，函数参数变量
v:varname      变量是 Vim 的预定义的内部变量



### ===========================================================% Vimscript 伪变量
&varname 	    一个Vim 选项
&l:varname 	    本地变量(局部变量)
&g:varname 	    全局变量
@varname 	    一个 Vim 寄存器
$varname 	    一个环境变量





### ========================================================% 比较操作(condition)
% 在 Vimscript 中，比较函数始终执行数字比较，除非两个运算对象都是字符串。
% 特别的，如果一个运算对象是字符串，另一个是数字，
% 那么字符串将被转换为数字，然后再对两个数字进行数值比较
let ident = 'Vim'
if ident == 0       "Always true (string 'Vim' converted to number 0)

% 在这种情况下，一种更健壮的解决方案是： if ident == '0'
% 任何字符串比较函数都可以被显式地标记为大小写敏感
% (通过附加一个 #),显式地标记为大小写敏感  ,或大小写不敏感(通过附加一个 ?)
if name == ?'vim'
if name == #'Vim'


%%%%%%%%%%%%%%%%% 防御性编程
这意味着什么？意味着在为别人开发插件时，你_不能_信任==。 
一个不加包装的==_不能_出现在你的插件代码里。
这个建议就像是"nmap VS nnoremap"一样。_永远不要_猜测你的用户的配置。 
Vim既古老，又博大艰深。在写插件时，你_不得不_假定用户们的配置五花八门，千变万化。
所以怎样才能适应这荒谬的现实？好在Vim有额外两种比较操作符来处理这个问题。
执行下面的命令：
:set noignorecase
:if "foo" ==? "FOO"
:    echom "first"
:elseif "foo" ==? "foo"
:    echom "second"
:endif
% Vim显示first因为==?是"无论你怎么设都大小写不敏感"比较操作符。现在执行下面的命令：


:set ignorecase
:if "foo" ==# "FOO"
:    echom "one"
:elseif "foo" ==# "foo"
:    echom "two"
:endif
% Vim显示two因为==#是"无论你怎么设都大小写敏感"比较操作符。
故事的最后告诉我们一个道理：你应该_总是_用显式的大小写敏感或不敏感比较。 
使用常规的形式是_错的_并且它_终究_会出错。打多一下就能拯救你自己于焦头烂额中。
当你比较整数时，这点小不同不会有什么影响。 
不过，我还是建议每一次都使用大小写敏感的比较(即使不一定需要这么做)，好过该用的时候_忘记_用了。
在比较整数时使用==#或==?都可以，而且将来一旦你改成字符串间的比较，它还会正确工作。 
如果你真想用==比较整数也不是不行，不过要铭记，一旦被改成字符串间的比较,你需要修改比较操作符。





### ==================================================% 算术运算，注意整数和实数差别
let filecount = 234
echo filecount/100          " 显示2
echo filecount/100.0        " 显示2.34



### ==========================================================% vimscript 语句

% 赋值语句：let
let {variable} = {expression}

% 条件控制if 语句：
if {condition}
    {statements}
elseif {condition}
    {statements}
else
    {statements}
endif

% while 语句：
while {condition}
    {statements}
    [ continue ]
    [ break ]
endwhile

% for 语句：
for {varname} in {listexpression}
    {statements}
endfor







### ============================================================% vimscript 函数
一如大多数编程语言，Vimscript支持函数。
让我们看看如何创建函数，然后再讨论它们的古怪之处。
执行下面的命令：    
    :function meow()
% 你可能会认为这将定义函数meow。
% 不幸的是，情况不是这样的，我们已经掉进了Vimscript其中的一个坑。
% 没有作用域限制的Vimscript函数必须以一个大写字母开头！
即使你_真的_给函数限定了作用域(我们待会会谈到)，你最好也用一个大写字母开头。 
大多数Vimscript程序猿都是这么做的，所以不要破例。



% ok，是时候认真地定义一个函数了。执行下面的命令：
% 这次Vim愉快地定义了一个函数。让我们试试运行它：
:function Meow()
:  echom "Meow!"
:endfunction
:call Meow()


% 让我们试试令它返回一个值。执行下面的命令：
% 现在执行这个命令试试：
% Vim将调用这个函数并把结果传递给echom，显示Meow String!
:function GetMeow()
:  return "Meow String!"
:endfunction
:echom GetMeow()



% 这个函数涉及到我们之前学到的许多重要概念：
    if语句
    将选项作为变量
    访问特定作用域里的选项变量
    大小写敏感的比较
% 如果你对以上内容感到陌生，最好翻到前几章温习一遍。
% 现在我们已经定义了一个函数，该函数告诉我们当前缓冲区的textwidth会不会设得‘太过宽’。 
% 因为80字符的限制适用于除了HTML之外的任何代码文件)
:function TextwidthIsTooWide()
:  if &l:textwidth ># 80
:    return 1
:  endif
:endfunction



% 现在让我们使用它。执行下面的命令：
:set textwidth=80
:if TextwidthIsTooWide()
:  echom "WARNING: Wide text!"
:endif
% 在这里我们做了什么？
    一开始我们设置全局的textwidth为80。
    接着我们运行一个if语句判断TextwidthIsTooWide()是否为真。
    由于不满足条件，if语句体(译注：包括函数内的和函数外的)不会被执行。
% 因为我们没有显式返回一个值，Vim从函数中返回代表'falsy'的0。



% 试试改变一下。运行下面的命令：
:setlocal textwidth=100
:if TextwidthIsTooWide()
:  echom "WARNING: Wide text!"
:endif
这次函数中的if执行了它的语句体，返回1，并且我们手工输入的if语句也执行了_它_的语句体。






### =============================================================== 自定义函数
function {Name}({var1}, {var2}, ...)
    {body}
    [ return ]
endfunction

%  例：求两数中最小值函数：
function! s:Min(num1, num2)
    return a:num1 < a:num2 ? a:num1 : a:num2
endfunction


% Vimscript 函数参数
毫无疑问，Vimscript函数可以接受参数。执行下面的命令：
:function DisplayName(name)
:  echom "Hello!  My name is:"
:  echom a:name
:endfunction
% 执行下面的函数：
:call DisplayName("Your Name")
% Vim将显示两行：Hello! My name is: 和 Your Name。
% 注意我们传递给echom命令的参数前面的a:。
% 这表示一个变量的作用域，在前几章(译注：第20章)我们曾讲过。
在写需要参数的Vimscript函数的时候，你_总需要_给参数加上前缀a:，来告诉Vim去参数作用域查找


% 字符串长度
:echom strlen("foo")         

% Vim显示['one','two','three']。split函数把字符串切割成列表
echo split("one two tree")  

% 字符串连接，Vim将显示foo...bar。暂时不要在意列表语法
:echo join(["foo", "bar"], "...")

% split和join可以合作无间。执行下面的命令：
% Vim显示foo;bar。首先我们把"foo bar"切割成列表，接着用分号作为分隔符把列表连接成字符串
:echo join(split("foo bar"), ";")

% 大小写转换
% Vim有两个函数来转换字符串大小写。执行下面的命令：
:echom tolower("Foo")
:echom toupper("Foo")



### ================================================================= 函数可变参数
Vimscript函数可以设计为接受不定数目的参数，
就像Javascript和Python中的一样。执行下面命令：
:function Varg(...)
:  echom a:0
:  echom a:1
:  echo a:000
:endfunction

:call Varg("a", "b")
% 这个函数向我们展示了许多东西，让我们来逐一审视。
% 函数定义中的...说明这个函数可以接受任意数目的参数。就像Python函数中的*args
% 函数中的第一行为输出消息a:0，结果显示2。当你在Vim中定义了一个接受可变参数的函数，
% a:0将被设置为你额外给的参数数量(译注：注意是额外的参数数量)。 
刚才我们传递了两个参数给Varg，所以Vim显示2。(译注：2 - 0 ==# 2)

% 第二行为输出a:1，结果显示a。
你可以使用a:1,a:2等等来引用你的函数接受的每一个额外参数。 
如果我们用的是a:2，Vim就会显示"b"

% 第三行有些费解。
当一个函数可以接受可变参数，a:000将被设置为一个包括所有传递过来的额外参数的列表(list)。 
我们还没有讲过列表，所以不要太纠结于此。你不能对列表使用echom，因而在这里用echo代替。

% 你也可以将可变参数和普通参数一起用。执行下面的命令：
:function Varg2(foo, ...)
:  echom a:foo
:  echom a:0
:  echom a:1
:  echo a:000
:endfunction
:call Varg2("a", "b", "c")
我们可以看到Vim将"a"作为具名参数(named argument)a:foo的值，将余下的塞进可变参数列表中。





### ============================================================== vim 内置寄存器
% 首先对vim中的寄存器来进行个大致浏览，它主要分为这么几个部分：
　　　　1.无名寄存器（" ）
　　　　2.复制专用寄存器 （0）
　　　　3.统剪贴板（X11视窗系统下的主剪贴板）（*）
　　　　4.黑洞寄存器 （_）
　　　　5.命名寄存器 （a-z）
　　　　6.表达式寄存器 （=）
　　　　7.其他的一些只读寄存器（"/寄存器特殊）

% 无名寄存器保存的是dd命令删除的内容，而复制专用寄存器（0）保存的是y命令复制的内容。
% 第三个是系统剪贴板寄存器(+)和X11视窗系统的主剪贴板寄存器(*)。
个人认为这个比较常用，所以就先说了。众所周知，任何操作系统都有一个剪贴版板，
而vim就是用+寄存器来代表这个剪贴版，我经常遇到的情况就是在浏览器中复制了一段文本，
然后需要在vim中粘贴，感觉这时候这个+寄存器就大显身手了



gedit       vim
_______________________________
剪切板 <===> vim       寄存器名
cut   <===> delete      "
copy  <===> yank        0
paste <===> put


% 查看当前寄存器的内容
:reg

% 查看指定寄存器值：
:reg {register_name}



% 调取寄存器值
    NORMAL Mode：@{register_name}
    COMMAND MODE：<C-r>+"寄存器名称 (输入<C-r>后VIM会自动打出"寄存器引用符号)
    INSERT MODE：<C-r>+寄存器名称(无需输入寄存器引用符号")




==================================================== 命令的记录与回放
1 q{register_name}      %将后续的动作记录到名为{register_name}的寄存器中，
                        %其中给出的寄存器名字必须是 a到z之间的一个字母。                       
2 在命令模式中，[ 输入q，在输入a ]; 
  vim提醒你当前已经进入记录状态,这个寄存器把它命名为“a”
3 此时你所输入的任意字符都会被记录下来 ,它记录到寄存器“a”中了
4 用“q”来结束记录
5 在按“Esc”,  用“@a” 来回放你的记录




### ================================================================ copy paste

set paste























