### =================================== perl文字处理模式中,/pattern/常用到的语法 1

/pattern/ 	结果
.	        除了换行字符\n外,找寻只有一个字符的字符串
x? 	        找寻0个或是1个x字符
x* 	        找寻0个或是0个以上的x字符
.* 	        找寻0个或是0个以上的任何字符
x+ 	        找寻0个或是1个以上的x字符
.+ 	        找寻1个或是1个以上的任何字符
{m} 	    找寻刚好是m个个数指定的字符
{m,n} 	    找寻在m个数个数以上,n个个数以下指定的字符
{m,} 	    找寻m个个数以上指定的字符
[] 	        找寻符合[]内的字符
[^] 	    找寻不符合[]内的字符
[0-9] 	    找寻符合0到9的任何一个字符
[a-z] 	    找寻符合a到z的任何一个字符
[^0-9] 	    找寻不符合0到9的任何一个字符
[^a-z] 	    找寻不符合a到z的任何一个字符
^ 	        找寻字符开头的字符
$ 	        找寻字符结尾的字符
\d 	        找寻一个digit(数字)的字符,和[0-9]语法一样
\d+ 	    找寻一个digit(数字)以上的字符串,和[0-9]+语法一样
\D 	        找寻一个non-digit(非数字)的字符,和[^0-9]语法一样
\D+ 	    找寻一个non-digit(非数字)以上的字符,和[^0-9]+语法一样
\w 	        找寻一个英文字母或是数值的字符,和[a-zA-Z0-9]语法一样
\w+ 	    找寻一个以上英文字母或是数值的字符,和[a-zA-Z0-9]+语法一样
\W 	        找寻一个非英文字母,数值的字符,和[^a-zA-Z0-9]语法一样
\W+ 	    找寻一个以上非英文字母,数值的字符,和[^a-zA-Z0-9]+语法一样
\s 	        找寻一个空白的字符,和[\n\t\r\f]一样
\s+ 	    找寻一个以上空白的字符,和[\n\t\r\f]+一样
\S 	        找寻一个非空白的字符,和[^\n\t\r\f]一样
\S+ 	    找寻一个以上非空白的字符,和[^\n\t\r\f]+一样
\b 	        找寻一个不以英文字母,数值为边界的字符串
\B 	        找寻一个以英文字母,数值为边界的字符串
a|b|c 	    找到符合a字符或是b字符或是c字符的字符串
abc 	    找到一个含有abc的字符串

(pattern) 	()这个符号是会记忆所找寻到的字符,是一个很实用的语法
            第一个()内所找到的字符串变成$1这个变量或是\1变量
            第二个()内所找到的字符串变成$2这个变量或是\2变量
            以此类推,笔者会在下一小节中详细介绍它的用法
            
/pattern/i 	i这个参数是代表忽略英文大小写的意思,
            也就是在找寻字符 串的时候,不会去考虑英文的大小写
            
\ 	        如果要在pattern模式中找寻一个有特殊的意义的字符,
            要在 这个字符前加上\这个符号,这样才会让这个特殊字符失效
            
            
            
### ================================= 文字处理模式(Regular Expression)的简单范例 2          
            
范例 	    说明
/perl/ 	    找到含有perl的字符串
/^perl/ 	找到开头是perl的字符串
/perl$/ 	找到结尾是perl的字符串
/c|g|i/ 	找到含有c或g或i的字符串
/cg{2,4}i/ 	找到c后面跟着2个到4个g,再跟着i的字符串
/cg{2,}i/ 	找到c后面跟着2个以上g,再跟着i的字符串
/cg{2}i/ 	找到c后面跟着2个g,再跟着i的字符串
/cg*i/ 	    找到c后面跟着0个或多个g,再跟着i的字符串,如同/cg{0,1}i/
/cg+i/ 	    找到c后面跟着一个以上g,再跟着c的字符串,如同/cg{1,}i/
/cg?i/ 	    找到c后面跟着0个或是一个g,再跟着c的字符串,如同/cg{0,1}i/
/c.i/ 	    找到c后面跟着一个任意字符,再跟着i的字符串
/c..i/ 	    找到c后面跟着二个任意字符,再跟着i的字符串
/[cgi]/ 	找到符合有这三个字符任意一个的字符串
/[^cgi]/ 	找到没有这三个字符中任意一个的字符串
/\d/ 	    找寻符合数值的字符串
            可以使用/\d+/来表示一个或是多个数值的字符串
/\D/ 	    找寻符合不是数值的字符串
            可以使用/\D+/来表示一个或是更多个非数值的字符串
/\w/ 	    找寻符合英文字母,数值的字符串
            可以使用/\w+/来表示一个或是更多个英文字母,数值的字符串
/\W/ 	    找寻符合非英文字母,数值字符的字符串
            可以使用/\W+/来表示一个或是更多个非英文字母,数值的字符串
/\s/ 	    找寻符合空白的字符串
            可以使用/\s+/来表示一个或是更多个空白字符的字符串
/\S/ 	    找寻符合不是空白的字符串
            可以使用/\S+/来表示一个或是更多不是空白的字符的字符串
/\*/ 	    找寻符合*这个符号的字符串,因为*在文字处理模式中有它的特殊意思,
            所以要在这个特殊符号前加上\这个符号,这样才会让这个特殊字符失效
/abc/i 	    找寻符合abc的字符串而且不考虑这些符合字符串的大小写           
            
            
### ========================== 文字处理模式(Regular Expresion)相关的运算符及函数  3         
%  在perl程序写作中常会用到=~和!~这两个运算符及s和t;
%  这二个函数来和文字处理模式/pattern/搭配而成一个运算式,
%  如果能够活用这些指令的话,就可以很。轻易地来处理一些字符串,
%  当然在CGI程序设计中了就更能得心应手了。
%  现在就让作者来介绍这些运算符及函数的用法:
           
指令: /pattern/文字运算
说明: 如果在文字运算中没有使用=~或是!~运算符指定一个字符串来做运算的话,
就会使用内定的输出变量$_来做/pattern/文字运算。            
            
范例一:
$string="chmod711cgi";
$string=~/(\W+)\s+(\d+)/;
第一个(\W+)是代表找寻数个字母,并将的找到的字符串指派给$1这个变量,
而\s+代表找寻多个空白的字符串,最后(\d+)代表找寻个数值,并将所找到的字符串指派给$2这个变量。
所以$1="chmod";$2=711;但是$string还是等于原来的字符串,没有改变。            
            
            
范例二:
$_="chmod711cgi";
/(\W)\s+(\d+)/;
因为是把字符串指定给$_这个变量,所以可以不用=~这个运算符就会得到
$1="chmod";$2=711;而且$_还是等于原来的字符串,没有改变。

范例三:
$string="chmod 711 cgi";
@list=split(/s+/,$string);
以上一个或是多个空白字符来分割$string这个字符串,这是一个很常用的语法。
此时@list=("chmod","711","cgi");




### =========================================================== 指令: =~相配运算符
说明:这是Perl语言中特有的语法,通常会和文字处理来作运算。

范例:

print"请输入一个字符串!\n";
$string=<STDIN>;            #<STIDN>代表标准输入,会让使用者输入一字符串
chop($string);              #将$string最后一个换行的字符\n删除掉
if($string=~/cgi/){

    print("输入的字符串中有cgi这个字符串!\n";

}

如果输入的字符串含有cgi这个字符串的话,就会显示出这个信息。



### =========================================================== 指令:!~不相配运算符

说明:这也是Perl语言中特有的语法,通常会和文字处理模式来运算。

范例:

print"请输入一个字符串!\n";
$string=<STDIN>;            #<STIDN>代表标准输入,会让使用者输入一字符串
chop($string);              #将$string最后一个换行的字符\n删除掉
if($string!~/cgi/)
{

    print("输入的字符串中有cgi这个字符串!\n";

}

如果输入的字符串中没有cgi这个字符串的话,就会显示出这个信息。



### =========================================================== 指令:tr转换函数

语法:tr/SEARCHLIST/REPLACELIST/

其中SEARCHLIST是要转换的字符;REPLACELIST是转换成何种字符。

说明:tr(translate)就是转换的意思,会把符合转换的字符转换成要转换的字符。

范例一:

$string="testing";
$string=~tr/et/ET/"; #此时$string="TEsTing";
$string=~tr/a-z/A-Z/; #此时$stirng="TESTING";

范例二:

$string="CGI+Perl";
$string=~tr/+//; #此时$string="CGI Perl";

在传送CGI数据的时候会先将数据编码,其中会将空白的字符转成+这个字符。






### =========================================================== 指令:s 取代函数

语法:s/PATTERN/REPLACE/eg
其中
1 PATTERN是文字处理(Regular Expresion)的模式;

2 REPLACE是代表取代成何种文字模式。

3 而g是这个函数最常用的参数,代表要把所有符合文字模式的字符串全部取代,
如果省略这个参数的话,则只取代一个符合文字模式的字符串中;

4 而加上e这个参数代表要将REPLACE的部分当成一个运算式,
如果没有这个需要的话,就不用加上这个参数了。

说明:将符合文字处理模式的字符串取成为要取代的字符串

范例一:

$string="i:love:perl";
$string=~s/:/*/;            #此时$string="i*love:perl";
$string=~s/:/*/g;           #此时$string="i*love*perl";
$string=~s/*/+/g;           #此时$string="i+love+perl";
$string=~s/+//g;            #此时$string="i love perl";
$string=~tr/+//;            #此时$string="i love perl";
$string=~s/perl/cgi;        #此时$string="i love cgi";



范例二:

$string=~s/(love)/<$1>/;
第一个()内所找到的字符串变成$1,在这个范例中,
会把变量love这个字符串变成<love>,此时$string="i<love>perl";

$string="i love perl";
$string=~s(i)(perl)/<$1><$2>/;
在这个范例中,会把i变成<i>;perl变成<perl>，
此时$string="<perl> love <i>";

$string="i love perl";
$string=~s(\W+)/<$1>/g;
(/w+)代表找寻符合一个或是多个英文字符或是数值的字符串,
之后再将找到的字符串设成$1。因为加上g这个参数,
所以会找到字符串的这三个英文单字,然后再把这三个单字分加上<>这个符号,
此时$string="<perl><love><i>";



范例三:

$string="www22cgi44";
$string=~s/(\d+)/$1*2/e;
(/d+)代表要找寻$string中一个或是多个数值的字符串,
再将找到的字符串设成$1。加上参数e是代表要把$1*2当作是一个运算式,
所以$string="www22cgi44";

$string="www22cgi44";
$string=~s/(\d+)/$1*2/eg;
加上参数e,所以会把$1*2当作是一个运算符式来看;
加上参数g就会把全部符合数值的字符串经过运算式运算之后再把它取代,
所以$string="www44cgi88";




范例四:

假设原本的字符串是$value="三八!",经CGI数据编码之后,这个字符串就会变成

$value="%A4T%A4K%21"。以下是一个解码的示范程序:

$value="%A4T%A4K%21";
$vlaue=~s/%([a-fA-F0-9][a-fA-F0-9]/pack("c",hex($1))/eg;

在传送CGI数据的时候会把数据编码,
其中会将特殊字符或是中文字符编码以%开头的连续的两个十六进制数的字符串,
所以要用s这个函数来找寻这个以%开头的字符串。
为了要把找到的字符串再做解码的处理,所以要在%这个符号之后加上()这个符号,
表示会把找到的字符串记忆起来并指定给$1这个变量,
而且要在()中加上代表是连续两个十六进制数值的文字处理模式(Regular Expression),
也就是[a-fA-F0-9][a-fA-F0-9]。
再用hex这个函数($1是代表符合的字符串)把十六进制数值转成十进制的码,
之后再用pack这个函数(以C为参数,是代表unsigned char value的意思)把这个十进制码还原成原来的字符串。
最后就会把这个字符串解码成$value="三八!"。值得一提的是也可以把这个解码的程序写成:
$value=~s/%(..)/pack("C",hex($1))/eg;







### =================================================================== 用户函数
% 用户函数又称子程序(Subroutine)，在Perl中用下面的结构来定义用户函数：
% 这里的子程序名与变量的取名规则类似。

　　　　sub 子程序名 {

　　　　　　语句块;
　　　　}


用户函数的定义可以位于程序的任何位置，比如说放在文件的未尾。
如果两个子程序使用了相同的程序名， 后面的子程序将覆盖前面子程序。
% 用户函数中的变量默认为全局变量，与其他程序共享。
% 用户函数的调用：通过在子程序前加“&”调用，可在任一表达式内调用。 
% 子程序中可以再调用另外的子程序。
% 调用用户函数产生的结果称为返回值(return value)。
% 返回值是每次调用函数中最后一个表达式的计算值。
既然函数中的变量全为全程变量，那么上述程序中若调用程序中含有$sum变量时将替换，
这不是我们所要的。 那么如何解决这一问题呢？
答案就是：使用局部变量, 使用local()操作符就可实现此功能。
在上面的程序中，只需在第一行$sum=0;前加入：
　　　　local($sum);

% 其中 $chinese($number)||number; 行的初级写法为：
　　　　if ($chinese(number) {
　　　　　　&chinese($number); #返回中文
　　　　} else {
　　　　　　&number;          #返回阿拉伯数字
　　　　}
　　　　
　　　　
use strcit
my







