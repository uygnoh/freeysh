### % https://www.w3cschool.cn/vim/gsenvozt.html


"buffer"、"window"、 "normal mode"、"insert mode"、"text mode"


### ======================================================= %  vim 语法基本特征
### 创建Vimrc文件 
~/.vimrc文件包含了Vimscript代码，每次启动Vim时，Vim都会自动执行其中的代码
在Linux和Mac OS X中，这个文件位于你的home文件夹，并以.vimrc命名
在Windows中，这个文件位于你的home文件夹，并以_vimrc命名
% 在_任意_系统中，在Vim中执行以下命令可以快速得知这个文件的位置和名称
% 如果你的home文件夹没有这个文件，请自行创建一个
:echo $MYVIMRC


### Vimscript 打印信息 
Vimscript中，我们最先关注的是 echo和echom 命令。
你可以在Vim中执行[:help echo]和[:help echom]命令以查看其帮助文档。
读完本书之后， 再次遇到新的命令时，你应该先执行:help命令查看其帮助文档。
% 执行如下命令，体验echo命令：
:echo "Hello, world!"

:echom "Hello again, world!"
%执行如下命令，查看上述两个打印命令的区别：
:messages
% 你应该会看到一些消息。Hello, world!应该_不在_其中，但是Hello again, world! 在。

当你写更为复杂的Vimscript时，你可能会想"打印一些信息"以方便调试程序。
:echo命令 会打印输出，但是一旦你的脚本运行完毕，那些输出信息就会消失。
使用:echom打印的信息 会保存下来，你可以执行:messages命令再次查看那些信息。


### 继续之前，咱们先看看如何添加注释
% 当你写Vimscript脚本时(在你的~/.vimrc文件中或 其它任意文件)，
% 你可以通过"字符添加注释，例如：
" Make space more useful

"       注释
\       续行

阅读:help echo帮助文档。
阅读:help echom帮助文档。
阅读:help messages帮助文档。


### ======================================================= %Vimscript 设置选项
Vim拥有很多选项可以设置以改变其展现方式。
主要有两种选项：布尔选项（值为"on"或"off"）和键值选项。
% 布尔选项, 执行如下命令： 那么现在你就会看见行号
:set number

% 执行命令：行号应该消失。
:set nonumber

% number是一个布尔选项：可以off、可以on。
通过:set number命令打开、 :set nonumber命令关闭。
所有的布尔选项都是这种配置方法。
:set <name>打开选项、:set no<name>关闭选项。

% 切换布尔选项
你可以"切换"布尔选项的值，即从开启切为关闭或从关闭切为开启。执行命令：
:set number!

% 查看选项当前值
你可以使用一个?符号向Vim获取一个选项的当前值。执行如下命令并查看每个命令的 返回结果
:set number?

% 键值选项
有些选项并不只有off或on两种状态，它们需要一个值。执行如下命令，查看返回结果：
:set number
:set numberwidth=10
:set numberwidth=4
:set numberwidth?
% numberwidth选项改变行号的列宽。
你可以通过 :set <name>=<value> 命令改变 非布尔选项的选项值，
你可以通过 :set <name>?        命令查看选项的当前值。
来看看一些常用选项的值：
:set wrap?
:set shiftround?
:set matchtime?

% 一次性设置多个选项
最后，你可以在一个:set命令中设置多个选项的值。试试如下命令：
注意最后一个命令是如何一次性设置两个选项值的
:set numberwidth=2
:set nonumber
:set number numberwidth=6

阅读:help 'number'（注意有单引号）帮助文档。
阅读:help relativenumber帮助文档。
阅读:help numberwidth帮助文档。
阅读:help wrap帮助文档。
阅读:help shiftround帮助文档。
阅读:help matchtime帮助文档。



### =======================================================% Vimscript 基本映射
% 我们先从normal模式的键盘映射开始。
% 我们将在下一章节讨论insert模式和其他模式下的 键盘映射。
% 随意在文本中敲写几行文字，然后运行命令：
% 将光标置于文本中的某处，按下-。
% 注意Vim删除了当前光标下的字符，就好像你按了x一样。
% 我们本来就有个按键用于 "删除当前光标下的字符" ，
% 所以我们将-重新映射到稍微有用的 功能。执行命令：
:map - x

% 现在移动光标到任意一行，再按下-，这次Vim删除了整行的文本，因为dd的功能就是删除整行。
:map - dd

% 特殊字符; 你可以使用<keyname>告诉Vim一个特殊的按键。尝试如下命令：
% 现在在键盘上按下Ctrl+d将执行dd命令。
:map <c-d> dd


% 特殊字符
% 你可以使用<keyname>告诉Vim一个特殊的按键。尝试如下命令：
% 移动光标到一个单词上，按下空格键。Vim将高亮选中整个单词。
:map <space> viw





### ======================================================= Vimscript 模式映射
上一章中我们谈论了如何在Vim中映射按键。我们使用的命令map在normal模式下工作。 
如果阅读本章之前你自己已经折腾了，可能会注意到这个映射在visual模式一样工作。
% 你可以使用nmap、vmap和imap命令分别指定映射仅在normal、visual、insert模式有效。
% 执行如下命令：
:nmap \ dd
% 在normal模式下，按下\。Vim会删除当前行。
% 现在进入Visual模式，再次按下\。什么都不会发生，
% 因为我们告诉了Vim这个映射仅在normal 模式下工作（同时\的默认行为是什么都不做）。


% 进入visual模式并选中一些文字，按下\。Vim将把选中文本转换成大写格式。
% 分别在normal模式和visual模式测试\按键，注意不同模式下的效应。
:vmap \ U


% 你可能猜想这个命令的作用是在insert模式下通过按键Ctrl+d删除整行。这个映射很实用， 
% 因为你不必每次都要为了删除某些行而切回到normal模式。
% 好的我们试一下。它并不如我们想象那般工作，而仅仅是在文件中添加了两个d字符！ 它压根就没用。
% 问题就在于Vim只按我们说的做。这个例子中，我们说：“当我按下<c-d>时，相当于我 按了两次d”。
% 而当你在insert模式下，按下两次d的作用就是输入两个字符d。
:imap <c-d> dd


% 要想让这个映射按我们的期望执行，我们需要更加明确的指令。修改映射并运行如下命令：
:imap <c-d> <esc>dd
% <esc>告诉Vim按下ESC按键，即退出insert模式。
% 现在再试试这个映射。它能够正常工作，但是注意你是如何回到normal模式的。
% 这是因为我们 告诉Vim<c-d>要退出insert模式并删除一行，但是我们没有告诉它再回到insert模式。

% 运行如下命令，修复映射问题：
:imap <c-d> <esc>ddi
% 结尾的i告诉Vim进入insert模式，至此我们的映射才最终完成。




### ======================================================= 非递归映射
% 每一个*map系列的命令都有个对应的*noremap命令，
% 包括：*noremap/nnoremap、 vnoremap和inoremap。
% 这些命令将不递归解释映射的内容。
% vim中键盘映射有三类：visual，insert和normal
inoremap是用于insert模式的非递归映射，
nnoremap是用于normal模式的非递归映射，
vnoremap是用于visual模式的非递归映射.

% 该何时使用这些非递归的映射命令呢？
% 答案是： 任何时候 。
是的，没开玩笑， 任何时候 。
在安装插件或添加新的自定义映射时使用*map系列命令纯属是给自己 找 麻烦。 
多敲几个字符以确保这个问题不会发生，救自己于火海。



% 一个更为复杂的Mapping
% 你已经见过很多简单的mappings了，是时候看看一些复杂的了。运行下面的命令：
    :nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel

%那是一个有趣的mappings！你自己可以先试试。
%进入normal模式，移动光标至一个单词， 输入<leader>"。Vim将那个单词用双引号包围！
%它是如何工作的呢？我们拆分这个映射并逐个解释：
    viw<esc>a"<esc>hbi"<esc>lel

    viw     :高亮选中单词
    <esc>   :退出visual模式，此时光标会在单词的最后一个字符上
    a       :移动光标至当前位置之 后 并进入insert模式
    "       :插入一个 "
    <esc>   :返回到normal模式
    h       :左移一个字符
    b       :移动光标至单词头部
    i       :移动光标至当前位置之 前 并进入insert模式
    "       :插入一个"
    <esc>   :返回到normal模式
    l       :右移一个字符，光标置于单词的头部
    e       :移动光标至单词尾部
    l       :右移一个字符，置光标位置在第一个添加的引号上
% 记住：因为我们使用的是nnoremap而不是nmap，所以尽管你映射了字符序列中的字符 也不会有影响。
% Vim会将其中的字符按默认功能执行。
% 希望你能看出Vim mappings的潜能及随之引发的阅读困难。



% ESC <=========> JK  [KEY-MAPPING]
% 让我们先创建一个mapping，这个mapping会为你的左手减轻很多负担。执行下面的命令：
% ok，现在进入插入模式然后敲击jk。Vim会返回到常用模式，就像你敲击了escape按键一样。
    :inoremap jk <esc>
% 这个命令会告诉Vim在插入模式下敲击escape按键后执行<nop>(no operation)，
% 这样escape按键在插入模式下就无效了。ok，现在你就_不得不_使用jk这个mapping来退出插入模式了。
    :inoremap <esc> <nop>




### ======================================================= Vimscript Leaders
% 这就意味着你可以用一个你不常用的按键（如-）作为“前缀”，
% 后接其它字符作为一个整体 进行映射。
% 你需要多敲一个按键以执行这些映射，多一个按键而已，很容易就记住了。

% 如果你也认为这是个好方法，我可以告诉你，Vim已经支持这种机制。
% Leader，我们称这个“前缀”为“leader”。你可以按你的喜好设置你的leader键。运行命令：
:let mapleader = "-"

% 你可以替换-为你喜欢的按键。尽管会屏蔽一个有用的功能，但我个人使用的是,，因为这个键比较 比较容易按到。
% 当你创建新的映射时，你可以使用<leader>表示“我设置的leader按键”。运行命令：
:nnoremap <leader>d dd

% 现在试试按下你的leader按键和d。Vim会删除当前行。
% 然而为何每次都要繁琐的设置<leader>？为什么创建映射时不直接敲入你的“前缀”按键？ 原因主要有三个。
% 首先，你某天可能会想要更换你的“leader”。在一个地方定义它使得更方便更换它。
% 第二，其他人看你的~/.vimrc文件时，一旦看到<leader>就能够立即知道你的用意。
% 如果他们 喜欢你的~/.vimrc配置，即使他们使用不同的leader也可以简单的复制你的映射配置。
% 最后，许多Vim插件都会创建以<leader>开头的映射。如果你已经设置了leader，你会更容易上手 使用那些插件。



Local Leader ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% Vim有另外一个“leader”成为“local leader“。
% 这个leader用于那些只对某类文件 （如Python文件、HTML文件）而设置的映射。
% 本书将在后续章节讲述如何为特定类型的文件创建映射，但你可以现在创建一个“localleader”：
:let maplocalleader = "\\"

% 注意我们使用\\而不是\，因为\在Vimscript中是转义字符。我们将在后续章节 讲到这个。
% 现在你就可以在映射中使用<localleader>了，使用方法和<leader>一样（当然， 你要使用另外一个前缀）。
% 如果你不喜欢反斜线，请随意更改它。



### ===================================================% Vimscript Abbreviations
% Vim有个称为"abbreviations"的特性，与映射有点类似，
% 但是它用于insert、replace和 command模式。
% 这个特性灵活且强大，不过本节只会谈及最常用的用法。
% 本书只会讲述insert模式下的abbreviations。运行如下命令：
:iabbrev adn and
% 进入insert模式并输入：One adn two.
% 在输入adn之后输入空格键，Vim会将其替换为and。

% 诸如这样的输入纠错是abbreviations的一个很实用的用法。运行命令：
:iabbrev waht what
:iabbrev tehn then
再次进入insert模式并输入： Well, I don't know waht we should do tehn.
注意 两个 abbreviations的替换时机，第二个没有输入空格却也替换了。



% Keyword Characters
紧跟一个abbreviation输入"non-keyword character"后Vim会替换那个abbreviation。 
"non-keyword character"指那些不在iskeyword选项中的字符。
运行命令： :set iskeyword?
你将看到类似于iskeyword=@,48-57,_,192-255的结果。
这个格式很复杂，但本质上 "keyword characters"包含一下几种：
    下划线字符 (_).
    所有字母字符，包括大小写。
    ASCII值在48到57之间的字符（数字0-9）。
    ASCII值在192到255之间的字符（一些特殊ASCII字符）。
如果你想阅读这个选项格式的 完整 描述，你可以运行命令:help isfname，另外 阅读之前最好准备点吃的。
你只要记住输入非字母、数字、下划线的字符就会引发abbreviations替换。



% 更多关于abbreviations
% Abbreviations不仅仅只能纠错笔误。我们可以加几个日常编辑中常用的abbreviations。 
运行如下命令：
:iabbrev @@    steve@stevelosh.com
:iabbrev ccopy Copyright 2013 Steve Losh, all rights reserved.
随意更换我的名字和邮箱地址为你的，然后试试这两个abbreviations吧~
这些abbreviations将你常用的一长串字符压缩至几个字符，省的每次都要那么麻烦。

% Why Not Use Mappings? 为什么不用Mappings?
% 不错，abbreviations和mappings很像，但是他们的定位不同。看个例子：
% 运行命令：
:inoremap ssig -- <cr>Steve Losh<cr>steve@stevelosh.com
这个 mapping 用于快速插入你的签名。进入insert模式并输入ssig试试看。
看起来一切正常，但是还有个问题。进入insert模式并输入如下文字：
Larry Lessig wrote the book "Remix".

% 注意到Vim将Larry名字中的ssig也替换了！
% mappings不管被映射字符串的前后字符是什么-- 它只在文本中查找指定的字符串并替换他们。

% 运行下面的命令删除上面的mappings并用一个abbreviation替换它：
:iunmap ssig
:iabbrev ssig -- <cr>Steve Losh<cr>steve@stevelosh.com
再次试试这个abbreviation。
这次Vim会注意ssig的前后字符，只会在需要的时候替换它。



% Exercises
在你的~/.vimrc文件中为经常拼写错误的单词增加abbreviations配置。
一定要使用 上一章中你创建的mappings来重新打开读取~/.vimrc文件。
为你的邮箱地址、博客网址、签名添加abbreviations配置。
为你经常输入的文本添加abbreviations配置。


### ===================================================% 本地缓冲区的选项设置和映射
现在我们先花点时间复习一下我们已经谈论过的三个东西：
映射（mappings），缩写（abbreviations）和选项设置（options），
这个过程中会讲到一些新的东西。我们将在一个单一的缓冲区中同时设置它们。
这一章所讲到的东西会在下一章中真正的显示它们的作用，目前我们只需先打下基础。
% 在这一章中你需要在Vim中打开两个文件，两个文件是分开的。
% 我先将它们命名为foo和bar，你可以随便对它们命名。然后为每个文件输入一些文字。


% 映射, 选择文件foo，然后执行下面的命令：
:nnoremap          <leader>d dd
:nnoremap <buffer> <leader>x dd
% 现在保持在文件foo下面，确保当前处于常用模式下，然后敲击<leader>d。
% Vim会删除一行。这个之前讲到过，没什么新鲜的。
仍然保持在文件foo下面，敲击<leader>x。Vim也会删除一行。
这很正常，因为我们也将<leader>x映射到dd了。

% 现在切换到文件bar。在常用模式下敲击<leader>d。
% 同样的，Vim会删除当前行，也没有什么新鲜的。
ok，现在来点新鲜的：在文件bar下敲击<leader>x。
% Vim只删除了一个字符，而不是删除整个行！ 为什么会这样？
% 第二个nnoremap命令中的<buffer>告诉Vim这个映射只在定义它的那个缓冲区中有效：
% 当你在bar文件下敲击<leader>x，Vim找不到一个跟它匹配的映射，
它将会被解析了两个命令：<leader>（这个什么都不会干）和 x（通常会删除一个字符）。


% 本地Leader
在这个例子中，<leader>x是一个本地缓冲区映射，不过这种定义方式并不合适。
如果我们需要设定一个只会用于特定缓冲区的映射，一般会使用<localleader>，而不是<leader>。
使用两种不同的leader按键就像设置了一种命名空间，这会帮助你保证所有不同的映射对你而言更加清晰直接。
但你在编写一个会被其他人用到的插件的时候，这点显得尤其重要。
使用<localleader>来设置本地映射会防止你的插件覆盖别人用<leader>设置的全局映射，
因为他们可能已经对他们做设置的全局映射非常之习惯了。


% 设置在这本书的前面几个章节里，我们谈论了使用set来设置选项。
% 有一些选项总是会适用于整个Vim，但是有些选项可以基于缓冲区进行设置。
切回到文件foo，执行下面的命令：
:setlocal wrap

然后切换到文件bar，执行下面的命令：
:setlocal nowrap

把你的Vim窗口调小一些，你会发现有些行在foo中会自动换行，而在bar中则不会。
让我们来测试下另外一个选项。切换到foo执行下面的命令：
:setlocal number

现在切换到bar，然后执行下面的命令：
:setlocal nonumber

现在在文件foo中会出现行号，而在bar则没有。
不是所有的选项都可以使用setlocal进行设置。
如果你想知道某个特定的选项是否可以设置为本地选项，执行:help查看它的帮助文档。
对于本地选项如何_真正地_地工作，我说的有些简略。在练习中你会学到更多这方面的细节。


% 遮盖ok，在开始下一节之前，我们先来看关于本地映射的一个非常有趣的特性。
切换到文件foo，然后执行下面的命令：
    :nnoremap <buffer> Q x
    :nnoremap          Q dd
然后敲击Q，看看会发生什么？
当你敲击Q，Vim会执行第一个映射，而不是第二个，因为第一个映射比起第二个要显得更具体，这可以看成第二个映射被第一个映射遮盖了。
切换回文件bar，然后敲击Q，Vim会使用第二个映射。这是因为在这个缓冲区中第二个映射没有被第一个映射遮盖。
阅读:help local-options
阅读:help setlocal
阅读:help map-local



### ===================================================% Vimscript 自动命令
% 现在我们谈论一个跟映射一样重要的东西：自动命令。
自动命令可以让Vim自动执行某些指定的命令，这些指定的命令会在某些事件发生的时候执行。我们先看一个例子。
使用:edit foo打开一个新文件，然后立即使用:quit关闭。
查看你的硬盘，你会发现这个文件并不存在。这是因为在你第一次保存这个文件之前，Vim_实际上_并没有真正创建它。

% 让我们对Vim做一些改变，使得Vim可以在你开始编辑文件的时候就创建它们。执行下面的命令：
    :autocmd BufNewFile * :write
这里面有很多需要进一步说明的，不过在此之前我建议你先感受下它是怎么工作的。
执行:edit foo，使用:quit关闭，然后查看硬盘。这个时候文件会存在（当然文件内容为空）。
% 你只有关闭Vim才能删除这个自动命令。我们会在后面的章节说明如何避免这种情况。



% 自动命令结构, 让我们来深入分析下我们刚才创建的自动命令：
:autocmd BufNewFile * :write
         ^          ^ ^
         |          | |
         |          | 要执行的命令
         |          |
         |          用于事件过滤的“模式（pattern）”
         |
         要监听的“事件”
% 这个命令的第一部分是我们想监听的事件的类型。Vim提供了_很多_可以监听的事件。这些事件包括：
    开始编辑一个当前并不存在的文件。
    读取一个文件，不管这个文件是否存在。
    改变一个缓冲区的filetype设置。
    在某段时间内不按下键盘上面的某个按键。
    进入插入模式。
    退出插入模式。

% 上面只举出了可用事件里面的很小一部分。还有很多其他的事件，你可以利用这些事件来做一些有趣的事情。
这个自动命令的下一部分是一个“模式”，这个模式可以进一步限定你要执行的命令的执行范围。
新开一个Vim实例，执行下面的命令：
    :autocmd BufNewFile *.txt :write
这个跟之前的那个自动命令基本一样，不过这个自动命令只对后缀为.txt的文件有效，
也就是说当你新建的文件为txt文件的时候，Vim会在文件创建的时候自动执行write命令将文件保存到硬盘上。
试试执行:edit bar，然后执行:quit，再执行:edit bar.txt，然后再执行:quit。
你会发现Vim会自动创建bar.txt，但不会创建bar，因为它的后缀名不是txt，不跟模式匹配。
这个自动命令的最后一部分是事件发生时我们想执行的命令。
这个部分很容易理解，跟我们执行其他命令一样，除了不能在这个命令中使用特殊的字符，
例如<cr>。我们会在本书后面的章节中谈论如何突破这个限制，现在你只需要遵守它就可以。    
    
    
    
% 再来一个示例
我们再定义一个自动命令，这次使用一个不同的事件。执行下面的命令：  
    :autocmd BufWritePre *.html :normal gg=G
这里用到了normal命令，我会在本书的后面的章节里面讲到它，这可能有点超前，
不过我觉得这是一个很好的使用自动命令的示例，所以请大家先忍受一下。
创建一个名为foo.html的新文件。用Vim编辑它，并输入下面的文本，请保证输入的文本完全一致，包括空白符：    
<html>
<body>
 <p>Hello!</p>
                 </body>
                  </html>    
执行:w保存这个文件。看看会发生了什么？Vim似乎在文件保存之前重新进行了文本缩进处理。
ok，请先相信我文本缩进处理是:normal gg=G干的，先别纠结于为什么:normal gg=G可以干这个。
我们_应该_把注意力放在自动命令上。这个自动命令里面用到的事件是BufWritePre，
这个事件会在你保存_任何_字符到文件之前触发。
我们使用了*.html这个模式，这个模式会保证命令只会在编辑html文件的时候被执行。
这就是自动命令强大的地方，因为它可以专门针对特定类型的文件来执行我们想要执行的命令。ok，让我们继续探索它吧。    
    
    
    
% 多个事件
你可以创建一个绑定_多个_事件的自动命令，这些事件使用逗号分隔开。执行下面的命令：
    :autocmd BufWritePre,BufRead *.html :normal gg=G    
    
    
这个跟上面的自动命令基本一样，不同的是它会让Vim不仅在写html文件的时候进行缩进处理，
读html文件的时候也会进行缩进处理。如果你有些同事不喜欢把HTML文件格式搞得漂亮点，那么这个命令会很有用。

% 在Vim脚本编程中有一个不成文的规定，你应该同时使用BufRead和BufNewFile
（译注：这里不是BufWritePre）这两个事件来运行命令，
这样当你打开某个类型的文件，不论这个文件是否存在命令都会执行。执行下面的命令：
    :autocmd BufNewFile,BufRead *.html setlocal nowrap
上面的命令会使得无论你在什么时候编辑HTML文件自动换行都会被关闭。 
    
    
 
% FileType事件
最有用的事件是FileType事件。这个事件会在Vim设置一个缓冲区的filetype的时候触发。
让我们针对不同文件类型设置一些有用的映射。运行命令：   
    :autocmd FileType javascript nnoremap <buffer> <localleader>c I//<esc>
    :autocmd FileType python     nnoremap <buffer> <localleader>c I#<esc>
打开一个Javascript文件（后缀为.js的文件）,将光标移动到某一行，敲击<localleader>c，光标所在的那一行会被注释掉。
现在打开一个Python文件（后缀为.py的文件）,将光标移动到某一行，敲击<localleader>c，同样的那一行会被注释掉，
不同的是此时所用的是Python的注释字符！
在自动命令中包含我们上一章中学到的本地缓冲区映射，我们可以创建一些映射，这些映射会根据我们正在编辑的文件的类型来进行不同的处理。
这可以为我们在编码的时候减轻很多思考的负担。如果要添加一个注释，我们可能想到的是必须将光标移动到行首，
然后添加一个注释字符，而使用上面的映射，我们只需要简单的将其理解为“注释掉这一行”。    
    
     
% 练习
浏览:help autocmd-events查看自动命令可以绑定的所有事件。
你不需要现在就记住每一个事件。仅仅只需要了解下你可以使用这些事件做哪些事情。
创建一些FileType自动命令使用setlocal对你喜欢的文件类型做一些设置。
你可以针对不同的文件类型设置wrap、list、 spell和number这些选项。
对一些你会经常处理的文件类型创建一些类似“注释掉这一行”的命令。
把所有这些自动命令写到你的~/.vimrc文件里面。
记住使用前面章节中提到过的快速编辑和加载~/.vimrc文件的映射来做这个事情，这是必须的！    
    
    

### =======================================================% 本地缓冲区缩写
上一章讲的东西比较多，完全理解会有点难，所以这一章来点容易的。
我们已经学习了如何定义本地缓冲区的映射和设置选项，现在以同样的方式来学习本地缓冲区的缩写。
% 打开你的foo和bar这两个文件，切换到foo，然后执行下面的命令：
    :iabbrev <buffer> --- &mdash;
% 在文件foo下进入插入模式输入下面的文本：
    Hello --- world.
在foo中 Vim会为你将---替换为“&mdash;“。
在bar中替换不会发生，这是因为我们所定义的缩写被设置为只用于foo的本地缓冲区。


% 自动命令和缩写
使用本地缓冲区的缩写和自动命令来创建一个简单的“snippet”系统。
执行下面的命令：
    :autocmd FileType python     :iabbrev <buffer> iff if:<left>
    :autocmd FileType javascript :iabbrev <buffer> iff if ()<left>
打开一个Javascript文件然后输入iff缩写。然后再打开一个Python文件试试。
Vim会依据文件类型在当前行执行合适的缩写。

% 练习
为你经常编辑的文件创建更多的针对不同类型的文件的“snippet”缩写。
你可以为绝大多数语言创建return的缩写，为javascript创建function的缩写，
以及为HTML文件创建&ldquo;和&rdquo;的缩写。
将你创建的snippets加入到你的~/.vimrc文件中。
记住：最好的学习使用这些snippets的方法是_禁用_之前你做这些事情的方式。
执行 :iabbrev <buffer> return NOPENOPENOPE 会_强迫_你使用缩写，
这个命令在你输入return的时候不会输出任何东西。为了节省学习的时间，
为你刚才创建的snippets都创建一个上面的缩写来_强迫_你使用你创建的snippets。

### =======================================================% 自动命令组  
% 前面几章我们学习了自动命令。执行下面命令：
    :autocmd BufWrite * :echom "Writing buffer!"
现在使用:write命令将当前缓冲区写入文件，然后执行:messages命令查看消息日志。你会看到Writing buffer!在消息列表中。
然后将当前缓冲区写入文件，执行:messages查看消息日志。你会看到Writing buffer!在消息列表中出现了两次。

% 现在再次执行上面的自动命令：
    :autocmd BufWrite * :echom "Writing buffer!"
再次将当前缓冲区写入文件并执行:messages命令。
你会看到Writing buffer!在消息列表中出现了_4_次，这是怎么回事？

这是因为当你以上面的方式创建第二个自动命令的时候，Vim没办法知道你是想替换第一个自动命令。
在上面的示例中，Vim创建了两个_不同_的自动命令，并且这两个命令刚好做同样的事情。


% 这会有什么问题？
既然你现在知道了Vim可能创建两个完全一样的自动命令，你可能会想：“有什么大不了？只要别这么干就可以！”。
问题是当你加载你的~/.vimrc文件的时候，Vim会重新读取整个文件，包括你所定义的任何自动命令！
这就意味着每次你加载你的~/.vimrc文件的时候，Vim都会复制之前的自动命令，
这会降低Vim的运行速度，因为它会一次又一次地执行相同的命令。


% 你可以执行下面的命令模拟这种情况：
    :autocmd BufWrite * :sleep 200m
现在将当前缓冲区写入文件。你可能注意到Vim在写入文件的时候有点缓慢，
当然也你可能注意不到。现在执行上面的自动命令三次：
    :autocmd BufWrite * :sleep 200m
    :autocmd BufWrite * :sleep 200m
    :autocmd BufWrite * :sleep 200m
再次写文件。这次会更明显。
当然你不会创建任何只是进行sleep而不做任何事情的自动命令，
不过一个使用Vim的老鸟的~/.vimrc文件可以轻易达到1000行，
其中会有很多自动命令。再加上安装的插件中的自动命令，这肯定会影响Vim的速度。


% 把自动命令放到组中（Grouping Autocommands）
对于这个问题，Vim有一个解决方案。这个解决方案的第一步是将相关的自动命令收集起来放到一个已命名的组（groups）中。
%新开一个Vim实例，这样可以清除之前所创建的自动命令。然后运行下面的命令：
    :augroup testgroup
    :    autocmd BufWrite * :echom "Foo"
    :    autocmd BufWrite * :echom "Bar"
    :augroup END
中间两行的缩进没有什么含义，如果你不想输入的话可以不输。
将一个缓冲区写入文件然后执行:messages。你应该可以在消息日志列表中看到Foo和Bar。现在执行下面的命令：
    :augroup testgroup
    :    autocmd BufWrite * :echom "Baz"
    :augroup END
当你再次将缓冲区写入文件的时候猜猜会发生什么。
ok，你也许已经有结果了，重新写入缓冲区，然后执行:messages命令，看看你猜对了没。



% 清除自动命令组
当你写入文件的时候发生什么了？猜对了么？
如果你认为Vim会替换那个组，那么你猜错了。不要紧，很多人刚开始的时候都会这么想（我也是）。
当你多次使用augroup的时候，Vim每次都会组合那些组。
如果你想清除一个组，你可以把autocmd!这个命令包含在组里面。执行下面的命令：
    :augroup testgroup
    :    autocmd!
    :    autocmd BufWrite * :echom "Cats"
    :augroup END
现在试试写入文件然后执行:messages查看消息日志。这次Vim只会输出Cats在消息列表中。



% 在Vimrc中使用自动命令
既然我们现在知道了怎么把自动命令放到一个组里面以及怎么清除这些组，
我们可以使用这种方式将自动命令添加到~/.vimrc中，这样每次加载它的时候就不会复制自动命令了。
添加下面的命令到你的~/.vimrc文件中：
    augroup filetype_html
        autocmd!
        autocmd FileType html nnoremap <buffer> <localleader>f Vatzf
    augroup END
当进入filetype_html这个组的时候，我们会立即清除这个组，然后定义一个自动命令，
然后退出这个组。当我们再次加载~/.vimrc文件的时候，清除组命令会阻止Vim添加一个一模一样的自动命令。


% 练习
查看你的~/.vimrc文件，然后把所有的自动命令用上面组的方式包裹起来。
如果你觉得有必要，可以把多个自动命令放到一个组里面。
想想上一节的示例中的自动命令是干啥的。
阅读:help autocmd-groups。

  
### =================================================== %Operator-Pending映射
% 这一章我们将来探索Vim映射系统中另外一个神奇的部分：“Operator-Pending映射”。
开始之前，我们先解释下这里面的几个词含义。
一个Operator（操作）就是一个命令，你可以在这个命令的后面输入一个Movement（移动）命令，
然后Vim开始对文本执行前面的操作命令，这个操作命令会从你当前所在的位置开始执行，
一直到这个移动命令会把你带到的位置结束。

% 常用到的Operator有d，y和c。例如：

按键    操作       移动
----   --------  -------------
dw     删除       到下一个单词
ci(    修改       在括号内
yt,    复制       到逗号


% Movement映射
Vim允许你创建任何新的movements，这些movements可以跟所有命令一起工作。执行下面的命令：
    :onoremap p i(
% 在缓冲区中输入下面的文字：
return person.get_pets(type="cat", fluffy_only=True)
把光标放到单词“cat”上，然后敲击dp。结果会发生什么？Vim会删除括号内的所有文字。
你可以把这个新建的movements当作“参数”。
onoremap命令会告诉Vim当它在等待一个要附加在operator后面的movement的时候，
如果这个movement是p的话，它会把它当作i(。所以当我们在运行dp的时候，
就象是在对Vim说“delete parameters”，而Vim会把它理解为“在括号内删除”。

% 我们现在可以立马对所有的operators使用这个新建的映射。
再次在缓冲区中输入上面的文字（或者直接把之前修改恢复一下）。
return person.get_pets(type="cat", fluffy_only=True)
把光标放到单词“cat”上，然后敲击cp。这次又会发生什么？
Vim会删除括号中的所有文字，不过这一次删除之后Vim会处于插入模式，
这是因为你使用的是“change”，而不是“delete”。


% 再看一个示例。执行下面的命令：
    :onoremap b /return<cr>
现在把下面的文字输入到缓冲区：
def count(i):
    i += 1
    print i

    return foo
把光标放到第二行的i上，然后按下db。会发生生么？
Vim把整个函数体中直到return上面的内容都删除了，
return就是上面的映射使用Vim的通用查找得到的结果。

% 当你想搞清楚怎么定义一个新的operator-pending movement的时候，你可以从下面几个步骤来思考：
    在光标所在的位置开始。
    进入可视模式(charwise)。
    ... 把映射的按键放到这里 ...
    所有你想包含在movement中的文字都会被选中。
% 你所要做的工作就是在第三步中填上合适的按键。



% 改变开始位置
你可能已经从上面所学的东西中意识到一个了问题。
如果我们定义的movements都是从光标所在的位置开始的话，那么这就会限制我们做一些我们想使用movement来做的事情。
但是Vim并不会限制你去做你想做的事情，所以对于这个问题肯定有解决办法。执行下面的命令：
    :onoremap in( :<c-u>normal! f(vi(<cr>
这个命令看起来有些复杂，不过我们还是先试试它能干什么。将下面的文字输入缓冲区：
print foo(bar)
把光标放到单词print上面，然后敲击cin(。Vim会删除括号内的内容然后进入插入模式，并且光标会停留在括号的中间。
你可以将这个映射理解为“在下一个括号内(inside next parentheses)”。
它会对当前行光标所在位置的下一个括号内的文本执行operator。


% 我们再创建一个“在上一个括号内(inside last parentheses)”的movement进行对照。
（在这里使用“前一个(previous)“可能更准确，但这会覆盖“段落(paragraph)”movement）
:onoremap il( :<c-u>normal! F)vi(<cr>
先试试确保这个命令可以工作。
那么这些映射是怎么工作的呢？
首先，<c-u>比较特殊，可以先不用管（你只需要相信我这个东西可以让这个映射在任何情况下都能正常工作）。
如果我们删除它的话，这个映射会变成这个样子：

:normal! F)vi(<cr>

:normal!会在后面的章节谈到，现在你只需要知道它可以在常用模式下模拟按下按键。
例如，运行:normal! dddd会删除两行，就像按下dddd。映射后面的<cr>是用来执行:normal!命令的。

那么现在我们可以认为这个映射的关键是运行下面这些按键组成的命令：
F)vi(
This is fairly simple: 这个命令很容易理解：
    F): 向后移动到最近的)字符。
    vi(: 进入可视模式选择括号内的所有内容。
这个movement结束在在可视模式下选择中我们想操作的文本，然后Vim会对选中的文本执行操作，就像通常情况一样。


% 一般规则
下面两条规则可以让你可以很直观的以多种方式创建operator-pending映射：
    如果你的operator-pending映射以在可视模式下选中文本结束，Vim会操作这些文本。
    否则，Vim会操作从光标的原始位置到一个新位置之间的文本。
练习
为"around next parentheses"和"around last parentheses"创建operator-pending映射
为打括号创建类似的in/around next/last的mappings。
阅读:help omap-info，看看你可不可以搞清楚<c-u>是干啥的。

### =======================================================%更多Operator-Pending映射
Operators和movements所包含的理念是Vim中的一个非常重要的概念，
也是Vim之所以这么高效的最大原因所在。在这一章我们会在这一块做更多的实践，这会让Vim变得更强大。

假设你现在在往Markdown中写入一些文字。如果你没有用过Markdown，
不要紧，对于我们现在要做的事情而言，它很简单。把下面的文字输入到一个文件中：

Topic One
=========

This is some text about topic one.

It has multiple paragraphs.

Topic Two
=========

This is some text about topic two.  It has only one paragraph.


使用=作为“下划线”的行会被Markdown当作标题。我们现在创建一些映射，这些映射可以让我们通过movements定位到标题。运行下面的命令：

:onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>

这个映射有些复杂。现在把你的光标放到文本中的某个位置（不要放到标题上）,
然后敲击cih。Vim会删除光标所在章节的标题，然后保持在插入模式，这可以称为"修改所在的标题(change inside heading)"。

这里使用了一些我们之前从来没有见过的东西，所以我们有必要单独分析下每一部分的含义。
这个映射的第一部分，:onoremap ih是映射命令，这个我们很熟悉了，无需多言。<c-u>上一章讲过，我们现在也不深究。

接着看看剩下的部分：
:execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>

Normal
:normal命令的后面会跟着一串字符，无论这些字符表示什么含义，
:normal命令都会执行它们，就像是在常用模式下敲击这些字符一样。
我们会在后面的章节中谈论关于:normal的更多细节，由于这个它已经出现多次，
所以我觉得有必要现在做一个简单的说明，算是浅尝辄止吧。执行下面的命令：

:normal gg
Vim会将光标跳转到文件的顶部。现在执行下面的命令：

:normal >>
Vim将缩进当前行。

那normal后面的!是干啥的呢？先别管，以后再说。
Execute

execute命令后面会跟着一个Vim脚本字符串（以后会深究它的细节），然后把这个字符串当作一个命令执行。执行下面的命令：
:execute "write"
Vim会写文件，就像你已经输入了:write<cr>一样。现在执行下面的命令：

:execute "normal! gg"
Vim会执行:normal! gg，这个会将光标跳转到文件的顶部，跟之前一样。
现在问题来了，我们为什么要搞得这么蛋疼，又是execute，又是normal!，直接执行normal!不就可以搞定么？

看看下面的命令，猜猜它会干啥：
:normal! gg/a<cr>

这个命令似乎会做下面的一些事情：
    将光标跳转到文件的顶部。
    准备搜索。
    把“a”当作目标字符串进行搜索。
    按下return键执行搜索。
你自己执行一下，Vim会将光标跳转到了文件顶部，然后。。没有然后了！
之所以会这样是由于normal!的一个问题，这问题是normal!不能识别“特殊字符”，
例如这里的<cr>。这个问题有很多办法可以搞定，最简单的就是使用execute，另外使用execute也会让脚本更易读。

当execute碰到任何你想让它执行的字符串的时候。它会先替换这个字符串中的所有特殊字符。
在这个示例中，\r是一个转义字符，它表示的是"回车符（carriage return）"。
两个反斜线也是一个转义字符，它会将一个反斜线当作一般字符放到字符串中。

如果我们按照上面的分析替换这个映射中的特殊字符，然后就可以搞清楚这个映射会怎么执行：

:normal! ?^==\+$<cr>:nohlsearch<cr>kvg_
                ^^^^           ^^^^
                 ||             ||
这里的<cr>实际上是一个回车符，而不是由4个字符——“左尖括号”，“c“，”r“和“右尖括号”组成的字符串。


所以现在normal!会执行这些字符，如同我们是在常用模式下敲击了它们一样。我们以回车符对这些字符进行拆分，然后看看它们是怎么执行的：
?^==\+$
:nohlsearch
kvg_

第一部分?^==\+$会向后搜索任何由两个或多个等号组成的行，这些行不会包含除等号外的任何其他字符。
这个命令执行后会让光标停留在符合搜索条件的行的行首。

之所以使用向后搜索，是因为当你想“修改所在的标题(change inside heading)”的时候，
而当前光标是位于某一节的文本上，那么你最可能想做的是修改_这_一节的标题，而不是下一节的标题。

第二部分是:nohlsearch命令。这个命令只是简单的清除之前的搜索结果的高亮显示，防止这些高亮显示分散我们的注意。

最后一部分是三个常用模式下的命令的序列：
    k：向上移动一行。第一部分已经将光标定位到了等号符号组成的行的第一个字符，所以执行这个命令后光标就会被定位到标题的第一个字符上。
    v：进入可视模式(characterwise)。
    g_：移动到当前行的最后一个非空字符上。这里没有使用$，是因为$会选中换行符号，这不是我们所想要的。

结果
这个映射做了很多工作，所以看起来有些复杂，不过我们已经搞清楚了这个映射中的每个部分。现在来概括一下：
    我们为“所在章节的标题内（inside this section's heading）”创建了一个operator-pending的映射。
    我们使用了execute和normal!这两个命令来执行我们用于选择标题的常用命令，这让我们可以在这些命令中使用特殊字符。
    我们的映射会搜索由等号组成的行从而定位到一个标题，然后在常用模式下选中标题的文本。
    Vim进行剩下的处理标题的工作。




% 再来看一个映射。执行下面的命令：
:onoremap ah :<c-u>execute "normal! ?^==\\+\r:nohlsearch\rg_vk0"<cr>
把光标放到某一节的文字上，然后敲击cah试试看。这一次Vim不仅会删除这一节的标题，
而且还会删除跟这个标题相连的等号组成的行。
你可以把这个movement当作是“_环绕_这一节的标题(around this section's heading)“。

% 这个映射有什么不同呢？让我们对照之前的映射看一下：

:onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
:onoremap ah :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rg_vk0"<cr>

%唯一的不同是映射的后面用于选择文本的部分：

    inside heading: kvg_
    around heading: g_vk0

其他的部分都是一模一样的，所以我们现在从将光标定位到等号组成的行的第一个字符的那个部分开始进行讲解：

    g_：移动到当前行（译注：等号组成的行）的最后一个非空字符。
    v：进入可视模式(characterwise)。
    k：向上移动一行。这会将光标移动到包含标题文字的行上。
    0：移动到这一行（译注：标题行）的第一个字符。
这一系列命令的执行结果就是在可视模式下同时选中标题的文字和等号组成的行，然后Vim会在这两行上执行相应的操作。

% 练习
Markdown也可以用-字符来限定标题。调整上面的正则表达式使得这些映射可以工作在不同类型的标题上。
你可能想查看:help pattern-overview。记住正则表达是在一个字符串中，所以反斜线需要进行转义。

添加两个创建这些映射的自动命令到你的~/.vimrc文件中。确保只对合适的缓冲区使用这些映射，
并且确保使用自动命令组来防止每次加载~/.vimrc的时候创建这些自动命令的副本。

阅读 :help normal。
阅读 :help execute。
阅读 :help expr-quote了解你可以在字符串中使用的转义序列。
创建一个“在下一个邮件地址内(inside next email address)”的operator-pending映射，
然后你就可以使用“修改在下一个邮件地址内(change inside next email address)”。
将in@作为映射的按键是个不错的选择。你可能还需要将这个按键映射为/...some regex...<cr>。




### =======================================================%Vimscript 负责任的编码
到目前为止我们已经介绍了一堆Vim命令，这可以让你可以快速自定义Vim。
除了自动命令组外其他的命令都是单行的命令，你可以不费吹灰之力就把它们添加到你的~/.vimrc文件中。

这本书的下一部分我们会开始专注于Vim脚本编程，将其当作一个真正的编程语言对待，不过在此之前，
我会先讲一些在编写大量的Vim脚本时需要注意的东西。


% 注释
Vim脚本非常强大，但对于那些想进入这个领域的程序员而言，
在最近几年它似乎逐渐变得像一个弯弯曲曲的迷宫，让进入的人找不到归路。

Vim的选项和命令经常会比较简短生硬，并且难于阅读，另外处理兼容性问题也会增加代码的复杂度。
编写一个插件并且允许用户自定义又会让复杂度更进一级。

在编写大量Vim脚本时要保持防御意识。要养成习惯添加注释说明某段代码是干什么的，
如果有一个相关的帮助主题（help topic），最好在注释中说明！

这不仅会给你以后的维护带来方便，而且如果你将你的~/.vimrc文件分享到Bitbucket或者GitHub（强烈推荐你这么做），
这些注释也会帮助其他的人理解你的脚本。


% 分组
之前创建的映射可以让我们在使用Vim的同时方便快捷地编辑和加载~/.vimrc。
不幸的是这会导致~/.vimrc中的代码快速增长以至失去控制，并且变得难于阅读浏览。

我们用于对付这种情况的方法是使用Vim的代码折叠功能，将多行代码组织起来的作为一个部分然后对这部分的代码进行折叠。
如果你从来没有用过Vim的折叠功能，那么你现在应该尽快去瞄一瞄。很多人（包括我自己）都认为在日常编码工作中代码折叠是不可或缺的。
首先我们需要为Vim脚本文件设置折叠。在你的~/.vimrc文件中添加下面几行：
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END

这会告诉Vim对任何Vim脚本文件使用marker折叠方法。
现在在显示~/.vimrc文件的窗口中执行:setlocal foldmethod=marker。
如果你不执行这个命令，你会发现加载~/.vimrc文件后没什么效果，
这是因为Vim已经为这个文件设置了文件类型(FileType)，
而自动命令只会在设置文件类型的时候执行。这让你以后不需要手动来做这个事情。

现在在自动命令组开始和结束的地方添加两行，像下面这样：
" Vimscript file settings ---------------------- {{{
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}

切换到常用模式，将光标放到这些文字中的任意一行，然后敲击za。
Vim会折叠从包含{{{的行到包含}}}的行之间的所有行。再敲击za会展开所有这些行。

刚开始你可能会觉得为了代码折叠而对源代码进行注释会有些不合理，我刚开始也这么想。
对于大多数文件我现在仍然觉得这种做法并并不合适。因为不是所有人都使用相同的编辑器，
所以在代码中添加的折叠注释对于那些不用Vim的人而言就像是噪音。

不过Vim脚本文件比较特殊，因为一个不用Vim的人不太可能会读你的代码，
并且最重要的是如果不对代码进行分组处理，写着写着你就不知道写到哪里了，严重点可能会经脉尽断，吐血而亡。

先自己尝试尝试吧，说不定你会逐渐喜欢上它。
简短的名称(Short Names)

对于大多数命令和选项，Vim支持使用它们的缩写。例如，下面的两个命令做的事情完全一样：

:setlocal wrap
:setl wrap

我_强烈_提醒你不要在你的~/.vimrc或者是你编写的插件中使用这些缩写。
Vim脚本对于初学者而言本来就已经够晦涩难懂了；
从长远来看使用缩写只会使得它更难于阅读。即使_你_知道某个缩写的意思，其他人未必读得懂。

换句话说，缩写只在编码的过程中手动执行命令的时候会很有用。
在你按了回车键以后，就没人会看到你输入什么了，这样你也没必要输入更多的字符。

% 练习
检查你的~/.vimrc文件，将所有相关的行组织起来。
你可以这么开头：“基本设置(Basic Settings)“，
”文件类型相关设置(FileType-specific settings)”，“映射(Mappings)”，
和“状态条(Status Line)”。然后在每个部分添加折叠标记和标题。

想想怎么让Vim在第一次打开~/.vimrc文件的时候自动折叠所有设置了折叠注释的行。
阅读:help foldlevelstart你会知道怎么搞。

检查你的~/.vimrc文件，把所有的命令和选项的缩写改成全称。

检查你的~/.vimrc文件，确保里面没有什么敏感信息。
然后创建一个git或者Mercurial仓库，再将~/.vimrc文件放到里面，然后将这个文件链接到~/.vimrc。

提交你刚才创建的仓库，并把它放到Bitbucket或者GitHub上，
这样其他的人都可以看到和学习它。记住要经常提交和推送到仓库中，这样你所做的修改也会被记录下来。

如果你不只在一个机器上使用Vim，那你就可以克隆那个仓库，
然后像之前一样将这个文件链接到~/.vimrc文件。这样你就可以在所有的机器上都使用同样的Vim配置了。



### =======================================================% 变量
到目前为止我们已经讲完了单行命令。在本书后面的三分之一个章节中将会把Vim脚本当作一个脚本语言。
这部分东西不会像前面的你学到的东西一样马上可以学以致用，不过这是为本书的最后一部分打基础，
最后一部分会讲解创建一个插件所需要的各个方面的东西。

我们开始吧。我们首先要了解的是变量。执行下面的命令。
:let foo = "bar"
:echo foo
% Vim会显示bar。foo现在是一个变量，我们将一个字符串"bar"赋值给它。现在执行这些命令：

:let foo = 42
:echo foo
Vim会显示42，因为我们将foo赋值为整型42。
从这些小例子似乎可以看出Vim脚本是动态类型的。事实并非如此，我们之后会说明。



% 作为变量的选项
% 你可以通过一种特殊语法将_选项_作为变量来设置。执行下面的命令：

:set textwidth=80
:echo &textwidth
Vim会显示80。在名称的前面加一个&符号是告诉Vim你正在引用这个选项，而不是在使用一个名称刚好相同的变量。


% 我们来看下Vim是怎么处理布尔选项的。执行下面的命令：
:set nowrap
:echo &wrap
Vim显示0。

% 然后再试试这些选项：
:set wrap
:echo &wrap
这次Vim会显示1。这些输出很明确提示Vim会将整型0当作"false"，整型1当作"true"。
我们可以更进一步假设Vim会将所有的非0值整型当作"truthy"，而事实确实如此。


% 我们也可以使用let命令来_设置_作为变量的选项。执行下面的命令：
:let &textwidth = 100
:set textwidth?
Vim会显示textwidth=100。


% 既然set可以搞定选项的设置，那我们为什么还要用let呢？执行下面的命令：
:let &textwidth = &textwidth + 10
:set textwidth?
这一次Vim显示textwidth=110。当你用set来设置某个选项，你只能给它设置一个常量值。
当你使用let并将它作为一个变量来设置，你可以使用Vim脚本的所有强大之处来决定它的值。


%本地选项
%如果你想将某个选项作为变量来设置它的_本地_值，而不是_全局_值，你需要在变量名前面加前缀。
在两个分隔的窗口中分别打开两个文件。执行下面的命令：
:let &l:number = 1
% 然后切换到另一文件，然后再执行下面的命令：
:let &l:number = 0
注意第一个窗口会出现行号，而第二个没有。



% 作为变量的寄存器(Register)
你也可以将_寄存器_当作变量来读取和设置。执行下面的命令：
:let @a = "hello!"
现在把光标放到文本中的某个地方然后敲击"ap。这个命令会告诉Vim“在这里粘贴寄存器a中的内容”。
我们设置了这个寄存器的内容，所以Vim会将hello!粘贴到你的文本中。

% 还可以读寄存器的内容。执行下面的命令：
:echo @a
Vim会输出hello!。

% 在你的文件中选择一个单词然后用y复制，再执行下面的命令：
:echo @"
Vim会输出你刚才复制的单词。"寄存器是“未命名(unnamed)”寄存器，
在复制的时候没有指定寄存器的文本都会放到这里。

% 在你的文件中执行搜索/someword，然后执行下面的命令：
:echo @/
Vim会输出你刚刚使用的搜索模式。这样你就可以通过编程来读_和修改_当前的搜索模式，有些时候这会很有用。


% 练习
检查你的~/.vimrc文件，然后将其中的一些set和setlocal命令替换为它们的let形式。记住布尔选项仍然需要被设置为某个值。
尝试将某个布尔选项设置为0和1之外的值，例如wrap。当你将它设置为一个不同的数字时会怎么样？如果设置为字符串又会是什么情况？
回到你的~/.vimrc文件，然后恢复所有的修改。在set可以搞定的时候，永远都不要用let，这是因为let更难于阅读。
阅读:help registers，然后看看你可以进行读和写的寄存器列表。




### =======================================================% 变量作用域
%前缀            含义
g:varname      变量为全局变量
s:varname      变量的范围为当前的脚本文件
w:varname      变量的范围为当前的编辑器窗口
t:varname      变量的范围为当前的编辑器选项卡
b:varname      变量的范围为当前的编辑器缓冲区
l:varname      变量的范围为当前的函数
a:varname      变量是当前函数的一个参数
v:varname      变量是 Vim 的预定义变量



### =======================================================% Vimscript 伪变量
&varname 	    一个Vim 选项
&l:varname 	    本地变量(局部变量)
&g:varname 	    全局变量
@varname 	    一个 Vim 寄存器
$varname 	    一个环境变量



### ======================================================= 比较操作(condition)
% 在 Vimscript 中，比较函数始终执行数字比较，除非两个运算对象都是字符串。
% 特别的，如果一个运算对象是字符串，另一个是数字，
% 那么字符串将被转换为数字，然后再对两个数字进行数值比较

let ident = 'Vim'
if ident == 0       "Always true (string 'Vim' converted to number 0)

% 在这种情况下，一种更健壮的解决方案是： if ident == '0'
% 任何字符串比较函数都可以被显式地标记为大小写敏感（通过附加一个 #）或大小写不敏感（通过附加一个 ?）：
if name == ?'vim'
if name == #'Vim'




### =================================================== 算术运算，注意整数和实数差别

let filecount = 234
echo filecount/100          " 显示2
echo filecount/100.0        " 显示2.34



### ======================================================= 语句 (statement)

% 赋值语句：let
let {variable} = {expression}

% 条件控制if 语句：
if {condition}
    {statements}
elseif {condition}
    {statements}
else
    {statements}
endif

% while 语句：
while {condition}
    {statements}
    [ continue ]
    [ break ]
endwhile

% for 语句：
for {varname} in {listexpression}
    {statements}
endfor



### ======================================================= 命令
vim script 语句可以直接支持:命令。
加上normal关键字，也支持normal模式命令。
起码，把script做成批命令是没有问题了。




### ======================================================= 函数
% vim 有许多内置函数。还可以自定义函数。
% 内置函数，内置寄存器，:命令等构成与编辑缓冲的连接，使可以编程控制。
% 自定义函数，按照如下函数格式：
function {Name}({var1}, {var2}, ...)
    {body}
    [ return ]
endfunction


%  例：求两数中最小值函数：
function! s:Min(num1, num2)
    return a:num1 < a:num2 ? a:num1 : a:num2
endfunction



