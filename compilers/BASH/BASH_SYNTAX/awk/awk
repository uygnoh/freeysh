### ========================================================
% awk '條件類型1{動作1} 條件類型2{動作2} ...' filename
awk 後面接兩個單引號並加上大括號 {} 來設定想要對資料進行的處理動作。 
awk 可以處理後續接的檔案，也可以讀取來自前個指令的 standard output 。 
但如前面說的， awk 主要是處理『每一行的欄位內的資料』，
而預設的『欄位的分隔符號為 "空白鍵" 或 "[tab]鍵" 』



### =======================================================
NR,     number of record        ;表示横行数量，行号
NF,     number of field         ;表示竖行数量，列号
FS,                             ;表示输入分隔符，默认是空格符
OFS,                            ;表示输出分隔符，默认是空格符
$0,                             ;表示文件的所有列数
$n,                             ;表示文件的第几列 

### =======================================================
awk '条件类型1{动作1}条件类型2{动作2}......' 文件名                            
% cat /etc/passwd | awk '{FS=":"} $3<10 {print $1 "\t" $3}'
% cat /etc/passwd | awk 'BEGIN{FS=":"} $3<10 {print $1 "\t" $3}'
% awk 'END{print "end of file"}{print $3}' /etc/passwd
% df -h | grep sda3 | awk '{print $5}' | cut -d "%" -f 1



### =======================================================
### "print"代表打印输出;"$"代表打印的位置参数
awk -F: '{print $(NF)}' /etc/passwd             ;只打印文件每行的最后一列
awk -F: '{print $(NF-1}' /etc/passwd            ;只打印文件每行的倒数第二列
awk -F: '{print $1="xxxxxx",$NF}' /etc/passwd   ;把第一列替换成“xxxxxx”
awk -F: '{print $1"---"$NF}' /etc/passwd | head -5

% ysh@debian:~$ ip addr | grep inet | grep -v "127" | grep brd | awk '{print $2}' | awk -F"/" '{print $1}' | awk -F. '{print $1"-"$2"-"$3"-"$4}'

% awk 'NR==7{print NR,$0}' /etc/passwd          ;只打印第7行
% awk 'NF==7{print NR,$0}' /etc/passwd          ;只打每行有7段内容的行

% awk -F: '{print NR "\t" $1 "\t" $2}' /etc/passwd
% awk -F: '{print NF "\t" $1 "\t" $2}' /etc/passwd



### =======================================================
% awk 'BEGIN{FS=":"; OFS="\t"}{print $1,$2}' /etc/passwd

% awk '{a=1; b=3; print a/b}'
___________________________________________________________
### NR,表示行号     FILENAME,表示文件名      $0,表示所有列
% awk '{print NR, FILENAME, $0}' /etc/passwd data.txt   
___________________________________________________________ 
### 打印第1列和第3列中的内容
% awk -F: ' BEGIN{OFS="---"} {print $1,$3} ' /etc/passwd  
___________________________________________________________   
### "/ /"代表整则表达式;"root"代表要第一行要匹配的内容    
### "-F"定义输入字段分割符为“:”  
% awk -F: '/root/{print $1}' /etc/passwd   



 
### ===========================================================================
awk:逐行扫描进行文本处理的一门语言
a.w.k分别为该程序的三位设计者姓氏的第一个字母
用法
		awk '程序' 文件名列表
		awk -f 程序文件名 文件名列表
		程序 条件{动作}
		awk自动对每行文本执行条件判断,满足条件执行动作 (内置循环)
		允许多段程序:多段程序间用空格或分号隔开		
处理方式
	输入文件的每行作为一个“记录”,变量NR就是行号
	每行用空格分隔开的部分,叫做记录的“域”
	内置变量$1是第1域内容,依次,$2是第2域内容,......
	特别的,$0指的是整个这一行的内容
	awk的处理为:符合条件的行,执行相应的动作
___________________________________________________________
awk描述条件的方法
使用与C语言类似的关系算符
	<小于	!= 不等于	<= 小于或等于	> 大于
	==等于	>=大于或等于

使用与C语言类似的逻辑算符
	||条件或		&&条件与		!条件非

正则表达式的模式匹配 /regexpr/
	包含该模式的行,执行动作

特殊的条件
	不指定任何条件,对所有文本行执行动作
	BEGIN	开始处理所有文本行之前执行动作
	END		处理完所有文本行之后执行动作
___________________________________________________________
awk描述动作的方法
描述“动作”时,简单的用法有:
自定义变量
加减乘除等算术逻辑运算
正则表达式匹配运算符(用作条件判断)	~	!~
例如: $2 ~ "[1-9][0-9]*"

___________________________________________________________
流程控制(与C语言类似)
	条件判断 if
	循环控制 for

print 变量1, 变量2,......
printf(”格式串”,变量1,变量2,......)
ps -ef | grep guest
ps -ef | awk ' /guest/{ printf("%s ",$2); }‘

awk '{printf("%d: %s\n",NR,$0); }' test.c

date | awk '{print $4}'

ls -s | awk '$1 > 2000 { print $2 }'




### ======================================================================== awk

awk -W version


Why awk ......?

Headers with BEGIN
Footers with END
Conditions and Loops Internal Function

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% cat user.awk
BEGIN {FS=":"; print "Username"}
END {print "Total users = " NR}

awk -f user.awk /etc/passwd
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% cat user.awk
BEGIN { FS=":"; print "Username" }

$3 > 499 {
    print $1
} 

END { print "Total users = " NR }

awk -f user.awk /etc/passwd
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% cat user.awk
BEGIN { FS=":"; print "Username" }

/^root/ { 
    print $1
    count++
}

END { print "Total users = " count }

awk -f user.awk /etc/passwd
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





___________________________________________________________

                Choosing the right tool
                
awk -F"," ' { print toupper($1), tolower($2), $3 } ' employees

sed ' s@\([^,]*\),\([^,]*\)@\U\1\L\2@ ' employees




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% cat lastlog.awk
BEGIN {
    printf "%8s %11s\n", "Username", "Login date"
    print "================================================"
}

!(/Never logged in/ || /^Username/ || /^root/) {
    count++
    if ( NF == 8 )
        printf "%8s %2s %3s %4s\n", $1, $5, $4, $8
    else
        printf "%8s %2s %3s %4s\n", $1, $6, $5, $9
}

END {
    print "================================================"
    print "Total Number of Users Processed: ", count
}


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% cat tool.sh

#!/bin/bash
OLDIFS=$IFS
IFS=","

while read product price quantity
do
    echo -e "\033[41;37m$product =====================\033[37;0m\n\
    price : \t $price \n\
    Quantity : \t $quantity \n"
    
done <$1
IFS=$OLDIFS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



__________________
% cat tool

drill,99,5
hamner,10,50
brush,3,100
lamp,24,40
scdhi,4,67
__________________



./tool.sh tool
./tool.sh tool | grep -A2 hamner
./tool.sh tool | grep -B2 hamner
./tool.sh tool | grep -C2 hamner
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



___________________________________________________________
ifconfig etho|awk -F":" ' /HWaddr/{ print $# $4 $5 $6 $7 }'

ysh@debian:~$ awk ' { print } ' ~/test.bak 


awk ' BEGIN { print "start ..." } { print } END { print NR } ' ~/test.bak 


awk ' BEGIN { print "start ..." } { print NR, $0 } END { print NR } ' ~/test.bak

ifconfig eth0 | awk -F":" ' /HWaddr/{print $3 $4 $5 $6 $7}'

















