### ======================================================== <<EOF Vs <<-EOF
% 两个都是获取stdin,并在EOF处结束stdin，输出stdout。
% 但是<<-是什么意思呢？

先来看man中的说明：
If the redirection operator is <<-, 
then all leading tab characters are stripped from input lines and  the  line  containing  delimiter.   
翻译过来的意思就是：
如果重定向的操作符是<<-，那么分界符（EOF）所在行的开头部分的制表符（Tab）都将被去除。
这可以解决由于脚本中的自然缩进产生的制表符。
通俗一点的解释：
在我们使用cat <<EOF时，我们输入完成后，需要在一个新的一行输入EOF结束stdin的输入。
EOF必须顶行写，前面不能用制表符或者空格。


### ======================================================== PS1
% PS1是linux里头的一个默认的环境变量，用来设置命令提示符的环境变量。
    \d ：代表日期，格式为weekday month date，例如："Mon Aug 1"
    \H ：完整的主机名称。例如：我的机器名称为：fc4.linux，则这个名称就是fc4.linux
    \h ：仅取主机的第一个名字，如上例，则为fc4，.linux则被省略
    \t ：显示时间为24小时格式，如：HH：MM：SS
    \T ：显示时间为12小时格式
    \A ：显示时间为24小时格式：HH：MM
    \u ：当前用户的账号名称
    \v ：BASH的版本信息
    \w ：完整的工作目录名称。家目录会以 ~代替
    \W ：利用basename取得工作目录名称，所以只会列出最后一个目录
    \# ：下达的第几个命令
    \$ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$	
编辑~/.bashrc，将所有的PS1中的\w替换为\W就可以让
shell只显示最后一个目录名而不显示完整的路径。


### ==================================================== cat /etc/shells

login shell                     su - alice
{/etc/profile, /etc/bashrc, ~/.profile, ~/.bashrc};登陆的shell,这4个文件都执行

nologin shell                   su alice
{/etc/bashrc, ~/.bashrc}                         ;非登陆的shell,它只执行这2个文件
___________________________________________________________
/etc/profile                    系统级配置文件*
/etc/bashrc                     系统级配置文件*
~/.profile                      用户级配置文件
~/.bashrc                       用户级配置文件
~/.bash_logout                  离开shell写入~
~/.bash_history                 离开shell写入~
___________________________________________________________
base64,Base64是网络上最常见的用于传输8Bit字节码的编码方式之一
Base64就是一种基于64个可打印字符来表示二进制数据的方法。
可查看RFC2045～RFC2049，上面有MIME的详细规范。
% base64 <<< meimei
% base64 <<< 'meimeito'


### ========================================================= bash快捷键
Ctrl+Shift++                    ;增大字体
Ctrl+-                          ;缩小字体：
Ctrl+D                          ;退出bash环境, exit
Ctrl+C                          ;杀死当前进程
Ctrl+R                          ;搜索1个历史命令
Ctrl+A                          ;光标移到行首
Ctrl+E                          ;光标移到行尾
Ctrl+L                          ;清屏
Ctrl+d                          ;删除光标所在字母
Ctrl+b                          ;光标左移
Ctrl+f                          ;光标右移
Ctrl+U                          ;清除光标前至行首的内容
Ctrl+K                          ;清除光标后至行尾的内容
touch {a, b, c}
mkdir {dira, dirb, dirc}


============================================================= 前台后台控制
 &, nohup, bg, fg, kill %3, jobs
___________________________________________________________ 
nohup---将程序以忽略挂起信号的方式运行起来(不挂断地运行命令)
% nohup gedit a.c

___________________________________________________________
&
bg 将进程搬到后台运行（Background）；
fg 将进程搬到前台运行（Foreground）； 


___________________________________________________________
job-number 指出进程组号，以和 wait、fg、bg 和 kill 命令一起使用。
当和这些命令一起使用时，在作业号前面加上一个“%”（百分号标志）。

___________________________________________________________
kill 命令参数：
-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称
-a  当处理当前进程时，不限制命令名和进程号的对应关系
-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号
-s  指定发送信号
-u  指定用户 
只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略。 
% 下面是常用的信号;     kill -l
SIGHUP          1               终端断线
SIGINT          2               中断（同 Ctrl + C）
SIGQUIT         3               退出（同 Ctrl + \）
SIGKILL         9               强制终止
SIGTERM         15              终止
SIGCONT         18              继续（与STOP相反, fg/bg命令）
SIGSTOP         19              暂停（同 Ctrl + Z）

======================================================== InPut/OutPut重定向
ysh@debian:~$ ls -l  /dev/std*
lrwxrwxrwx 1 root root 15 3月  14 13:04 /dev/stdin  -> /proc/self/fd/0
lrwxrwxrwx 1 root root 15 3月  14 13:04 /dev/stdout -> /proc/self/fd/1
lrwxrwxrwx 1 root root 15 3月  14 13:04 /dev/stderr -> /proc/self/fd/2
___________________________________________________________
>file_name_ok, >>file_name_ok            ;重定向正确输出到文件file_name_ok中
2>file_name_err, 2>>file_name_err        ;重定向错误输出到文件file_name_ok中
&>file_name                              ;正确输出和错误输出重定向到file_name中
&>/dev/null                              ;正确输出和错误输出重定向到/dev/null中
___________________________________________________________
2>&1                                     ;将标准错误输出重定向到标准输出
% nohup java -jar app.jar >log 2>&1 &
% 每次都写”>log 2>&1”太麻烦，能简写吗？
% 简写方式:   &>log
___________________________________________________________
<, <<;输入重定向(覆盖,append)     >, >>;输出重定向(覆盖,append)    
<<;两个小于号连在一起表示接受一个输入结束的标识，当输入这个标识是结束输入
% cat </etc/passwd >a.password          ;把/ect/passwd文件重定向到a.password


### ================================================================== tee
格式：tee file
输出到标准输出的同时，保存到文件file中。
如果文件不存在，则创建；如果已经存在，则覆盖之。
___________________________________________________________
格式：tee -a file
输出到标准输出的同时，追加到文件file中。
如果文件不存在，则创建；如果已经存在，就在末尾追加内容，而不是覆盖
___________________________________________________________
格式：tee -
输出到标准输出两次
___________________________________________________________
格式：tee file1 file2 -
输出到标准输出两次，同时保存到file1和file2中
% date |tee a.txt



### ======================================================== 逻辑判断 && ||
command1 && command2 ;只有在 && 左边的命令返回真（命令返回值 $? == 0），&& 右边的命令才会被执行
command1 || command2 ;只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才会被执行
% ping -c3 www.baidu.com &>/dev/null && echo "is up" || echo "is down"


### ============================================================ Text color
\e[1        ;开启颜色  
\e[0m       ;关闭颜色
31-37       ;文字颜色,重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37
41-47       ;背景颜色,重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47

% echo -e "\e[1;31mThis text\e[0m"

___________________________________________________________
文字闪动：
echo -e "\033[37;31;5mMySQL Server Stop...\033[39;49;0m"
红色数字处还有其他数字参数：
0 关闭所有属性; 1 设置高亮度(加粗); 4 下划线; 5 闪烁; 7 反显; 8 消隐
033后面第一位是字体颜色+[+31~37，分号后面第二位是背景色，41~47，分号第三位是文字闪烁


### ====================================== 应用程序的转义处理与shell的转义处理
% grep \''192\.168\.[0-9.]*'\''$' *.conf
% grep "'192\\.168\\.[0-9.]*'\$" *.conf
% grep \'192\\.168\\.\[0-9.]\*\'\$ *.conf


### ==================================================== bash中调用python3
% example_1.sh

___________________________________________________________
#!/bin/bash

pwd

/usr/bin/python3 <<-EOF
print("pthon3")
EOF

echo "hello, bash"



### ================================================================ EOF
% test.sh
% 此文件如果在[cat << 'YSH']加上单引号的话，会原样输出信息

___________________________________________________________
#!/bin/bash
cat <<YSH
******************************************************
    Now: `date`
    My home Directory is $HOME

******************************************************
YSH

___________________________________________________________
ysh@debian:~$ cat <<EOF >test.sh
ysh@debian:~$ >123
ysh@debian:~$ >456
ysh@debian:~$ >EOF
ysh@debian:~$ cat <<ABC >test.sh
ysh@debian:~$ >123
ysh@debian:~$ >456
ysh@debian:~$ >ABC



### =============================================================== expect
send                            用于向进程发送字符串
expect                          从进程接收字符串
spawn                           启动新的进程
interact                        允许用户交互
ecpect eof                      
___________________________________________________________
#!/usr/tcl/bin/expect

set timeout 30
set host "101.200.241.109"
set username "root"
set password "123456"

spawn ssh $username@$host
expect "*password*" {send "$password\r"}
interact

___________________________________________________________
#!/usr/tcl/bin/expect

if {$argc < 3} {
    puts "Usage:cmd <host> <username> <password>"
    exit 1
}

set timeout -1
set host [lindex $argv 0] 
set username [lindex $argv 1]
set password [lindex $argv 2]

spawn ssh $username@$host
expect "*password*" {send "$password\r"}
interact














