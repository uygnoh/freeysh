### ==============================================================ARM指令集
Thumb-2 技术引入了 Thumb指令集的一个新的超集，
可以在一种模式下同时使用16位和32位指令集。
___________________________________________________________
% ARM指令集格式
<opcode>{<cond>}{S} <Rd>, <Rn> {,<operand2>}

1 <opcode>      操作码
2 {<cond>}      决定指令执行的条件域
3 {S}           决定指令执行是否影响状态寄存器xPSR的值
4 <Rd>          目的寄存器
5 <Rn>          第一个操作数为寄存器
6 <operand2>    第二个操作数
% ARM指令语法格式中，<>中的内容是必须的，{}中的内容是可选的


CMP R0, R1
BEQ AAA
...
AAA
说明：如果R0==R1,则跳转到AAA标号处执行。



### =========================================================== ARM寻址方式
___________________________________________________________
% 数据处理寻址方式

1.立即数寻址方式
立即寻址指令中的操作码字段后面的地址码部分是操作数本身,
即数据就包含在指令当中，取出了指令也就取出了可以立即使
用的操作数（这样的数称为立即数）

立即数可表示为常数表达式。
在立即数寻址方式中，
规定这个立即数必须是一个8bit的常数通过循环右移偶数位得到。
ARM 只提供了12bit 来放数据，其中8位来记录数值的，
另外4位来放移位的位数，以此来形成一个立即数。

立即数以“#”开头，16进制在#后面加“0x”或“&”表示。
% MOV R0, #0x800            ;R0⇦将立即数0x800装入R0寄存器中
% SUBS R0, R0, #1           ;R0⇦R0-1,结果放入R0.


2.寄存器寻址方式
Rm-----寄存器方式。在寄存器方式下，操作数即为寄存器的数值。
操作数的值在寄存器中，指令中的地址码字段指出的是寄存器编号，
指令执行时直接取出寄存器的值来操作。
% MOV R1, R2                ;r1⇦r2
% SUB R0, R1, R2            ;r0⇦(r1-r2)
注意：第一个是目的寄存器，然后是第一个操作数寄存器，
      最后是第二个操作数寄存器。


3.寄存器移位寻址方式
寄存器移位寻址是ARM指令集持有的寻址方式。
当第2个操作数是寄存器移位方式时，第2个寄存器操作数在与第1个操作
数结合之前，选择进行的移位操作。
% MOV R0, R2, LSL #3        ;R2的值左移3位，结果放入R0；即R0⇦(R2*8)
% ANDS R1, R1, R2, LSL R3   ;R2的值左移R3位，与R1 相与，结果放入R1中,\
%                            加了后缀“S”，表示影响标志位。


___________________________________________________________
% 字及无符号字节的Load/Store指令的寻址方式
% 普通Load/Store指令的寻址方式
语法格式：
LDR|STR{<cond>}{B}{T} <Rd>, <addressing_mode>

注：B为加载字节数据，T为可选后缀。
若指令有T,那么即使处理器在特权模式下,
存储系统也将访问看成是在用户模式下进行的。
T 在用户模式下无效。


___________________________________________________________
% 杂类Load/Store指令的寻址方式
LDR|STR{<cond>}H|SH|SB|D <Rd>, <addressing_mode>

注：B为字节，H为半字，D为双字，S为加载有符号数。
使用该类寻址方式的指令包括：（有符号/无符号）半字Load/Store指令，
有符号字节Load/Store指令和双字Load/Store指令。



___________________________________________________________
% 批量Load/Store指令寻址方式 
批量Load/Store指令将一片连续的内存单元的数据加载到通用寄存器组中
或者将一组通用寄存器的数据存储到内存单元中。

它的寻址模式产生一个内存单元的地址范围，
指令寄存器和内存单元在对应关系满足这样的规则：
编号低的寄存器对应于内存中低地址单元，
编号高的寄存器对应于内存中高地址单元。
% LDM|STM{<cond>}<addressing_mode> <Rn> {!}, <registers><^>



___________________________________________________________
% 协处理器Load/Store指令寻址方式
<opcode>{<cond>}{L}{<coproc>}, <CRd>, <addressing_mode>

其中：opcode为指令操作码
      coproc为协处理器名称
      addressing_mode为指令寻址模式 




___________________________________________________________
% 堆栈操作寻址方式
堆栈是一个按特定顺序进行存取的存储区，操作顺序为“后进先出”。
堆栈寻址是隐含的，它使用了一个专门的寄存器(堆栈指针)指向一块存储区域(堆栈)，
指针所指向的存储单元是堆栈的栈顶。
根据不同的寻址方式，将堆栈分为以下4种：

1 满堆栈，堆栈指针指向栈顶元素
2 空堆栈，堆栈指针指向第一个可用元素
3 递减栈，堆栈向内存地址减小的方向生长
4 递增栈，堆栈向内存地址增加的方向生长

1 FD(Full Descending)
2 ED(Empty Descending)
3 FA(Full Ascending)
4 EA(Empty Ascending)
% 空堆栈，先放数据再调指针
% 满堆栈，先调指针再放数据

如果程序中有对协处理器数据进栈/出栈操作，最好使用FD或FA类型堆栈。
例：
满递减堆栈：
STMFD SP!, {R1-R7, LR}  ;将R1～R7,LR入栈

空递减堆栈：
LDMED SP!, {R-R7, LR}   ;数据出栈放入R1～R7,LR
















