### ================================================ perl Regular Expression


    .	        除了换行字符\n外,找寻只有一个字符的字符串
    x? 	        找寻0个或是1个x字符
    x* 	        找寻0个或是0个以上的x字符
    .* 	        找寻0个或是0个以上的任何字符
    x+ 	        找寻0个或是1个以上的x字符
    .+ 	        找寻1个或是1个以上的任何字符
    {m} 	    找寻刚好是m个个数指定的字符
    {m,n} 	    找寻在m个数个数以上,n个个数以下指定的字符
    {m,} 	    找寻m个个数以上指定的字符
    [] 	        找寻符合[]内的字符
    [^] 	    找寻不符合[]内的字符
    [0-9] 	    找寻符合0到9的任何一个字符
    [a-z] 	    找寻符合a到z的任何一个字符
    [^0-9] 	    找寻不符合0到9的任何一个字符
    [^a-z] 	    找寻不符合a到z的任何一个字符
    ^ 	        找寻字符开头的字符
    $ 	        找寻字符结尾的字符
    \d 	        找寻一个digit(数字)的字符,和[0-9]语法一样
    \d+ 	    找寻一个digit(数字)以上的字符串,和[0-9]+语法一样
    \D 	        找寻一个non-digit(非数字)的字符,和[^0-9]语法一样
    \D+ 	    找寻一个non-digit(非数字)以上的字符,和[^0-9]+语法一样
    \w 	        找寻一个英文字母或是数值的字符,和[a-zA-Z0-9]语法一样
    \w+ 	    找寻一个以上英文字母或是数值的字符,和[a-zA-Z0-9]+语法一样
    \W 	        找寻一个非英文字母,数值的字符,和[^a-zA-Z0-9]语法一样
    \W+ 	    找寻一个以上非英文字母,数值的字符,和[^a-zA-Z0-9]+语法一样
    \s 	        找寻一个空白的字符,和[\n\t\r\f]一样
    \s+ 	    找寻一个以上空白的字符,和[\n\t\r\f]+一样
    \S 	        找寻一个非空白的字符,和[^\n\t\r\f]一样
    \S+ 	    找寻一个以上非空白的字符,和[^\n\t\r\f]+一样
    \b 	        找寻一个不以英文字母,数值为边界的字符串
    \B 	        找寻一个以英文字母,数值为边界的字符串
    a|b|c 	    找到符合a字符或是b字符或是c字符的字符串
    abc 	    找到一个含有abc的字符串

    (pattern) 	()这个符号是会记忆所找寻到的字符,是一个很实用的语法
                第一个()内所找到的字符串变成$1这个变量或是\1变量
                第二个()内所找到的字符串变成$2这个变量或是\2变量
                以此类推,笔者会在下一小节中详细介绍它的用法
                
    /pattern/i 	i这个参数是代表忽略英文大小写的意思,
                也就是在找寻字符 串的时候,不会去考虑英文的大小写
                
    \ 	        如果要在pattern模式中找寻一个有特殊的意义的字符,
                要在 这个字符前加上\这个符号,这样才会让这个特殊字符失效
```

           
            
            
### ===================================================== 文字处理模式的简单范例  

    /perl/ 	    找到含有perl的字符串
    /^perl/ 	找到开头是perl的字符串
    /perl$/ 	找到结尾是perl的字符串
    /c|g|i/ 	找到含有c或g或i的字符串
    /cg{2,4}i/ 	找到c后面跟着2个到4个g,再跟着i的字符串
    /cg{2,}i/ 	找到c后面跟着2个以上g,再跟着i的字符串
    /cg{2}i/ 	找到c后面跟着2个g,再跟着i的字符串
    /cg*i/ 	    找到c后面跟着0个或多个g,再跟着i的字符串,如同/cg{0,1}i/
    /cg+i/ 	    找到c后面跟着一个以上g,再跟着c的字符串,如同/cg{1,}i/
    /cg?i/ 	    找到c后面跟着0个或是一个g,再跟着c的字符串,如同/cg{0,1}i/
    /c.i/ 	    找到c后面跟着一个任意字符,再跟着i的字符串
    /c..i/ 	    找到c后面跟着二个任意字符,再跟着i的字符串
    /[cgi]/ 	找到符合有这三个字符任意一个的字符串
    /[^cgi]/ 	找到没有这三个字符中任意一个的字符串
    /\d/ 	    找寻符合数值的字符串
                可以使用/\d+/来表示一个或是多个数值的字符串
    /\D/ 	    找寻符合不是数值的字符串
                可以使用/\D+/来表示一个或是更多个非数值的字符串
    /\w/ 	    找寻符合英文字母,数值的字符串
                可以使用/\w+/来表示一个或是更多个英文字母,数值的字符串
    /\W/ 	    找寻符合非英文字母,数值字符的字符串
                可以使用/\W+/来表示一个或是更多个非英文字母,数值的字符串
    /\s/ 	    找寻符合空白的字符串
                可以使用/\s+/来表示一个或是更多个空白字符的字符串
    /\S/ 	    找寻符合不是空白的字符串
                可以使用/\S+/来表示一个或是更多不是空白的字符的字符串
    /\*/ 	    找寻符合*这个符号的字符串,因为*在文字处理模式中有它的特殊意思,
                所以要在这个特殊符号前加上\这个符号,这样才会让这个特殊字符失效
    /abc/i 	    找寻符合abc的字符串而且不考虑这些符合字符串的大小写           
          
            

    use encoding 'utf-8';
    $_ = "我正在我正在我学习学习数据结构和算法算法";
    if(/数据结构.算法/){print "match\n";}else{print "NO-match\n";}
    if(/数据结构.*算法/){print "match\n";}else{print "NO-match\n";}
    if(/数据结构.+算法/){print "match\n";}else{print "NO-match\n";}
    if(/学习.*算法/){print "match\n";}else{print "NO-match\n";}
    if(/数据结构和*算法/){print "match\n";}else{print "NO-match\n";}
    if(/数据结构和+算法/){print "match\n";}else{print "NO-match\n";}
    if(/数据结构和?算法/){print "match\n";}else{print "NO-match\n";}
    if(/(数据结构)+和算法/){print "match\n";}else{print "NO-match\n";}

    % "数据结构和算法" 或 "数据结构算法"
    if(/数据结构(和|与)算法/){print "match\n";}else{print "NO-match\n";}

    $_ = "我a你";
    if(/我[abcwxyz]你/){print "match\n";}else{print "NO-match\n";}

    $_ = "我8888你";
    if(/我[01389]+你/){print "match\n";}else{print "NO-match\n";}
    if(/我[A-Za-z0-9_]*你/){print "match\n";}else{print "NO-match\n";} 
    if(/我\w*你/){print "match\n";}else{print "NO-match\n";}
    if(/我[0-9]你/){print "match\n";}else{print "NO-match\n";}
    if(/我\d你/){print "match\n";}else{print "NO-match\n";}
    if(/我[^0-9]你/){print "match\n";}else{print "NO-match\n";}
    if(/我\D你/){print "match\n";}else{print "NO-match\n";}
    if(/我[^\d]你/){print "match\n";}else{print "NO-match\n";}

    $_ = "you me";
    if(/you[\t\n\r\f]me/){print "match\n";}else{print "NO-match\n";}
    if(/you\sme/){print "match\n";}else{print "NO-match\n";}
    if(/you[^\t\n\r\f]me/){print "match\n";}else{print "NO-match\n";}
    if(/you[^\s]me/){print "match\n";}else{print "NO-match\n";}
    if(/you\Sme/){print "match\n";}else{print "NO-match\n";}

    % 可以匹配任何字符
    if(/you[\d\D]me/){print "match\n";}else{print "NO-match\n";}


    % 不匹配任何字符
    if(/you[^\d\D]me/){print "match\n";}else{print "NO-match\n";}
    
    
    
    


### ================================================ 贪婪&懒惰
% 贪婪(尽可能多的匹配)
/a.*b/  (aabab)匹配aabab    

% 懒惰(尽可能少的匹配),匹配任意数量的重复，
% 但是在能使整个匹配成功的前提下使用最少的重复。
/a.*b?/  (aabab)匹配aab


*?          重复任意次，但尽可能少重复
+?          重复1次或多次，但尽可能少重复
??          重复1次或多次，但尽可能少重复
{n, m}?     重复n到m次，但尽可能少重复
{n, }?      重复n次以上，但尽可能少重复




### ========================================================== 量词, 通用量词
% ？号，表示a为1个到0个
$_ = "abc";
if (/a?/) {
    print "匹配上了！";
}


% *号，表示a可以没有，a也可以有多个
$_ = "abc";
if (/a*/) {
    print "匹配上了！";
}


% +号，表示a至少有1个， a也可以有多个 
$_ = "abc";
if (/a+/) {
    print "匹配上了！";
}


$_ = "abc";
if (/a?b*c+/) {
    print "匹配上了！";
}


% 用{}大括号来指定量词，它叫做通用量词
$_ = "abcddddddeef";
if (/a?b*c+d{5}e{2,5}/) {
    print "匹配上了！";
}

% 容易出错的地主,表示以fred开头，或barney结尾
if (/^fred|barney$/) {
    print "匹配上了！";
}
% 修改后的,表示以fred开头，以fred结尾
% 或以barney开头，以barney结尾
if (/^(fred|barney)$/) {
    print "匹配上了！";
}

### ========================================================= 模式测试程序
%% demo
while (<>) {
    chomp;
    if (/你的正则表达式/) {
        print "匹配上的是： |$`<$&>$'|\n";
    } else {
        print "没有匹配上\n";
    }
}


% 测试程序1
while (<>) {
    chomp;
    if (/\s\d+\s) {
        print "匹配上的是： |$`<$&>$'|\n";
    } else {
        print "没有匹配上\n";
    }
}





### ========================================================= 正则表达式的优先级
圆括号         ()
量词           a* a+ a? a{n, m}
锚位和序列      abc ^a a$
择一           a|b|c
元素           a [abc] \d \1







### =============================================================== 模式匹配修饰符

% 指定模式匹配的修饰符，可以改变正则表达式的匹配行为。
% 例如，下面的i就是一种修饰符，它让前面的正则REG匹配时忽略大小写。
m/REG/i

% perl总共支持以下几种修饰符：msixpodualngc
    i   ：匹配时忽略大小写
    g   ：全局匹配，默认情况下，正则表达式"abc"匹配"abcdabc"字符串的时候，
          将之匹配左边的abc，使用g将匹配两个"abc"
    c   ：在开启g的情况下，如果匹配失败，将不重置搜索位置
    m   ：多行匹配模式
    s   ：让.可以匹配换行符"\n"，也就是说该修饰符让.真的可以匹配任意字符
    x   ：允许正则表达式使用空白符号，免得让整个表达式难读难懂，
          但这样会让原本的空白符号失去意义，这是可以使用\s来表示空白
    o：只编译一次正则表达式
    n：非捕获模式
    d：使用unicode或原生字符集，就像5.12和之前那样，也不用考虑这个修饰符
    p：保存匹配的字符串到${^PREMATCH}、${^MATCH}、${^POSTMATCH}中，
       它们在结果上对应$`、$&和$'，但性能上要更好 
    a和u和l：分别表示用ASCII、Unicode和Locale的方式来解释正则表达式，一般不用考虑这几个修饰符
    
    
### ======================================= 范围模式匹配修饰符(?imsx-imsx:pattern)
% 前文介绍的修饰符adluoimsxpngc都是放在m//{FLAG}的flag处的，
% 放在这个位置会对整个正则表达式产生影响，所以它的作用范围有点广。
% 例如m/pattern1 pattern2/i的i修饰符会影响pattern1和pattern2。

perl允许我们定义只在一定范围内生效的修饰符，
方式是(?imsx:pattern)或(?-imsx:pattern)或(?imsx-imsx:pattern)，
其中加上-表示去除这个修饰符的影响。这里只列出了imsx，因为这几个最常用，其他的修饰符也一样有效。


+ 例如，对于待匹配字符串"Hello world gaoxiaofang"，使用以下几种模式去匹配的话：
/(?i:hello) world/
% 表示匹配hello时，可忽略大小写，但匹配world时仍然区分大小写。所以匹配成功

/(?ims:hello.)world/
% 表示可以跨行匹配helloworld，也可以匹配单行的hellosworld，且hello部分忽略大小写。所以匹配成功

/(?i:hello (?-i:world) gaoxiaoFANG)/
% 表示在第二个括号之前，可用忽略大小写进行匹配，但因为第二个括号里指明了去除i的影响，
% 所以对world的匹配会区分大小写，但是对gaoxiaofang部分的匹配又不区分大小写。所以匹配成功

/(?i:hello (?-i:world) gaoxiao)FANG/
% 和前面的类似，但是将"FANG"放到了括号外，意味着这部分要区分大小写。所以匹配失败
