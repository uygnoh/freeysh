### =========================================================== 捕获变量
% ()小括号有2个功能， 1个是捕获，另一个是分组

% 小括号的捕获功能，捕获变量 
1. \s           表示匹配空白开头的行
2. \w           表示[a-zA-Z0-9_]
3.  +           表示匹配1个到多个单词
4.  ,           表示包含这个符号
5. (/\s(\w+),/  表示它匹配hterc,
6. (\w+)        这个括号，表示它启动了正则表达式的捕获功能
7. (\w+)        表示它把捕获的变量放到$1中
8. $1           表示它把捕获到的变量放入它里面
% 
$_ = "hello hterc, neighbor";
if(/\s(/w+),/){
    print $1;
}


% 让它捕获多个，"Hello there, neighbor"它正好匹配它
% \S表示不包含空白
$_ = "Hello there, neighbor";
if(/(\S+) (\S+), (\S+)/) {
    print "$1 $2 $3";
}



% "I fear that I'll be extinct after 1000 years.";
% 匹配上面的字符串中的数字并打印出来 {匹配数字}
% 运行结果： 1000
my $dino = "I fear that I'll be extinct after 1000 years.";
if($dino =~ /(\d*) years/) {
    print "$1 \n";
}



% 捕获其中的字符
% 运行结果： one two three four
$_ = "one two three four five six";
if(/(\S+) (\S+) (\S+) (\S+)/) {
    print "$1 $2 $3 $4 \n";
}


% 我们只想要它分组， 不要捕获
% ?:它表示只用来分组，不用来作捕获
% 运行结果： two three four five
$_ = "one two three four five six";
if(/(?:\S+) (\S+) (\S+) (\S+)/) {
    print "$1 $2 $3 $4 \n";
}



% 使用特殊变量来作捕获 $1 $2 $3 #n
% 我们用一个绑定表达式，再用一个正则表达式去捕获
% 使用”?:“只作分组，不作捕获
% 运行结果： Fred Barney
my $name = "Fred and Barney";
if ($name =~ m/(\w+) and (\w+)/) {
    print "$1, $2 \n";
}

% 运行结果： Fred Barney
my $name = "Fred and Barney";
if ($name =~ m/(\w+) (?:or|and) (\w+)/) {
    print "$1 $2 \n";
}

% 运行结果： Fred Barney
my $name = "Fred and Barney";
if ($name =~ m/(\w+) (or|and) (\w+)/) {
    print "$1 $3 \n";
}


### ======================================================== 重命明捕获
% 把第1个捕获到的命为name1, 把第2个捕获到的命为name2
% 重命明后它存储在一个特殊的hash中，$+{re_name}格式取出
% print "$1 $2", 重命名的这个变量在一个特殊的哈希里，
% 我们就用 $+{renameN} 取出里面的数据 。
% 运行结果： Fred Barney

my $name = "Fred and Barney";
if ($name =~ m/(?<name1>\w+) (?:or|and) (?<name2>\w+)/) {
    print "$+{name1} $+{name2}";
}





### =================================================== 重命明用在反向引用的使用
% \g{last_name}反向引用
my $names = "Fred Flinstone and Wilma Flinstone";
if ($name =~ /(?<last_name>\w+) and \w+ \g{last_name}/) {
    print "$+{last_name}\n";
}


% \k<last_name>反向引用
my $names = "Fred Gates and Wilma Gates";
if ($name =~ /(?<last_name>\w+) and \w+ \k<last_name>/) {
    print "$+{last_name}\n";
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 自动[匹配 捕获]变量
% $1        捕获到的是(\w+) 运行结果：three
% $&        捕获到的是/\s(\w+),/ 运行结果： three,
% $'        捕获到之后的字符串
% $`        捕获到之前的字符串    
% $`$&$'    捕获到的是原始的字符串
$_ = "one two three, four five six";
if (/\s(\w+),/) {
    print "$1\n";       # 捕获到小括号中的字符串
    print "$&\n";       # 匹配到的字符串
    print "$'\n";       # 匹配到之后的字符串
    print "$`\n";       # 匹配到之前的字符串  
    print "$`$&$'\n";   # 匹配的是原始的字符串
    print "$`<$&>$'\n"; # 把匹配的部分标识出来
}



### ========================================================== 量词, 通用量词

% ？号，表示a为1个到0个
$_ = "abc";
if (/a?/) {
    print "匹配上了！";
}


% *号，表示a可以没有，a也可以有多个
$_ = "abc";
if (/a*/) {
    print "匹配上了！";
}


% +号，表示a至少有1个， a也可以有多个 
$_ = "abc";
if (/a+/) {
    print "匹配上了！";
}


$_ = "abc";
if (/a?b*c+/) {
    print "匹配上了！";
}


% 用{}大括号来指定量词，它叫做通用量词
$_ = "abcddddddeef";
if (/a?b*c+d{5}e{2,5}/) {
    print "匹配上了！";
}

% 容易出错的地主,表示以fred开头，或barney结尾
if (/^fred|barney$/) {
    print "匹配上了！";
}
% 修改后的,表示以fred开头，以fred结尾
% 或以barney开头，以barney结尾
if (/^(fred|barney)$/) {
    print "匹配上了！";
}

### ========================================================= 模式测试程序
%% demo
while (<>) {
    chomp;
    if (/你的正则表达式/) {
        print "匹配上的是： |$`<$&>$'|\n";
    } else {
        print "没有匹配上\n";
    }
}


% 测试程序1
while (<>) {
    chomp;
    if (/\s\d+\s) {
        print "匹配上的是： |$`<$&>$'|\n";
    } else {
        print "没有匹配上\n";
    }
}





### ========================================================= 正则表达式的优先级
圆括号         ()
量词           a* a+ a? a{n, m}
锚位和序列      abc ^a a$
择一           a|b|c
元素           a [abc] \d \1




### ========================================================== 特殊变量 $_
+ 不使用特殊变量($_)的情况下, 使用绑定操作符(=~)
$content = "one another one";
$content =~ s/one/two/g;


% (fred|barney)转换成大写字母
$_ = "I saw Barney with Fred";
s/(fred|barney)/\U$1/ig;
print "$_\n";

% (fred|barney)转换成小写字母
$_ = "I saw Barney with Fred";
s/(fred|barney)/\L$1/ig;
print "$_\n";
```


### ================================================= 正则表达式捕获功能替换字符串 
+ 正则表达式捕获功能替换字符串，并改为大写
+ 正则表达式捕获功能替换字符串，用E来结束大写 
```perl
$-_ = "this is one and two";
s/(\w+) and (\w+)/$2 and $1/;

$-_ = "this is one and two";
s/(\w+) and (\w+)/\U$2 and $1/;

$-_ = "this is one and two";
s/(\w+) and (\w+)/\U$2\E and $1/;
```

+ \U全部字母大写 
+ \u第1个字母大写，其它不变
+ \l第1个字母小写，其它不变
+ \L全部字母小写
+ \u\L第1个字母大写，其它字母小写 
+ \E表示来结束大小写字母
```perl
$_ = "one and two";
s/(one|two)/\U$1/gi;
print "$_\n";

$_ = "one and two";
s/(one|two)/\u$1/gi;
print "$_\n";

$_ = "one and two";
s/(one|two)/\u$1/gi;
print "$_\n";

$_ = "one and two";
s/(one|two)/\u\L$1/gi;
print "$_\n";

$name = "bill";
print "Hello, \L\u$name\E, would you like to play a game?\n";













