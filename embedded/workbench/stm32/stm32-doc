###########################################################
### % STM32通用功能和复用功能I/O
###########################################################
% General-purpose and alternate-function I/O
% /* GPIOx_CRL和GPIOx_CRH 配置表 */
%           %               CNF1   CNF0  MODE1  MODE0   PxODR  
Input       Analog            0     0     0      0      x     模拟输入
Input       Input floating    0     1     0      0      x     浮空输入
input       Input pull-down   1     0     0      0      0     下拉输入
input       input pull-up     1     0     0      0      1     上拉输入
output      Push-pull         0     0     01-10-11      0 or 1通用推完输出 
output      Open-drain        0     1     01-10-11      0 or 1通用开漏输出
output      Push-pull         1     0     01-10-11      x     推挽式复用功能
output      Open-drain        1     1     01-10-11      x     开漏式复用功能
% 注意：下拉输入和上拉输入是通过端口输出寄存器 GPIOxODR 来区分。
% 01-10-11  输出最大速度分别是： 10 MHz, 2 MHz, 50 MHz.



% /* GPIOx 端口配置 */
/* 设置GPIOA引脚的工作模式 [ GPIOA.0 GPIO.1, 推挽式输出，50MHz ] */
	GPIOA->CRL = 0x00000033
/* 在GPIOA.0，GPIO.1引脚输出一个高电平 */
	GPIOA->ODR = 0x00000003



% /* AFIO 复用功能输入输出 */
AFIO_EVCR       事件控制寄存器
AFIIO_MAPR      复用重映射和调试 I/O 配置寄存器
AFIO_EXTICR1    外部中断配置寄存器 1
AFIO_EXTICR2    外部中断配置寄存器 2
AFIO_EXTICR3    外部中断配置寄存器 3
AFIO_EXTICR4    外部中断配置寄存器 4



% /* GPIO 通用功能输入输出寄存器 */
2个32位配置寄存器	GPIOx_CRL, GPIOx_CRH
2个32位数据寄存器	GPIOx_IDR, GPIOx_ODR
1个32端口位设置/清除寄存器	GPIOx_BSRR
1个32位端口位清除寄存器	GPIOx_BRR
1个32位锁定寄存器	GPIOx_LCKR



% /* 端口复用功能和重映射功能 */
1.端口复用功能 AFIO
	如果一个端口配置成复用功能，将使引脚和输出寄存器断开，并和片上外设的输出信号连接。
	复用功能最好配置成 浮空输入模式， 模拟输入不支持复用功能
	开启复用功能相关端口

2.重映射
	将芯片内部的外设模块固定分配的端口重新映射到其他端口的功能。
	没有重映射， 部分重映射， 完全重映射
	重映射功能可以额外的增加资源

% /* USART1 端口重映射启用 */
GPIO_PinRemapConfig(GPIO_Remap_USART1, ENABLE);





###########################################################
### % STM32时钟系统
###########################################################
% /* STM32时钟源 */
内部高速时钟HSI, 外部高速时钟HSE, 
内部低速时钟LSI, 外部低速时钟LSE, 
PLL时钟
PLL         锁相环，启到倍频作用
Prescaler   分频器
Multiplier  倍频器
MCO         微控制器时钟输出端口 
CSS         时钟监视系统，一旦HSE时钟失效，则自动切换至 SYSCLK=HSI



% /* 使用外部高速晶体振荡器, 配置为72MHz */
void rcc_configure(void)
{
	/* HSE_configuration */
	RCC_DeInit();                                         /* 初始化为缺省值               */
	RCC_HSEConfig(RCC_HSE_ON);                            /* 使能外部高速时钟             */			
	while (RCC_GetFlagStatus(RCC_FLAG_HSERDY) == RESET);  /* 等待外部高速时钟稳定          */ 	
	FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); /* enable prefetch buffer     */
	FLASH_SetLatency(FLASH_Latency_2);                    /* flash 2 wait state         */
	RCC_HCLKConfig(RCC_SYSCLK_Div1);                      /* HCLK  ==  SYSCLK           */
	RCC_PCLK2Config(RCC_HCLK_Div1);                       /* PCLK2 ==  HCLK             */
	RCC_PCLK1Config(RCC_HCLK_Div2);                       /* PCLK1 ==  HCLK/2           */
	RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);  /* PLLCLK == 8MHz*9 ==72MHz   */
	RCC_PLLCmd(ENABLE);                                   /* enable PLLCLK              */
	while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);  /* wait till  PLLCLK is ready */
	RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);            /* select PPLL as system clock*/
	while (RCC_GetSYSCLKSource() != 0x08);                /* wait till PLL is used as system clock source */
	
	/* usart1_configuration */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
}
% /* RCC 时钟配置流程 */
RCC_DeInit();                                        /* 1  将RCC寄存器重新设置为默认值 */    
RCC_HSEConfig(RCC_HSE_ON);                           /* 2  打开外部高速时钟晶振HSE */          
HSEStartUpStatus = RCC_WaitForHSEStartUp();          /* 3  等待外部高速时钟晶振工作 */          
RCC_HCLkConfig();                                    /* 4  设置AHB时钟 */                   
RCC_PCLK2Config();                                   /* 5  设置高速APB时钟 */	                
RCC_PCLK1Config();                                   /* 6  设置低速APB时钟	 */                
RCC_PLLConfig();                                     /* 7  设置PLL */                      
RCC_PLLCmd(ENABLE);                                  /* 8  打开PLL */                
while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);  /* 9  等待PLL工作稳定	 */        
RCC_SYSCLKConfig();                                  /* 10 设置系统时钟 */             
while(RCC_GetSYSCLKSource() != 0x08);                /* 11 判断是否 PLL 是系统时钟 */   
RCC_APB2PerphClockCmd();                             /* 12 打开要使用的外设时钟 */        
RCC_APB1PerphClockCmd();
					
					
					
					
					
					
	
###########################################################
### % STM32中断系统
###########################################################					
% NVIC嵌套向量中断控制器



% 外部中断/事件控制器(EXTI)
对于互联型产品,外部中断/事件控制器由20个产生事件/中断请求的边沿检测器组成,对于其它
产品,则有19个能产生事件/中断请求的边沿检测器。每个输入线可以独立地配置输入类型(脉冲
或挂起)和对应的触发事件(上升沿或下降沿或者双边沿都触发)。每个输入线都可以独立地被屏
蔽。挂起寄存器保持着状态线的中断请求。
1 中断屏蔽寄存器(EXTI_IMR)
2 事件屏蔽寄存器(EXTI_EMR)
3 上升沿触发选择寄存器(EXTI_RTSR)
4 下降沿触发选择寄存器(EXTI_FTSR)
5 软件中断事件寄存器(EXTI_SWIER)
6 挂起寄存器(EXTI_PR)



% 中断配置
1 时钟配置
2 GPIO配置
3 EXTI配置
(中断源的选择，清除中断标志为了避免误操作，触发模式)
4 NVIC配置
(配置NVIC是那一个组， 指定主优先级&从优先级， 中断通道是否开启 )
5 中断服务子程序



% STM32中断系统配置例程
{
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);   //使能GPIOB时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);    //使能GPIO的复用功能
    
    
    // GPIO, 配置PB6为外部中断
    GPIO_DeInit(GPIOB);
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    
    
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource6); //选择 GPIO 管脚用作外部中断线路
    //EXTI, 外部中断配置
    EXIT_DeInit();
    EXTI_InitTypeDef EXTI_InitStructure;
    EXTI_InitStructure.EXTI_Line = EXTI_Line6;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);
    EXTI_ClearITpendingBit(EXTI_Line6); //清除EXTI_Line6中断标志，为了安全
    
    
    //NVIC配置
    NVIC_InitTypeDef NVIC_InitStructure;
    /* 配置组为第1组，先占优先级 1 位， 从优先级 3 位 */
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQChannel; /* 外部中断线 9-5 中断 */
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure(&NVIC_InitStructure);
    
    
    
    
    
    //中断服务子程序
    void EXTI9_5_IRQHandler(void)
    {
        GPIO_ResetBits(GPIOA, GPIO_Pin_3);
        Delay_MS(1000);
        EXTI_ClearITPendingBit(EXTI_Line6); //清除中断标志位
    }
        
}




###########################################################
### % usart通信
###########################################################
/* 串口1(USART1)初始化配置(寄存器版)
 * 2018.10.29
 * @freeysh
 * 设置 USART1模块，UE使能位，M位来定义字长， 
 * 停止位位数，TE位，BRR寄存器选择波特率 
 */
USART1->CR1 |= (1<<13);
USART1->CR1 &= ~(1<<12);
USART1->CR2 &= ~(3<<12);	/* USART->CR2 &= ~((1<<12) | (1<<13)); */
USART1->CR1 |= (1<<3);

/*
 * USART 波特率配置 
 * 波特率 9600, 系统时钟 72MHz,
 * Tx/Rx波特率 = ƒck/(16*USARTDIV)
 * 9600 = 72*1000*1000/(16*U)
 * U = 72000000/(9600*16)
 */
float Div;
u16 M,F,BRR;
u32 Bound;
Bound = 9600;
Div = (float)(72*1000*1000)/(Bound*16);
M = Div;	// 取整数部分
F = (Div-M)*16; // 小数部分
% /* 整合整数部分和小数部分 */
BRR = M<<4 + F;
USART1->BRR = BRR;


/* 发送一个字符 'A' 到 USART的DR寄存器 */
	int i, data,;
	data = 'A';
	USART->DR = data;
	for (i = 0; i < 30; i++) 
	{
		data++;
		while ((USART1->SR & (1<<6) == 0);
	}
	
	
	
	
% usart通信过程	
/* 数据发送过程 */
	1. 设置 USART_CR1寄存器中 UE位置位 来激活USART
	2. 设置 USART_CR1寄存器中 的M位    来定义字长
	3. 设置 USART_CR2寄存器中 编写停止位位数
	*  如果采用多缓冲器通信，配置 USART_CR3寄存器中的 DMA使能位(DMAT)
	4. 设置 USART_CR1中的 TE位，发送一个空闲帧作为第一次数据的发送
	5. 设置 USART_BRR寄存器，设定要求的波特率
	6. 把发送的数据写进 USART_DR寄存器 (此动作自动清除 TXE位)。
	   -----在只有一个缓冲器的情况下，对每个待发送的数据重复此步骤

/* 数据接收过程 */
	1. 设置 USART_CR1寄存器中 UE位置位 来激活USART
	2. 设置 USART_CR1寄存器中 的M位    来定义字长
	3. 设置 USART_CR2寄存器中 编写停止位位数
	*  如果采用多缓冲器通信，配置 USART_CR3寄存器中的 DMA使能位(DMAT)
	4. 设置 USART_BRR寄存器，设定要求的波特率
	5. 设置 USART_CR1中的 RE位，激活接收器，使他开始寻找起始位

/* 当一个字符被接收时 */
	RXNE位被置位。它表明移位寄存器的内容被转移到 RDR.
	RXNEIE位被置位。则产生中断信号.
	在接收期间如果检测到帧错误，噪音或溢出错误，错误标志将被置起.



% /* usart寄存器 */
USART_SR	状态寄存器
USART_DR	数据寄存器
USART_BRR	波特比率寄存器
USART_CR1	控制寄存器 1
USART_CR2	控制寄存器 2
USART_CR3	控制寄存器 3
1. 起始位
2. 数据位 (8, 9)
3. 奇偶校验位 (9 bit)
4. 停止位 (1, 1.5, 2)
5. 波特率设置 (速度)







