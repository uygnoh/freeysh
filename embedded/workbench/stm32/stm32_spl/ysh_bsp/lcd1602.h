#ifndef __LCD1602_H__
#define __LCD1602_H__



#endif








/*
1 管脚：1602共16个管脚，但是编程用到的主要管脚不过三个，分别为：
  RS(数据命令选择端),R/W（读写选择端）,E（使能信号）;
% RS    为寄存器选择，高电平选择数据寄存器，低电平选择指令寄存器。
% R/W   为读写选择，高电平进行读操作，低电平进行写操作。
% E     端为使能端，后面和时序联系在一起。
% D0~D7 分别为8位双向数据线。

2 LCD1602操作时序：
RS      R/W     操作说明                                                E
0       0       将 DB0~DB7 的指令代码写入指令寄存器中                       1->0
0       1       分别将状态标志 BF 和地址计数器(AC)内容读到 DB7 和 DB6~DB0    1
1       0       将 DB0~DB7 的数据写入数据寄存器中,模块的内部操作              1->0
                % 自动将数据写到 DDRAM 或者 CGRAM 中                
1       1       将数据寄存器内的数据读到 DB0~DB7,模块的内部操作自             1
                % 动将 DDRAM 或者 CGRAM 中的数据送入数据寄存器中

3 LCD1602注意事项
注：关于E=H脉冲——开始时初始化E为0，然后置E为1，再清0.
读取状态字时，注意D7位，D7=1，禁止读写操作；D7=0，允许读写操作；
所以对控制器每次进行读写操作前，必须进行读写检测。（即后面的读忙子程序）

4 LCD1602读忙子程序：
void  read_busy()
{
    uchar state;
    LCD1602_DB = 0xff;      //LCD1602正忙，禁止读写数据或命令
    LCD1602_RS = 0;
    LCD1602_RW = 1;
    do {
        LCD1602_E = 1;
        state     = LCD1602_DB;
        LCD1602_E = 0;      //读完状态后撤销使能，防止LCD输出干扰总线
    } while (state&0x80);   //若LCD为忙碌状态就持续检测，一直到不忙为止
}
此处用do-while而不能用whil，do-while是执行一次后再进行判断，而while是直接进行判断；
若LCD一开始就是空闲状态的的话，空闲状态无法存储，在接下的操作中无法读出LCD的状态，从而无法再LCD上显示
*/
















