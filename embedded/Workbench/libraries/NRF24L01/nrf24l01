###########################################################
### % NRF24L01是NORDIC公司生产的无线通信芯片
###########################################################
1 % 采用FSK调制
2 % 可以实现点对点，或是1对6的通信
3 % 无线通信速度可达2Mbps
4 % 引脚定义
    1 GND
    2 VCC
    3 CE    % 使能器件的发送模式或接收模式
    4 CSN   % 从器件使能信号
    5 SCK   % 时钟信号，由主器件产生
    6 MOSI  % 主器件输出，从器件输入
    7 MISO  % 主器件输入，从器件输出
    8 IRQ   % 中断信号
    
    
    
###########################################################
### % NRF24L01寄存器(nrf24l01.h)
###########################################################    
#ifndef __NRF24L01_H__
#define __NRF24L01_H__
/* % NRF24L01_SPI接口指令(8个指令) */
#define R_REGISTER      0x00    // 读配置寄存器,低5位为寄存器地址
#define W_REGISTER      0x20    // 写配置寄存器,低5位为寄存器地址
#define R_RX_PAYLOAD    0x61    // 读RX有效数据,1~32字节,用于接收
#define W_TX_PAYLOAD    0xA0    // 写TX有效数据,1~32字节,用于发送
#define FLUSH_TX        0xE1    // 清除TX_FIFO寄存器.发射模式下用
#define FLUSH_RX        0xE2    // 清除RX_FIFO寄存器.接收模式下用
#define REUSE_TX_PL     0xE3    // 重新使用上一包数据,CE为高,数据包被不断发送.
#define NOP             0xFF    // 空操作,可以用来读状态寄存器
/* % NRF24L01寄存器内容设置(24个寄存器) */
#define CONFIG          0x00    // 配置寄存器地址
#define EN_AA           0x01    // 使能自动应答功能
#define EN_RXADDR       0x02    // 接收地址允许
#define SETUP_AW        0x03    // 设置地址宽度(所有数据通道)
#define SETUP_RETR      0x04    // 建立自动重发
#define RF_CH           0x05    // RF通道
#define RF_SETUP        0x06    // RF寄存器
#define STATUS          0x07    // 状态寄存器
#define OBSERVE_TX      0x08    // 发送检测寄存器
#define CD              0x09    // 载波检测寄存器
#define RX_ADDR_P0      0x0A    // 数据通道0接收地址
#define RX_ADDR_P1      0x0B    // 数据通道1接收地址
#define RX_ADDR_P2      0x0C    // 数据通道2接收地址
#define RX_ADDR_P3      0x0D    // 数据通道3接收地址
#define RX_ADDR_P4      0x0E    // 数据通道4接收地址
#define RX_ADDR_P5      0x0F    // 数据通道5接收地址
#define TX_ADDR         0x10    // 发送地址寄存器
#define RX_PW_P0        0x11    // 接收数据通道0有效数据宽度(1~32字节)
#define RX_PW_P1        0x12    // 接收数据通道1有效数据宽度(1~32字节)
#define RX_PW_P2        0x13    // 接收数据通道2有效数据宽度(1~32字节)
#define RX_PW_P3        0x14    // 接收数据通道3有效数据宽度(1~32字节)
#define RX_PW_P4        0x15    // 接收数据通道4有效数据宽度(1~32字节)
#define RX_PW_P5        0x16    // 接收数据通道5有效数据宽度(1~32字节)
#define FIFO_STATUS     0x17    // FIFO状态寄存器
#endif  



###########################################################
### % NRF24L01配置步骤
########################################################### 
/* 接收模式(RX模式初始化配置步骤) */
1 % (RX_ADDR_P0)        写RX节点的地址   
2 % (EN_AA->AUTO_ACK)   使能自动应答      
3 % (EN_RXADDR)         使能通道0           
4 % (RF_CH)             选择通信频率       
5 % (RX_PW_P0)          选择通道0有效数据宽度 
6 % (RF_SETUP)          配置发射参数(低噪放大增益，发射功率，速率)
7 % (CONFIG)            基本参数配置及切换工作模式

/* 发射模式(TX模式初始化配置步骤) */
1 % (TX_ADDR)           写TX节点的地址
2 % (RX_ADDR)           写RX节点的地址
3 % (EN_AA->AUTO_ACK)   使能自动应答  
4 % (EN_RXADDR)         使能通道0 
5 % (SETUP_RETR)        配置自动重发次数
6 % (RF_CH)             选择通信频率
7 % (RX_PW_P0)          选择通道0有效数据宽度 
8 % (RF_SETUP)          配置发射参数(低噪放大增益，发射功率，速率
9 % (CONFIG)            基本参数配置及切换工作模式



###########################################################
### % NRF24L01(nrf24l01.c)
###########################################################

/*
 * @brief   写1个字节到NRF24L01
 * @return  返回读到的数据
 */
uint8_t spi_rw(uint8_t byte)
{
    uint8_t i;
    for (i = 0; i < 8; i++)     // output 8-bit
    {
        MOSI = (byte & 0x80);   // output 'byte', MSB to MOSI
        byte = (byte << 1);     // shift next bit into MSB
        SCK = 1;                // set SCK high.
        byte |= MISO;           // capture current MISO bit
        SCK = 0;                // ..then set SCK low again.
    }
    return(byte);               // return read byte
}


/*
 * @brief   读写寄存器地址，并向寄存器中写入值
 * @return  寄存器status
 */
uint8_t spi_rw_reg(uint8_t reg, uint8_t value)
{
    uint8_t status;
    CSN = 0;                // CSN low, init SPI transaction
    status = spi_rw(reg);   // select register
    spi_rw(value);          // ..and write value to it..
    CSN = 1;                // CSN high again
    return(status);        //  return nRF24L01 status byte
}


uint8_t spi_read(uint8_t reg)
{
    uint8_t reg_val;
    CSN = 0;
    spi_rw(reg);            // select register to read from..
    reg_val = spi_rw(0);    // ..then read register value
    CSN = 1;
    return(reg_val);
}


uint8_t spi_read_buf(uint8_t reg, uint8_t *pbuf, uint8_t bytes)
{
    uint8_t status, byte_ctr;
    
    CSN = 0;
    status = spi_rw(reg);
    for (byte_ctr = 0; byte_ctr < bytes; byte_ctr++)
        pbuf[byte_ctr] = spi_rw(0); //Perform spi_rw to read byte from nRF24L01
    CSN = 1;
    return(status);  
}


uint8_t spi_write_buf(uint8_t reg, uint8_t *pbuf, uint8_t bytes)
{
    uint8_t status, byte_ctr;
    
    CSN = 0;
    status = spi_rw(reg);
    /* then write all byte in buffer(*pbuf) */
    for (byte_ctr = 0; byte_ctr < bytes; byte_ctr++)
        spi_rw(*pbuf++); 
    CSN = 1;
    return(status);  
}



void RX_Mode(void)
{
    
}




void TX_Mode(void)
{
    
}





















 
