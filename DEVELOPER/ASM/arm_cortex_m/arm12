### ===================================================== ARM汇编语言伪指令
% 指令-------->指令性语句 ↝处理器执行
% 伪指令------>指示性语句 ↝汇编器处理

% 指令有相应的操作码，而伪指令没有
一般指令是在程序运行时由CPU执行，而伪指令是在源程序汇编时由汇编程序来处理

伪指令在源程序中的作用是为完成汇编程序作各种准备工作的，
这些伪指令仅在汇编过程中起作用，
旦汇编结束，伪指令的使命就完成了。



### ======================================================== 数据定义伪指令
___________________________________________________________
% 字节单元定义伪指令 DCB
格式：标号 DCB 表达式

功能：DCB伪指令用分配一片连续的字节存储单元，
      并用伪指令指定的表达式初始化。
注意：表达式可以为 0～255 的数字或字符串。
      DCB也可能用 “=”代替。
例如：
	str DCB "this is a test!" ;分配连续的字节存储单元
                              ;并初始化

___________________________________________________________
% 半字单元定义伪指令 DCW （或DCWU）
格式：标号 DCW （或DCWU） 表达式

功能：DCW(或DCWU）伪指令用于分配一片连续的半字单元
      并用伪指令中指定的表达式初始化。
注意：表达式可以为和序标号或数字表达式。
      用DCW分配的存储单元是半字对齐的，
      而用DCWU 分配的存储单元并不严格半字对齐。
例如：
	data_test DCW 1, 2, 3,  ;分配连续的半字存储单元
                                ;并初始化

___________________________________________________________
% 字单元定义伪指令 DCD （或DCDU)
格式：标号 DCD(或DCDU) 表达式

功能：DCD（或DCDU)伪指令作于分配一片连续的字存储单元
      并用伪指令中指定的表达式初始化。
注意：表达式可以为程序标号或数字表达式。
      DCD也可以用 “&” 代替。
      作DCD分配的存储单元是字对齐的，
      而用DCDU分配的存储单元并不严格字对齐。
例如：
	datatest DCD 2, 1, 5  ;分配连续的字存储单元
                              ;并初始化
___________________________________________________________
% 双精度定义伪指令DCFD(或DCFDU)
格式：标号 DCFD(或DCFDU) 表达式

功能：DCFD(或DCFDU) 伪指令用于双精度浮点数
      分配一片连续的存储单元并用伪指令中指定的表达式初始化。
      每个双精度浮点数占用 2个字存储单元。
注意：用DCFD分配的存储单元是字对齐的，
      而用DCFDU分配的存储单元并不严格字对齐。
例如：
	FDataTest DCFD 5E13, -4E2 ;分配连续的字存储单元
                              ;并初始化为指定的双精度
___________________________________________________________
% 单精度数定义伪指令 DCFS(或DCFSU)
格式：标号 DCFS(或DCFSU) 表达式

功能：DCFS(或DCFSU) 伪指令用于为单精度浮点数
      分配一片连续的字存储单元并用伪指令指定的表达式初始化。
注意:每个单精度浮点数占用 1个字单元。
     用DCFS分配的存储单元是字对齐的，
     而用DCFSU分配的存储单元并不严格字对齐。
例如：
	FDataTest DCSD 3E15, -4E2 ;分配连续的字存储单元
                                  ;并初始化为指定的单精度数      
___________________________________________________________
% 双字单元定义伪指令 DCQ （或DCQU)
格式：标号 DCQ(或DCQU) 表达式

功能：DCQ(或DCQU)伪指令作于分配一片以 8 个字节为单位的连续存储单元
      并用伪指令中指定的表达式初始化。
注意：表达式可以为程序标号或数字表达式。
      作DCQ分配的存储单元是字对齐的，
      而用DCQU分配的存储单元并不严格字对齐。
例如：
	datatest DCQ 226      ;分配连续的字存储单元
                          ;并初始化指定的值
___________________________________________________________
% 存储区域定义伪指令
格式：标号 SPACE 表达式

功能：SPACE 伪指令用于分配一片连续的存储区域并初始化为 0。
注意：表达式在分配的字节数。
      SPACE也可以用 “%” 代替。
例如：
	datetest SPACE 256 ;分配连续256个字节的存储单元
                       ;并初始化为 0
___________________________________________________________
% 首在址定义伪指令
格式：MAP 表达式{，基地址寄存器}

功能：MAP伪指令用于定义一个结构的内存表的首地址
      MAP也可以用 “^”代替
注意：表达式可以为程序中的标号或数学表达式，
      基地址寄存器为可选项
      当基地址寄存器不存在时表达式的值即为内存表的首地址
      当该项存在时，内存表的首地址为表达式的值与基址寄存器的和
      MAP伪指令通常与FIELD伪指令配合使用来定义结构化的内存表。
例如：
	MAP 0x100, R0 ;定义结构化内存表首地址为
                  ;0x100+R0
___________________________________________________________
% 数据定义伪指令 FIELD
格式：标号 表达式

功能：用于定义结构化内存表中数据的域，
      也可以用 “#”代替
      值为当前数据域在内存表中所占的字节数
注意：该常与 MAP伪指令配合使用定义结构化的内存表
      MAP伪指令定义内存表的首地址，
      FIELD伪指令定义内存表中的各个数据域，
      并可以为每一个数据域指定一个标号供其它的指令引用
      此外两个伪指令仅定义数据结构，并不实际分配存储单元。
例如：
MAP 0x100  ;定义结构化内存表的首地址0x100
A FIELD 8  ;定义A长度为8字节，位置为0x100
B FIELD 16 ;定义B长度为16字节，位置为0x108
C FIELD 32 ;定义C长度为32字节，位置为0x118



### ======================================================== 符号定义伪指令
___________________________________________________________
% 全局变量定义伪指令
格式：GBLA GBLL GBLS 全局变量名

功能：GBLA伪指令用于定义一个全局数字变量，初始化为 0
      GBLL伪指令用于定义一个全局逻辑变量，初始化为 FALSE（假）
      GBLS伪指令用于定义一个全局的字符串变量，初始化为 空
注意：由于这三条伪指令用于定义全局变量，因此整个程序范围内变量名必须唯一。
例如：
	GBLA Test1          ;定义一个全局数字变量，名为Test1
	GBLL Test2          ;定义一个全局逻辑变量，名为Test2
	GBLS Test3          ;定义一个全局字符串变量，名为Test3
	
___________________________________________________________
% 局部变量定义伪指令 LCLA,LCll,LCLS
格式：LCLA(LCLL,LCLS) 局部变量名


___________________________________________________________
% 变量赋值伪指令 SETA,SETL,SETS
例如：
	LCLA test7		    ;声明一个局部数字变量，变量名为test7
	test7 SETA 0x1234	;将该变量赋值为0x1234
	LCLL test8		    ;声明一个局部逻辑变量，变量名为test8
	test8 SETL {TRUE}	;将变量赋值为真

___________________________________________________________
% 寄存器列表定义伪指令 RLIST
格式：名称 RLIST {寄存器列表}

功能：RLIST 伪指令可用于对一个通用寄存器列表定义名称，
      使用该伪指令定义的名称可以在ARM指令 LDM/STM中使用
注意：在LDM/STM指令中，列表中的寄存器访问次序为根据
      寄存器的编号由低到高，而与列表寄存器排列无关。
例如：
RegList RLIST {R0-R5,R8,R10} ;将寄存器列表名称定义为RegList，
                             ;可以在ARM指令LDM/STM中通过该名称访问寄存器列表



### ======================================================== 汇编结构伪指令
___________________________________________________________
% 段定义伪指令 AREA
格式：AREA 段名 属性1, 属性2, ......

ARM中只有两种段：代码段和数据段

功能：AREA伪指令用于定义一个代码段或数据段，
      其中，段名若以数字开头，则该段名需要用 “|“括起来
      例如：|1_test|
注意：一个汇编程序至少包含一个段，
     当程序太长时，也可以将程序分为多个代码段或数据段。

属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。

CODE 属性：        用于定义代码段，默认为 READONLY
DATA 属性：        用于定义数据段，默认为 READWRITE
READONLY 属性：    指定本段为只读，代码段默认为 READONLY
READWRITE 属性：   指定本段可读可写，义数据段默认为 READWRITE
ALIGN 属性：       使用方式为 ALIGN表达式。
                   在默认时，ELF(可执行连接文件）的代码段和数据段是按字对齐的。
                   表达式的取值范围为 0～31 ，相应的对齐方式为 2表达式次方。
COMMON 属性：      该属性定义一个通用的段，不包含任何的用户代码和数据。
                   各源文件中同名的 COMMON段共享同一段存储单元。

___________________________________________________________
% ALIGN 伪指令
格式：ALIGN {表达式{，偏移量}}

功能：ALIGN伪指令可以通过添加填充字节的方式，使当前位置满足一定的对齐方式。
      其中，表达式的值用于指定对齐方式，可能取值为 2 的幂，如1,2,4,8,16等。
      若未指定表达式，则将当前位置对齐到下一个字的位置。
      偏移量也为一个表达式，若使用该字段，则当前位置的对齐方式为：
            2 的表达式次幂 + 偏移量。
例如：
	AREA Init, CODE, READONLY, ALIGN=3
   ;ALIGN=3，指定后面的指令为 8 字节对齐方式。
   
___________________________________________________________
% CODE16,CODE32状态切换伪指令

___________________________________________________________
% 程序入口伪指令 ENTRY
格式：ENTRY

功能：ENTRY 伪指令用于指定汇编程序的入口点。
注意：在一个完整的汇编程序中至少要有一个 ENTRY,
      当有多个 ENTRY时，程序的真正入口点由链接器指定。
      但在一个源文件中最多只能有一个ENTRY,也可以没有。
例如：
	AREA Init, CODE, READONLY
	ENTRY	;指定程序的入口点
___________________________________________________________
% 程序结束伪指令 END
格式：END

功能：END用于通知编译器已经到了源程序的结尾。

___________________________________________________________
% 标号输出伪指令 EXPORT(或GLOBAL)
格式：EXPORT 标号 {[WEAK]}

功能：EXPORT伪指令用于在程序中声明一个全局的标号，
      该标号可以在其它文件中引用。
注意：EXPORT可以用GLOBAL代替，标号在程序中区分大小写。
      WEAK 选项，声明其它同名标号优先于该标号被引
例如：
AREA Init, CODE, READONLY
EXPORT Main0 ;声明一个全局引用的标号Main0
___________________________________________________________
% 标号输入伪指令 IMPORT
格式：IMPORT 标号 {[WEAK]}

功能：IMPORT伪指令用于通知编译器要使用的标号在其它源文件中的定义，
      但要在当前源文件中引用，且无论当前源文件是否引用该标号，
      该标号均会被加入到当前源文件的符号表中。
注意：标号在程序中区分大小写，
      WEAK 选项，表示当所有的源文件都没有定义这样一个标号时，
      编译器也不会给出错误信息。
在多数情况下将该标号置为0,若该标号为 B或BL指令引用，
则将B或BL指令置为 NOP操作。

例如：
AREA Init, CODE, READONLY
IMPORT Main1 ;通知编译器当前文件在引用标号Main1,
             ;但Main1在其它源文件中定义。
___________________________________________________________
% 标号引入伪指令 EXTERN
格式：EXTERN 标号 {[WEAK]} 

功能：EXTERN伪指令用于通知编译器在使用的标号在其它的源文件中定义，
      但要在当前源文件中引用，
      与IMPORT 不同的是
      如果当前源文件实际并未引用该标号，
      该标号就不会加入到当前源文件的符号表中。
      
___________________________________________________________
% 源文件包含伪指令 GET(或INCLUDE)
格式：GET 文件名

功能：GET伪指令用于将一个源文件包含到当前的源文件中，
      并将被包含的源文件在当前位置时行汇编处理，
      可以使用INCLUDE代替GET。
GET file1.s             ;通知编译器当前源文件包含文件file1.s
GET /tmp/file2.s        ;通知编译器当前源文件包含文件/tmp/file2.s

___________________________________________________________
% 目标文件包含伪指令 INCBIN
格式：INCBIN 文件名

功能：INCBIN伪指令用于将一个目标文件或数据文件包含到当前的源文件中，
被包含的文件不作任何变动的存放在当前文件中，编译器从其后开始继续处理。

INCBIN file a1.dat      ;通知编译器当前源文件包含文件a1.dat
INCBIN /tmp/file a1.txt ;通知编译器当前源文件包含文件a1.txt




### ======================================================== 汇编控制伪指令
___________________________________________________________
% 1.1 条件控制伪指令 IF, ELSE, ENDIF
格式：
IF 逻辑表达式
	指令序列1
ELSE 
	指令序列2
ENDIF

功能：该指令能根据条件的成立与否决定是否执行某个指令序列。
      当IF后面的逻辑表达式为真，
      则执行指令序列1,
      否则执行指令序列2
___________________________________________________________
% 1.2 循环控制伪指令 WHILE, WEND
格式：
WHILE 逻辑表达式
	指令序列
WEND
功能：该组伪指令能根据条件的成立与否决定是否循环执行某个指序列。
      当WHILE后面的逻辑表达式为真，则执行指令序列，
      该指令序列执行完毕后，再判断逻辑表达式的值，
      若为真则继续执行，一直到逻辑表达式的值为假。
___________________________________________________________
% 1.3 宏定义伪指令 MACRO, MEND 
格式：
MACRO 
	$标号 宏名 $参数1, $参数2, ...
	指令序列
MEND

功能：MACRO，MEND,伪指令可以将一段代码定义为一个整体，称为宏。
      然后可以通过宏指令多次调用该段代码。
注意：$标号在宏指令展开时，标号会替换为用户定义的符号。
      宏指令可以使使用一个或多个参数，
      当宏指令被展开时，这些参数被相应的值替换。
说明：宏指令的使用方式和功能与子程序有些相似，
      子程序可以提供模块化的程序设计，节省存储空间并提高运行速度。
      但在使用子程序结构时需要保护现场，从而增加了系统的开销。
      因此，在代码较短 且需要传递参数较多时，可以使用宏指令代替子程序。

包含在MACRO和MEND 之间的指令序列称为宏定义体。
在宏定义体的第一行应该声明宏的原型（包含宏名，所需的参数），
然后就可以在汇编程序中通过宏名来调用该指令序列。
___________________________________________________________
% 1.4 宏退出伪指令 MEXIT
格式：MEXIT
功能：MEXIT用于从宏定义中退出去。



### ======================================================== 其它常用伪指令

___________________________________________________________
1.等效定义伪指令 EQU
格式：名称 EQU 表达式{，类型}
功能：EQU伪指令用于为程序中的常量，标号等定义一个等效的字符名称。
      类似于C语言中的 #define .
      其中EQU可以用”*“代替。
注意：名称EQU伪指令定义的字符名称，
      当表达式为 32位常量时，可指定表达式的数据类型，
       以下有 3 种数据类型：
       CODE16, CODE32,DATA.
例如：
Test EQU 10		;定义标号Test的值为10
addr EQU 0xff,CODE32    ;定义Addr的值为0xff，且
                        ;该处为32位的ARM指令。
___________________________________________________________
2 别名定义伪指令 RN
格式：名称 RN 表达式
功能：RN 伪指令用于给一个寄存器定义一个别名。
注意：采用这种方式可以方便程序员记忆寄存器的功能。
      其中，名称为给寄存器定义的别名，
      表达式为寄存器的编码。
例如：
Temp RN R0
;将R0定义一个别名为Temp.
___________________________________________________________
ROUT伪指令
格式：{名称} ROUT
功能：用于给一个局部变量定义作用范围。
注意：在程序中未使用该伪指令时，
      局部变量的作用范围为所在的AREA,
      而使用ROUT伪指令后，
      局部变量的作用范围为当前 ROUT和下一个ROUT 之间。












