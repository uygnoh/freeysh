### =============================================================== AAPCS
% ARM的开发环境实际上就是嵌入了一个C语言的集成开发环境，
% 只不过这个嵌入式C语言开发环境和ARM的硬件紧密相关。

在使用C语言时，有时要用到和汇编语言的混合编程。
当汇编代码较为简洁，可使用直接内嵌汇编的方法。

通常需要将汇编程序以文件的形式加入项目当中，
并通过 ARM体系结构程序调用标准：
% (Procedure Call Standard for the ARM Architecture, 简称:AAPCS)
的规定与 C程序相互调用与访问。

AAPCS是ARM架构下应用程序例程调用的二进制接口规范，
其前身为著名的ATPCS(ARM/Thumb Procedure Call Standard)标准。

这个规范的目的是使不同程序模块可以分别编译，
在二进制代码层面上直接配合使用。



### ============================================================= AAPCS规则
为了使单独编译的 C语言程序和汇编程序之间能够相互调用，
必须为子程序之间的调用规定一定的规则。            
基本的AAPCS规定了在子程序调用的一些基本规则，包括下面3个方面：
寄存器的使用规则及其相应名称，数据栈的使用规则，参数传递的规则
___________________________________________________________
% 寄存器的使用规则及其相应名称

1 R0~R3(相当于全局变量)
子程序通过寄存器 R0~R3来传递参数，这时寄存器R0~R3可以记作A1-A4
被调用的子程序在返回前无需恢复寄存器R0~R3的内容。
—————————————————————————————————————————————————
2 R4~R11(相当于局部变量)
在子程序中，使用寄存器R4~R11来保存局部变量。
这时寄存器R4~R11可以记作V1-V8
—————————————————————————————————————————————————
3 R12
寄存器R12用作过程调用时的临时寄存器
(用于保存SP, 在函数返回时使用该寄存器出栈)，记作IP。
—————————————————————————————————————————————————
4 R13
寄存器R13用作数据栈指针，记作SP.
在子程序中寄存器R13 不能用作其它用途。
—————————————————————————————————————————————————
5 R14
寄存器R14称为连接寄存器，记作LR。
它用于保存子程序的返回地址。
—————————————————————————————————————————————————
6 R15
寄存器R15是程序计数器，记作PC



___________________________________________________________
% 数据栈的使用规则。

AAPCS规定堆栈为FD类型，即满递减堆栈，并且堆栈的操作是 8 字节对齐。
而对于汇编程序来说，如果目标文件包含了名部调用，
则必须满足以下条件：
1 外部接口的数据栈一定是 8位对齐的，也就是保证在进入该汇编代码后，
  直到该汇编程序调用外部代码之间，数据栈的栈指针变化为偶数个字。
2 在汇编程序中使用 PRESERVE8伪指令操作告连接器，本汇编程序是8字节对齐的。
	  
	  
___________________________________________________________
% 参数传递的规则

对于参数个数可变的子程序，
当参数不超过4个时，可以使用寄存器 R0~R3来进行参数传递，
当参数超过4个时，还可以使数据栈来传递参数。

在参数传递时，将所有参数看做是存放在连续的内存单元中的字数据。
然后，依次将各字数据传送到寄存器R0,R1,R2,R3中，
如果参数个数多于4个，将剩余的字数据传送到数据栈中。

入栈的顺序与参数顺序相反，即最后一个字数据先入栈。

___________________________________________________________
% 4 数据栈限制检查

如果在程序设计期间能够准确在计算出所需的内存总量，
就不需要进行数据栈的检查，但是通常情况下这是很难做到的，
这时需要进行数据栈的检查。

在进行数据栈的检查时，使用寄器R10作为数据栈限制指针，
这时R10又记作SL,用户在程序中有能控制该寄存器。

在已经占有栈的最低地址和SL之间必须有256字节的空间。
也就是说，SL所指的内存地址必须比已经占用的栈的最低地址低256个字节。

当中断处理程序使用用户的数据栈时，在已经占用的栈的最低地址和SL之间
除了必须保留的256个字节的内存单元外，还必须为中断处理预留足够的内存空间。

用户在程序中不能修改SL的值，数据栈栈指针SP的值必须不小于SL的值。


### ===============================================嵌入式C语言的数据存储方法
% 嵌入式C语言的数据存储方法

嵌入式C语言是被编译器先翻译成汇编指令集，
然后再将指令集转换为二进制指令代码，
这些二进制代码与微处理器指令长度是一致的。

微处理器的存储空间有 Flash ROM和RAM之分，
一般会将常量，常数等存在Flash ROM中，不常被修改。
而把变量，函数，堆栈等都存放在RAM中，以方便在运行时改变。

寄存器是微处理器中被频繁使用的存储空间，常用来存放做计算的操作数，
因此一个程序被编译成二进制后，分别保存在不同的地方。


RAM 
—————————————————————————————————————————————————
零初始化数据
初始化数据
堆栈
堆数据

Falsh ROM
—————————————————————————————————————————————————
常量数据
初始化数据
开始和运行库代码
program.txt


### ============================================== 嵌入式C语言编写注意事项
5 嵌入式C语言编写注意事项

数据 类型尽量考虑整形
计算符号多加减，少乘，不除
尽量采用移位运算代替乘除法

变量尽量用局部变量，少用全局变量。
全局变量全部存放在静态存储区，
在程序开始执行时给全局变量分配存储区，程序执行完毕才释放。
全局变量存在于RAM中，而局部变量存在于堆栈中。
如果定义的全局变量太多就有可能导致溢出。

注意变量名字的空间污染。

子程序的嵌套越少越好。
在子程序运行时，当调用下一个子程序时
就需要开辟一个堆栈空间，直到执行到return语句。
才会把这个堆栈去掉。

循环体多用 do-while 少用 for， while
从编译的代码可以看出，do-while 循环中需要一个空间存放退出地址。
相对而言，do-while 循环所需的额外开销最少。


### =============================================C语言与汇编语混合编程的方法

________________________________________________________________________________
% 在C语言中内嵌汇编指令

1  不能直接向 PC寄存器赋值，程序跳转只能使用 B或BL 指令实现。
—————————————————————————————————————————————————
2  在使用物理寄存器时，不要使用过于复杂的C表达式，以避免物理寄存器冲突。
—————————————————————————————————————————————————
3  R12和R13可能被编译器用来存放中间编译结果，计算表达式值时可能将R0-R3,
   R12,R14用于子程序调用，因此要避免直接使用这些物理寄存器。
—————————————————————————————————————————————————
4  一般不要直接指定物理寄存器，而让编译器进行分配。
—————————————————————————————————————————————————
__asm
}
	instruction [;instruction]
	...
	[instruction]
}


________________________________________________________________________________
% 在汇编中使用C定义的全局变量

内嵌汇编不用单独编辑汇编语言文件，比较简洁，
但是有诸多限制，当汇编代码比较多时一般放在单独的汇编文件中。

这时就需要在汇编和 C之间进行一些数据的传递。
最简单的办法就是使用全局变量。

使用 IMPORT 伪指令引入全局变量，
并利用 LDR和STR指令根据全局变量的地址访问它们。

% 下面例子是一个汇编代码的函数，它读取全局变量 ABC,
% 其加2后写回。
AREA ABC, CODE, READONLY
	EXPORT asmsub
	IMPORT ABC
asmsub
	LDR R1, =ABC
	LDR R0, [R1]
	ADD R0, R0, #2
	STR R0, [R1]
	MOV PC, LR
END



________________________________________________________________________________
% 在C 程序中调用汇编程序

C 程序调用汇编程序时需要做到以下两步：
——————————————————————————————————————
1 在 C程序中使用 extern 关键字声明外部函数（声明要调用的汇编子程序），
 即可调用此汇编子程序。
——————————————————————————————————————
2 在汇编程序中使 EXPORT 伪指令声明本子程序，使其它程序可以调用此子程序。
  另外，汇编程序设置要遵循 AAPCS规则，保证程序调用时参数的正确传递。
——————————————————————————————————————
% 1 C程序如下：
#include <stdio.h>
extern void strcopy(char *d, const char *s);
int main(void)
{
	const char *srcstr ="First string-source";
	char *dststr ="Second string-destination";
	strcopy(dststr, srcstr);
	return 0;
}

% 2 汇编程序如下：
AREA SCopy, CODE, READONLY
ENTRY
EXPORT strcopy
strcopy
	LDRB R2, [R1], #1
	STRB R2, [R0], #1
	CMP R2, #0
	BNE strcopy
	MOV PC, LR
END


________________________________________________________________________________
% 在汇编程序中调用 C程序

汇编程序的设置要遵循AAPCS规则，即前4个参数通过R0-R3传递，
后面的参数通过堆栈传递，保证程序调用时参数的正确传递。

在汇编程序中使用IMPORT伪指令声明将在调用的C程序函数。
在调用C程序时，要正确设置入口参数，然后使用BL调用。

1 汇编程序调用C程序的C函数代码如下：
int cFun(int a, int b, int c)
{
    return (a+b+c);
}
2 汇编程序调用C程序的汇编程序代码如下；
AREA asmfile, CODE, READONLY
IMPORT cFun
ENTRY
    MOV R0, #11
    MOV R1, #22
    MOV R2, #33
    BL cFun
END




### ============================================= 嵌入式C语言一些常用的用法
___________________________________________________________
% Define是C语言中的预处理指令，用于宏定义。
#define 标示符 字符串


___________________________________________________________
% ifdef条件编译
#ifdef 标识符
    程序段1
#else
    程序段2
#endif

___________________________________________________________
% 位运算操作

按位与             &
按位或             |
按位取反           ~
按位异或           ^
按位左移           <<
按位右移           >>


___________________________________________________________
% extern变量申明

C语言中，extern可以放在变量或函数之前，以表示该变量或函数的定义在别的文件中，
提示编译器在其它模块中寻找其定义。

通过extern申明变量可以有多次，但是该变量的定义只能有一次。
该申明的变量事实上就是全局变量。
例如：
extern u16 USART_RX_STA;    //申明的USART_RX_STA民在其它文件中定义


___________________________________________________________
% typedef 类型别名

typedef struct {
    __IO uint32_t MOD;
    __IO uint32_t OTY;
    ...
} GPIO_TypeDef;
//GPIO_TypeDefo 为该结构体的别名


___________________________________________________________
% 结构体

结构体是一种工具，用这个工具可以定义自己的数据类型。

与数组相比，结构体中各个元素 的数据类型可以不同。

在嵌入式系统开发中，结构体可以将多个变量组合为一个有机的整体，
例如串口定义为一个结构体。

这样在需要调整入口参数时， 可以直接通过修改结构体成员变量来完成，
而不需要采用传统的修改函数定义的方法。

struct 结构体名
{
    类型名1 成员名1;
    类型名1 成员名1;
    ...
    类型名n 成员名n;
};




