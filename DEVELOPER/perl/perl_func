### =============================================================== chop, chomp
指令：chop 语法：chop($url)
说明：把最后一个字符删除。
示例：     
$url="www.nease.net/~zmd/";
chop($url); 
这时$url="www.nease.net/~zmd"
而这两行也可以写成chop($url="www.nease.net/~zmd/");

% chop; 是用来删除最后一个字符, chomp; 是用来删除换行符



### ====================================================================== print
语法：print Filehandle LIST
说明：这个Filehandle可以看作在I(INPUT)/O(OUTPUT)之间的一个桥梁,
    可以利用FILEHANDLE来做出数据读入写 出的动作.
    STDIN是代表从哪连输入数据,例如从电脑的键盘输入;
    STDOUT是代表从哪连输出数据;例如从电脑的屏 幕输出;
    STDERR是代表从哪连输出错误的数据,例如从电脑的屏幕输出.
    而在PERL语言中有三个标准FILEHANDLE： 
    1.STDIN(标准输入)：是代表STDIN的FILEHANDLE
    2.STDOUT(标准输出)：是代表STDOUT的FILEHANDLE
    3.STDERR(标准错误输出)：是代表STDERR的FILEHANDLE如果要使用其他FILEHANDLE的时候,
    就要用OPEN这个函数来打开一个FILEHANDLE,我们可以用PRINT这个函数LIST的数据输出给FILEHANDLE.
% 在为大家介绍PRINT这个函数之前,先让我们来看看PRINT函数中特殊打印字符： 
    符号     其作用
    \n      换行 new line
    \r      光标换行 return
    \t      tab键
    \f      换页 form feed
    \b      退回一格
    \v      垂直tab键
    \a      响铃Bell
    \e      escape键
    \007    十进制ASC II码
    \xff    十六进制码
    \c[     控制字符



### ====================================================================== split
语法：split(/pattern/,$text,limit) 其中/pattern/是文字处理的模式， 
     而limit是代表要分割的个数，一般可以省略。
说明：用一个指定的文字处理模式来分割$text字符串。
示例：
$text="Michael,Gevin,Mike"; 
@name=split(/,/,$text);         #这时@name=("Michael","Gevin","Mike");
($a,$b,$c)=split(/,/,$text);    #这时$a="Michael";$b="Gevin";$c="Mike";
@name=split(/,/,$string,2);     #这时@name=("Michael","Gevin");
在传送CGI应用程序数据的时候会先将数据编码，
其中会将FORM中第个数据字段 的数据内容用&这个符号隔开，
所以在解码的时候就要以&这个符号为分割的字符，将每个数据字段分割出。

例如： 1 
$text="Mike=A&Michael=B";
@name=split(/&/,$text); 
#这时@name=("Mike=A","Michael=B"); 
而数据字段的名称和这个数据字段的值是用=这个符号来隔开，
如果想取得数据 字段的名称和所对应的值的话，就用要=这个符号来分割数据字段，

例如： 2
$name=""Mike=Michael""；
($name1,$name2)=split(/=/,$list); 
#这时$name1="Mike";$name2="Michael"; 




### ====================================================================== keys
语法：keys(%array)
说明：取出关联数组%ARRAY中全部的key。

示例：
%NAME=(1,"mike",2,"michael"); 
@readkey=keys(%NAMES); 
#这时@readkey=(1,2); 


### ===================================================================== values
语法：values(%array)
说明：取出关联数组%ARRAY中全部的value。

示例：
%NAMES=(1,"mike",2,"michael"); 
@readval=values(%NAMES); 
#这时@readval=("mike","michael"); 


### ==================================================================== reverse
语法：reverse(@array)
说明：将数组@array中的元素由后到前重新排列。

示例：
@back=("A","B","C","D","E"); 
@back=reverse(@back); 
#这时@back=("E","D","C","B","A"); 


### ======================================================================= sort
语法：sort(@array)
说明：将数组中的元素由小到大排序，如果要由大到小排序的话，要加上reverse这个函数。

示例：
@abc=("d","b","c","a"); 
@abc=sort(@abc); 
#这时@abc=("a","b","c","d");

@abc=(reverse sort@abc); 
#这时@abc=("d","c","b","a"); 
这个语法也可以写成@abc=(reverse sort(@abc));

@number=(5,2,10); 
@number=sort(@number); 
上面示例用sort函数来排序数值的时，会出差错，因此要用下面到下面这一句。 
@number=(sort{$a<=>$b}@number);
#这时@number=(2,5,10);



### ===================================================================== length
语法：length($string)
说明：求出字符串$string的字节(bytes)值。
示例：$string="Perl5"; $size=length($string); #这时$size=5; 




### ==================================================================== substr
语法：substr($string,offset,length)    #offset代表起始字符的位置,
    length代表引用的字符串长度，如果省略length则代表从起始值到字符串的最后一个字符长度。   
    而offset如果是负值的话，就会从字符串右边开始指定字符。
    
示例：
$s=substr("perl5",2,2);  #这时$s="rl";
$s=substr("perl5",2);    #这时$s="rl5";
$s=substr("perl5",-2,2); #这时$s="er"; 





### ====================================================================== index
语法：index($string,$substring,position) 
    $substring  ;是要寻找的字符；
    position    ;代表从哪一个位置开始寻找，假如省略position就从头开始找起。
说明：返回所要找寻的字符在一字符串$string中的位置，
    如果在字符串中找不到字符的话，则会返回-1这个 值。
    
示例：
$s=index("perl5","p");      #这时$s=0
$s=index("perl5","l",2);    #这时$s=3
$s=index("perl5","perl");   #这时$s=-1 




### ======================================================================= push
语法：push(@array,$string)
说明：在数组@array的最后附加新的元素 ($string)到数组@array中。
示例：@array=("one","two"); push(@array,"three"); 
    #这时$@array=("one","two","three")
### ======================================================================== pop
语法：pop(@array)
说明：将数组(@array)的最后一个元素删除，并将删除的元素返回。
示例：@array=("one","two"); $rm=pop(@array); 
    #这时@array=("one");而$rm="two";




### ==================================================================== unshift
语法：unshift(@array,$string) 
说明：在数组@array的第一个元素前附加新的元素$string到数组@array中。 

示例： 
@array=("one","two"); 
unshift(@array,"three"); 
#这时@array=("three","one","two")
### ====================================================================== shift
语法：shift(@array)
说明：将数组@array的第一个元素删除，并将删除的元素返回。
示例：
@array=("one","two"); 
@rm=shift(@array);  
#这时@array=("two");而$rm="one";
    
    

### ====================================================================== join
语法：join($string,@array)
说明：在一数组@array的元素之间加上一指定的字符$string,并将结果返回。
示例：
@array=("one","two","three");
$total=join("：",@array); 这时$total="one：two：three";



### ======================================================================= grep
语法：grep(/pattern/,@array)
说明：将合文字处理模式(regular expression)的数组元素找出来。

示例：
@array=("one","on","in");
$count=grep(/on/,@array); #这时$count=2
@result=grep(/on/,@array);#这时@result=("one","on");



### ======================================================================== hex
语法：hex($string)
说明：将十六进制的数值转成十进制。
示例： 
$decimal=hex("ff"); 
这时$decimal=255;



### ======================================================================= rand
语法：rand($interger)
说明：常和函数srand搭配来取得一随机数，如果没有先宣告stand函数的话，
    则取出的常数值是一个固定值。这个语法会返回一个介于0和$interger之间的数值，
    如果$interger省略的话，则会返回一个介于0和1 的数值。
    
示例：
srand;              #要先宣告srand函数，才能产生随机数的效果
$int=rand(10);      #$int的值会大于0而且小于10如果希望产生的乱数是整数的话,就要再加上int #这个函数
$int=int(rand(10)); #$int的值是一个整数，且值在0和9之间 




### ================================================================== localtime
语法：localtime(time)
说明：可返回九个有关时间的元素，在写CGI应用程序的时候常会用到系统的时间，
所以在此会详细介绍这个函 数的用法。
示例：
($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
其中： 
$sec    代表秒数[0,59] 
$min    代表分数[0,59] 
$hour   代表小时数[0,23] 
$mday   代表是在这个月的第几天[1,31] 
$mon    代表月数[0,11],要将$mon加1之后，才能符合实际情况。
$year   从1990年算起的年数 
$wday   从星期六算起，代表是在这周中的第几天[0-6] 
$yday   从一月一日算起，代表是在这年中的第几天[0,365] 
$isdst  只是一个flag 知道这些变量之后，就可以在CGI应用程序中拿来应用了。
此外，也可以用下面这一行指令在UNIX系统下取得系统的时间。
为了避免错误发生，最好用绝对路径的方法来取得系统时间，
如果绝对路径不清楚的话可以用"which data"这个指令来得知。
最后要提字符的话，就不能正确执行系统的程序了。 
$data='/usr/bin/data'; 而在perl5版本中，也可以用下面这一行指令来取得系统时间。 
$data=localtime(time); 



### ======================================================================== die
语法：die LIST
说明：会把LIST字符串显示出来，并退出程序。常常和$!这个代表错误信息变量一起使用。
示例：open(FILE,"$filename")||die "不能打开文件$!\n; 
    如果打开文件失败的话，就会显示出错误的信息，之后再退出程序。




### ======================================================================= open
语法1：open(filehandle,"$filename") 其中$filename是一个指定打开的文件名。
说明：这是一个很常用的函数，可用于文件的打开(read only)。
在CGI程序设计中常常会打开一个文件来读取数据，所以笔者会详加说明这一个函数相关用法。
这个filehandle可把它看作在I(INPUT)/O(OUTPUT)之间的一个桥梁，
可以利用FILEHANDLE来作出数据读 入写出的动作。
开始可用OPEN这个函数来打开一个指定的文件，
接下来可以用&ltfilehandle>来读取所打开文件的数据内容，
最后一定要用close这个函数来关闭这个之前打开的filehandle。
要注意的是在CGI程序定作中，当用OPEN这个函数来打开一个文件时，
一定要在打开文件前加上文件所在的绝对路径名称。
示例：
$filename="usr/abc.txt";
open(FILE,"$filename")||die"不能打开文件$filename\n; #将&ltfile>数据指定给纯变量$line(一行一行地)
while($line=&ltfile>) {
    print"$line";
}
close(file); 就会把abc.txt这个文件的内容显示出来。




语法2：open(filehandle,"<$filename")
说明：这个语法也可以打开一个存在的文件(read only)。
示例：
$filesname="usr/abc.txt";
open(file,"<$filename")||die"不能打开文件$filename\n";
@array=&ltfile>     #将&ltfile>全部的数据内容都指定给数组@array close(file);
print "@array";     #也会把abc.TXT这个文件的内容显示出来。



语法3：open(filehandle,">$filename")
说明：建立一个新的文件(write only),如果已经存在这个文件了，就会把旧文件名覆盖掉。
并可用print filehandle的方式将数据到所打开的文件中。
示例：
$filename="/usr/abc.txt";
open(file,">$filename")||die"不能打开文件$filename\n;
print file "this is a new line1\n; #\n是换行字符
print file "this is a new line2\n;
close(file); 会打数据存在一个新文件中。


语法4：open(filehandle,">>$filename")
说明：数据用附加的方式定入一文件(write only)，
如果指定的文件名不存在的话就会建立一个新的文件。
示例：
$filename="/path/abc.txt";
open(file,">>$filename")||die"不能打开文件$filename\n";
print file "this is a new line1\n";
print file "this is a new line2\n";
close(file);
会打数据附加(append)到一个文件(abc.txt)中。



语法5：open(filehandle,"|unix command")
说明：就会把在filehandle的数据输入给unix的指令来作处理。
示例：
$mailprog="/usr/ucb/mail"; #unix系统上的寄信程序(一定要加绝对路径)
$who="mqingyi@126.com";
$open(file,"|$mailprog$who")||die"打开失败\n";
print file "I love you!\n";
print file "I want to see you.\n";
close(file);
就会通过unix系统mail的程序，将FILE这个FILEHANDLE的数据内容寄给$who这个变量所指定的收信人。 
我们可以利用open这个函数来设计一个来信批评CGI应用程序，在本书中的下一章中会有详细的介绍。 

### =================================================================== sysopen
% sysopen 函数类似于 open 函数，只是它们的参数形式不一样。
% 以下实例是以读写(+<filename)的方式打开文件：
sysopen(DATA, "file.txt", O_RDWR);

%如果需要在更新文件前清空文件，则写法如下：
sysopen(DATA, "file.txt", O_RDWR|O_TRUNC );

% 你可以使用 O_CREAT 来创建一个新的文件， O_WRONLY 为只写模式， O_RDONLY 为只读模式。
% The PERMS 参数为八进制属性值，表示文件创建后的权限，默认为 0x666。
% 下表列出了可能的模式值：
模式	        描述
O_RDWR	    读写方式打开，将文件指针指向文件头。
O_RDONLY	只读方式打开，将文件指针指向文件头。
O_WRONLY	写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。
O_CREAT	    创建文件
O_APPEND	追加文件
O_TRUNC	    将文件大小截为零
O_EXCL 	    如果使用O_CREAT时文件存在,就返回错误信息,它可以测试文件是否存在
O_NONBLOCK	非阻塞I/O使我们的操作要么成功，要么立即返回错误，不被阻塞。 
### =================================================================== 读写文件
% 向文件读写信息有以下几种不同的方式：
<FILEHANDL> 操作符
从打开的文件句柄读取信息的主要方法是 <FILEHANDLE> 操作符。
在标量上下文中，它从文件句柄返回单一行。例如：

ysh@localhost:PERL$ cat t.pl 
#!/bin/perl
#
print "baidu: http?\n";
$name = <STDIN>;
print "baidu: $name\n";
以上程序执行后，会显示以下信息，我们输入网址后 print 语句就会输出：
ysh@localhost:PERL$ perl t.pl
baidu: http?
www.baidu.com
baidu: www.baidu.com


当我们使用 <FILEHANDLE> 操作符时，它会返回文件句柄中每一行的列表，
例如我们可以导入所有的行到数组中。
% 实现创建 import.txt 文件，内容如下：
ysh@localhost:PERL$ cat improt.txt 
blue 
red 
gray
% 读取 import.txt 并将每一行放到 @lines 数组中：
% 实例
#!/usr/bin/perl
 
open(DATA,"<import.txt") or die "Unable to open data";
@lines = <DATA>;
print @lines; 
close(DATA);
% 执行以上程序，输出结果为：
ysh@localhost:PERL$ perl t.pl 
blue 
red 
gray



### ====================================================================== read
read 函数用于从缓冲区的文件句柄读取信息。
这个函数用于从文件读取二进制数据。

read FILEHANDLE, SCALAR, LENGTH, OFFSET
read FILEHANDLE, SCALAR, LENGTH
参数说明:
    FILEHANDLE  文件句柄，用于存放一个文件唯一标识符。
    SCALAR      存贮结果，如果没有指定OFFSET，数据将放在SCALAR的开头。
                否则数据放在SCALAR中的OFFSET字节之后。
    LENGTH      读取的内容长度。
    OFFSET      偏移量。
如果读取成功返回读取的字节数，如果在文件结尾返回 0，如果发生错误返回 undef。 








### =============================================================== tell, seek

tell 函数用于获取文件位置：
tell FILEHANDLE
如果指定 FILEHANDLE 该函数返回文件指针的位置，以字节计。如果没有指定则返回默认选取的文件句柄。



seek 函数
seek()函数是通过文件句柄来移动文件读写指针的方式来读取或写入文件的，以字节为单位进行读取和写入：
seek FILEHANDLE, POSITION, WHENCE

参数说明:
    FILEHANDLE：文件句柄，用于存放一个文件唯一标识符。
    POSITION：表示文件句柄(读写位置指针)要移动的字节数。
    WHENCE：表示文件句柄(读写位置指针)开始移动时的起始位置，
    可以取的值为0、1、2；分别表示文件开头、当前位置和文件尾。

以下实例为从文件开头读取 256 个字节：

seek DATA, 256, 0;



### ===================================================================== close
用法：close(filehandle)
说明：用open这个函数来打开一个filehandle之后，一定要用close批这个函数把所打开的filehandle关闭。
示例：
open(filehandle,"$filename");
close(filehandle);

指令：pack
语法：pack("指定的格式",list)
说明：pack这个函数会将一个list变成所指定的二进制数据格式。
在CGI程序分割解码过程中，会用到pack这 个函数,所以笔者在此简单介绍这个函数的用法。
示例：$string=pack("c",65); 
#这时$string="a";将65这个ascii码转换成一个unsigned字符，
#其中c就是指定要转换成unsigned字符的意思。

### ===============================================================指令：read
语法：read(filehandle,$string,length) 其中length是代表读入字符串的长度(bytes)。
说明：用read这个函数把filehandle中的数据依指定的字符串长度读入之后指派给$string这个变量。
在cgi程序分割解码过程中，如果FORM的传送方式是设定为POST的话，就会将传送的数据设定为标准输入，
所以会将数据内容指定给STDIN这个标准输入的filehandle，
而CGI环境变量$env{'content_length'}就是代 表使用者送出数据内容的长度，
因此我们要用read这个函数来取得使用者送出的数据内容。
示例：read(stdin,$buffer,$env{'content_length'}); 
就会将stdin这个标准输入filehandle中的数据依指定的字符串长度读入，再指派给$buffer这个变量。



### ===============================================================指令：exit
语法：exit
说明：退出执行的程序。
示例： print"i love cgi\n"; exit; 显示完"i love cgi"以后，将退出这个程序。





### =============================================================== Perl 错误处理
if 语句 可以判断语句的返回值，实例如下：

if(open(DATA, $file)){
   ...
}else{
   die "Error: 无法打开文件 - $!";
}

程序中变量 $! 返回了错误信息。 我们也可以将以上代码简化为如下代码：

open(DATA, $file) || die "Error: 无法打开文件 - $!";




unless 函数
unless 函数与 if 相反，只有在表达式返回 false 时才会执行，如下所示：

unless(chdir("/etc")){
   die "Error: 无法打开目录 - $!";
}

unless 语句在你要设置错误提醒时是非常有用的。我么也可以将以上代码简写为：

die "Error: 无法打开目录!: $!" unless(chdir("/etc"));
以上错误信息只有在目录切换错误的情况下才会输出。




三元运算符
以下是一个三元运算符的简单实例:

print(exists($hash{value}) ? '存在' : '不存在',"\n");

以上实例我们使用了三元运算符来判断哈希的值是否存在。
实例中包含了一个表达式两个值，格式为：表达式 ? 值一 : 值二。




warn 函数
warn 函数用于触发一个警告信息，不会有其他操作，输出到 STDERR(标准输出文件)，通常用于给用户提示：
chdir('/etc') or warn "无法切换目录";



die 函数
die 函数类似于 warn, 但它会执行退出。一般用作错误信息的输出：
chdir('/etc') or die "无法切换目录";



Carp 模块
在 Perl 脚本中，报告错误的常用方法是使用 warn() 或 die() 函数来报告或产生错误。
而对于 Carp 模块，它可以对产生的消息提供额外级别的控制，尤其是在模块内部。
标准 Carp 模块提供了 warn() 和 die() 函数的替代方法，它们在提供错误定位方面提供更多信息，
而且更加友好。当在模块中使用时，错误消息中包含模块名称和行号。



carp 函数
carp函数可以输出程序的跟踪信息，类似于 warn 函数，通常会将该信息发送到 STDERR：

package T;

require Exporter;
@ISA = qw/Exporter/;
@EXPORT = qw/function/;
use Carp;

sub function {
   carp "Error in module!";
}
1;

在脚本调用以下程序:

use T;
function();

执行以上程序，输出结果为：

Error in module! at test.pl line 4




cluck 函数
cluck() 与 warn() 类似，提供了从产生错误处的栈回溯追踪。
package T;

require Exporter;
@ISA = qw/Exporter/;
@EXPORT = qw/function/;
use Carp qw(cluck);

sub function {
   cluck "Error in module!";
}
1;




在脚本调用以下程序:
use T;
function();

执行以上程序，输出结果为：

Error in module! at T.pm line 9
    T::function() called at test.pl line 4




croak 函数
croak() 与 die() 一样，可以结束脚本。
package T;

require Exporter;
@ISA = qw/Exporter/;
@EXPORT = qw/function/;
use Carp;

sub function {
   croak "Error in module!";
}
1;

在脚本调用以下程序:

use T;
function();

执行以上程序，输出结果为：
Error in module! at test.pl line 4



confess 函数
confess() 与 die() 类似，但提供了从产生错误处的栈回溯追踪。

package T;

require Exporter;
@ISA = qw/Exporter/;
@EXPORT = qw/function/;
use Carp;

sub function {
   confess "Error in module!";
}
1;

在脚本调用以下程序:

use T;
function();

执行以上程序，输出结果为：

Error in module! at T.pm line 9
    T::function() called at test.pl line 4


