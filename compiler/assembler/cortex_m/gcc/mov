### 

% 使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，
% 并告诉GCC对这些操作有哪些限制条件。例如在下面的汇编语句：  
__asm__ __violate__  
("movl %1,%0" : "=r" (result) : "r" (input));  

“movl %1,%0”是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，内嵌汇编靠它们将C语言表达式与指令操作数相对应。

指令模板后面用小括号括起来的是C语言表达式，本例中只有两个：“result”和“input”，
他们按照出现的顺序分别与指令操作数“%0”，“%1，”对应；注意对应顺序：
第一个C表达式对应“%0”；第二个表达式对应“%1”，依次类推，操作数至多有10个，分别用“%0”，“%1”….“%9，”表示。

在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。

 
“result”前面的限制字符串是“=r”，其中“=”表示“result”是输出操作数，
“r”表示需要将“result”与某个通用寄存器相关联，先将操作数的值读入寄存器，
然后在指令中使用相应寄存器，而不是“result”本身，当然指令执行完后需要将寄存器中的值存入变量“result”，
从表面上看好像是指令直接对“result”进行操作，实际上GCC做了隐式处理，这样我们可以少写一些指令。

 

“input”前面的“r”表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。
