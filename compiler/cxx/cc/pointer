/* 
 * @freeysh
 */




###########################################################
### 指针
###########################################################


/* 指针数组， 这是一个数组， 它的每一个元素都是指针变量 */
#include<stdio.h>
int main(void)
{

	//int a[3][6] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18};
	int a[3][6] = {{1,2,3,4,5,6},{7,8,9,10,11,12},{13,14,15,16,17,18}};

	int i, j;
	int *p[3];

	for (i = 0; i < 3; i++) {
	    p[i] = a[i];
		for (j = 0; j < 6; j++) {
			printf("%d ",p[i][j]);
		}
		printf("\n");
	}

	printf("hello.world\n");

	return 0;

}



/* int (*p)[3]; */
/* 这是一个指针变量， 它指向一个一维数组 */
#include<stdio.h>
int main(void)
{
	
	int a[6][3] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18};
	int (*p)[3];
	
	p = a;
	int i,j;
	for (i=0;i<6;i++) {
		for (j=0;j<3;j++) {
			printf("%d,",p[i][j]);
		}
		printf("\n");
	}
	//printf("%d %d",&p[0][0],&p[0][1]);
	return 0;
}



/* 指针函数， 这是一个函数， 它的返回值类型为指针 */
int * funtion(in a, int b)



/* 函数指针， 这是一个指针， 它指向一个函数 */
int (* funtion)(int a, int b);



/* 二级指针， 它指向另一个指针 */
#include <stdio.h>

int main(void) {
	int i;
	char *name[3] = {"apple", "ucos", "stm32"};
	char **ptr = name;
	for (i = 0; i < 3; i++) {
		printf("%s\n", *(name+i));
		printf("%s\n", ptr[i]);
		printf("%s\n", *(ptr+i));
		printf("%c\n", *(*(ptr+1)+2));
	}
	return 0;
}






###########################################################
### 函数
###########################################################


返回值类型    函数名         参数列表
return_type function_name( parameter list )
{
   body of the function
}

/* 在 C 语言中，函数由一个函数头和一个函数主体组成 */
% 下面列出一个函数的所有组成部分：
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1 返回类型：一个函数可以返回一个值。
  return_type 是函数返回的值的数据类型。
  有些函数执行所需的操作而不返回值，
  在这种情况下，return_type 是关键字 void.

2 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。

3 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。
  参数列表包括函数参数的类型、顺序、数量。参数是可选的，
  也就是说，函数可能不包含参数。

4 函数主体：函数主体包含一组定义函数执行任务的语句。




/* 函数的调用
 * 当在一个函数运行期间调用另一个函数时，在运行被调用之前，
 */
系统需要完成3件事
        1.将所有的实际参数，返回地址等信息传递给被调用函数保存。
        2.为被调用函数的局部变量(包括形参)分配存储空间
        3.将控制转移到被调函数的入口

从被调函数返回主调函数之前，系统也要完成3件事
        1.保存被调函数的返回结果
        2.释放被调函数所占的内存空间
        3.依照被调函数保存的返回地址将控制转移到调用函数

当有多个函数相互调用时，按照"后调用先返回" 的原则，上述函数之间
信息传递和控制转移必须借助 "栈" 来实现。 即系统将整个程序运行时
所需的数据空间安排在一个栈中，每当调用一个函数时，就在栈顶分配
一个存储空间，进行压栈操作。 每当一个函数退出时，就释放它的存储
空间，就进行出栈操作，当前运行的函数永远都在栈顶的位置。


A函数调用A函数 和 A函数调用B函数在计算机看来是没有任何区别的，
只不过用我们日常的思维方式理解比较怪异而已！


/* 递归函数的定义 */
一个函数直接或间接调用自己




###########################################################
### 数组
###########################################################
/* 指针和一维数组之间的关系 */
    int a[5];
    a,数组名代表数组的首地址&a[0]

    &a[i] == (a+i)
    a+1不是加上1个字节,取决于a的基类型

    一维数组元素的等价引用形式
    a[i] ↔ *(a + i)
    用下标形式访问数组元素的本质


/* 指针与一维数组间的关系的关键 */
牢记a[i] ↔ *(a+i)
一维数组和指针做函数形参是等同的
数组和指针并非在所有情况下都是等同的
sizeof(数组名)和sizeof(指针变量名),不可互换




/* 指针和二维数组之间的关系 */

换个角度看二维数组
int a[2][3];
a[i][j]
*(*(a+i)+j)

a=======&a[0]--->   &a[0][0] /{a[0][0], a[0][1], a[0][2]}

(a+1)===&a[1]--->   &a[1][0] /{a[1][0], a[1][1], a[1][2]}

a   代表二维数组的首地址,第0行的地址,行地址
a+i 代表第 i 行的地址, 但并非增加 i 个字节!

1)a包含2个元素a[0],a[1]
2)a[0],a[1]又分别是一个, 一维数组,包含3个元素




/* 指向二维数组的行指针 */
将二维数组a看成一维数组,有2个“int[3]型”元素
int a[2][3];
*(*(p+i)+j)

若要让一个指针指向它,则应定义为
    int (*p)[3];//行指针,基类型“int[3]型”
    p = a;      //&a[0]指向第0行的“int[3]型”元素


        p+i 指向第i行的“int[3]型”元素,即&a[i]
        *(p+i),即a[i],第i行的数组名,即指向第i行第0列的int型元素
        *(p+i)+j 指向第i行第j列的int型元素
        *(*(p+i)+j) 取出第i行第j列的内容(int型元素的值),即a[i][j]




/* 按行指针访问二维数组元素 */
int a[2][3];
int (*P)[3];
p = a;
for (i=0; i<m; i++) //行下标变化
{
    for (j=0; j<n; j++)//列下标变化
    {
        printf("%d", *(*(p+i)+j));
    }
}



//再换一个角度看二维数组, int a[2][3];
//将二维数组a看成一维数组,有6个int型元素
若要让一个指针指向它,则应定义为
int *p;         //列指针,基类型是int型
p = a[0];       //*(a+0)+0即&a[0][0],指向第0行第0列的int型元素

按列指针访问二维数组元素, 根据相对偏移量逐列查找
int *p;
p = &a[0][0];
for (i=0; i<m; i++)
{
    for (j=0; j<n; j++)
        printf("%d", *(p+i*n+j));
}

*(p+i*n+j) == p[i*n+j]







