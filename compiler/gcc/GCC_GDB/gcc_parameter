###########################################################
### gcc_param
###########################################################
-E                      # 指示编译器仅对输入文件进行预处理
-S                      # 告诉 GCC编译器 在为 C 代码产生了汇编语言文件后停止编译
-c                      # 只编译并生成目标文件
-o                      # 指定目标名称, 缺省的时候, gcc 编译出来的文件是 a.out
-O                      # 对程序进行优化编译、链接，采用这个选项
-w                      # 不生成任何警告信息
-Wall                   # 生成所有警告信息。
-Wextra                 # 输出-Wall不包含的警告等
-Werror                 # 将警告视为错误输出
-g                      # 生成调试信息。GNU 调试器可利用该信息
-pg                     # 要启用gprof很简单，gcc编译的时候带上-pg参数即可

-shared                 # 生成共享目标文件。通常用在建立共享库时。
-static                 # 禁止使用共享连接。 
-Idir                   # 将 dir目录加入搜索头文件的目录路径
-Ldir                   # 将 dir目录加入搜索库文件的目录路径
-llib                   # 链接lib库
-pipe	                # 使用管道代替编译中临时文件, 在使用非 gnu 汇编工具的时候, 可能有些问题
-ansi                   # 关闭 gnu c中与 ansi c 不兼容的特性, 激活 ansi c 的专有特性
                          （包括禁止一些 asm inline typeof 关键字, 以及 UNIX,vax 等预处理宏）


-nostdinc               # 使编译器不再系统缺省的头文件目录里面找头文件, 
                          一般和 -I 联合使用,明确限定头文件的位置
-imacros file           # 将 file 文件的宏, 扩展到 gcc/g++ 的输入文件, 
                          宏定义本身并不出现在输入文件中
-Dmacro                 # 相当于 C 语言中的 #define macro　　
-Dmacro=defn            # 相当于 C 语言中的 #define macro=defn　　
-Umacro                 # 相当于 C 语言中的 #undef macro
-undef                  # 取消对任何非标准宏的定义 
-DMACRO                 # 以字符串"1"定义 MACRO 宏
-DMACRO=DEFN            # 以字符串"DEFN"定义 MACRO 宏

　　　
-D name=definition      # 加入宏定义，若不指定def，则默认为1
-O0, -O1, -O2, -O3      # 编译器的优化选项的 4 个级别，
                              -O0 表示没有优化, -O1为 缺省值，-O3 优化级别最高

-Wl,option              # 通过该选项将参数 option 作为后续链接器 ld 使用的参数
-Wl,rpath=/path/to/lib  # 为链接器指定一个非默认的运行时库的搜索路径，
                          运行采用了该选项编译的程序时，
                          链接器会在-rpath 指定的目录中搜索所需的 so 库文件，
                          以将其载入内存中



###########################################################
### archive
###########################################################
ar == archive
rcs== replace create save
GCC编译器制作静态库文件 .a
格式：ar rcs  libxxx.a xx1.o xx2.o
ar命令最常见的用法是将目标文件打包为静态链接库
### ===================================
gcc -c hello.c			1 生成目标文件	
ar -r libhello.a hello.o	2 把生成的 hello.o 这个文件归档,生成一个 libhello.a
gcc main.c libhello.a -o App	3 使用静态库
gcc -L. main.c -o App -lhello	4 加入搜索库文件的目录路径,并指定要链接的库文件名



###########################################################
###  shared
###########################################################
shared	表示生成共享库格式
fpic	产生位置无关码(position independent code)
库名规则：	libxxx.so
l	链接共享库存，只要库名即可（去掉lib及版本号）
L	链接库所在路径
GCC编译器制作动态库文件 .so
### ===================================================
gcc -c -fpic hello.c		1 编译独立的代码目标文件 -fpic
gcc -shared hello.o -o libmy.so 2 编译生成共享库
gcc -fpic -shared hello.o -o libmy.so	3 第1部和第2部合并写法
gcc main.c libmy.so -o App	4 使用共享库
5 定位共享库依赖 LIBRARY_PATH, 运行时依赖 LD_LIBRARY_PATH.



###########################################################
###  include
###########################################################
gcc -I 或者 gcc -L 用于命令行方式指定头文件、库文件的搜索路径。
如果是源码安装一些东西，发生了找不到头文件、
库文件的时候，用的makefile直接编译还好；
如果是用的configure，甚至其他的来生成makefile，
或者有的时候，甚至都不知道怎么编译出来的。这时候就傻了。
这时候，可以用C_INCLUDE_PATH、CPLUS_INCLUDE_PATH（for c++）、
LIBRARY_PATH作为环境变量来指定GCC的相应搜索路径。
另外，环境变量CPPFLAGS、LDFLAGS等用于makefile。

C_INCLUDE_PATH
LIBRARY_PATH
LD_LIBRARY_PATH



###########################################################
###  ldd
###########################################################
ldd 是list, dynamic, dependencies的缩写， 
意思是， 列出动态库依赖关系

ldconfig几个需要注意的地方:
1. 往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf的，
   但是完了之后要调一下ldconfig，不然这个library会找不到
2. 想往上面两个目录以外加东西的时候，一定要修改/etc/ld.so.conf，
    然后再调用ldconfig，不然也会找不到
    比如安装了一个mysql到/usr/local/mysql，
    mysql有一大堆library在/usr/local/mysql/lib下面，
    这时就需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib，
    保存过后ldconfig一下，新的library才能在程序运行时被找到。
3. 如果想在这两个目录以外放lib，但是又不想在/etc/ld.so.conf中加东西（或者是没有权限加东西）。
   那也可以，就是export一个全局变量LD_LIBRARY_PATH，
   然后运行程序的时候就会去这个目录中找library。
   一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。
4. ldconfig做的这些东西都与运行程序时有关，跟编译时一点关系都没有。
    编译的时候还是该加-L就得加，不要混淆了。
5. 总之，就是不管做了什么关于library的变动后，最好都ldconfig一下，
   不然会出现一些意想不到的结果。
   不会花太多的时间，但是会省很多的事。
   再有，诸如libdb-4.3.so文件头中是会含有库名相关的信息的
   （即含“libdb-4.3.so”，可用strings命令察看），
   因此仅通过修改文件名以冒充某已被识别的库（如libdb-4.8.so）是行不通的。
   为此可在编译库的Makefile中直接修改配置信息，
   指定特别的库名。





GCC-> 
    GNU Compiler Collection                  GNU GPL---> 
============================================================
		
1.预处理-Pre-Processing
		gcc  -E  test.c  -o  test.i	# .i文件
2.编译-Compiling
		gcc  -S  test.i  -o   test.s	# .s文件
3.汇编-Assembling
		gcc  -c  test.s  -o  test.o	# .o文件
4.链接-Linking
		gcc  test.o  -o  test		# .bin文件
	
============================================================
-E		# 选项指示编译器仅对输入文件进行预处理
-S		# 编译选项告诉 GCC 在为 C 代码产生了汇编语言文件后停止编译


-c		#编译，不链接。.c--->.o
-o		#指定输出文件名。default: a.out

________________________________________________________
-O		# 对程序进行优化编译、链接，采用这个选项，
		# 整个源代码会在编译、链接过程中进行优化处理
		# -O 主要进行跳转和延迟退栈两种优化；
		# -O0表示不做优化
		# -O1为默认优化
		# -O2除了完成-O1的优化之外，还进行一些额外的调整工作，如指令调整等
		# -O3则包括循环展开和其他一些与处理特性相关的优化工作
---------------------------------------------------------------------
-g		#选项告诉 GCC 产生能被 GNU 调试器使用的调试信息以便调试你的程序。
		#GCC 提供了一个很多其他 C 编译器里没有的特性, 
		在 GCC 里你能使-g 和 -O(产生优化代码)联用
-pg		#选项告诉 GCC 在编译好的程序里加入额外的代码。
		#运行程序时, 产生 gprof 用的剖析信息以显示你的程序的耗时情况。
		
		
				
###########################################################		
###  Libraies
###########################################################
-l参数和-L参数
-l参数就是用来指定程序要链接的库，-l参数紧接着就是库名
  就拿数学库来说，他的库名是m，他的库文件名是libm.so，
  很容易看出，把库文件名的头lib和尾.so去掉就是库名 了
gcc  xxx.c  -lm( 动态数学库)
___________________________________________________________	
好了现在我们知道怎么得到库名了，比如我们自已要用到一个第三方提供的库名字叫libtest.so，
那么我们只要把 libtest.so拷贝到 /usr/lib里，编译时加上-ltest参数，
我们就能用上libtest.so库了
（当然要用libtest.so库里的函数，我们还 需要与 libtest.so配套的头文件）。

___________________________________________________________
#Libraries 库文件路径参数
放在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接了，
但如果库文件没放在这三个目录里，而是放在其他目录里， 这时我们只用-l参数的话，链接还是会出错，
出错信息大概是：“/usr/bin/ld: cannot find-lxxx”，也就是链接 程序ld在那3个目录里找不到libxxx.so，
这时另外一个参数-L就派上用场了，比如常用的X11的库 ，它放在/usr/X11R6/lib目录 下，
我们编译时就要用-L/usr/X11R6/lib -lX11参数，-L参数跟着的是库文件所在的目录名。
再比如我们把libtest.so放在/aaa/bbb/ccc目录下，那链接参数就是-L/aaa/bbb/ccc -ltest



###########################################################
###  Include
###########################################################
# -include和-I参数
-include用来包含头文件，但一般情况下包含头文件都在源码里用＃i nclude xxxxxx实现，
-include参数很少用。
-I参数是用来指定头文件目录，/usr/include目录一般是不用指定的，gcc知道去那里找，
但 是如果头文件不在/usr/icnclude里我们就要用-I参数指定了，
比如头文件放在/myinclude目录里，
那编译命令行就要加上-I/myinclude 参数了，
如果不加你会得到一个”xxxx.h: No such file or directory”的错误。
-I参数可以用相对路径，比如头文件在当前 目录，可以用-I.来指定。
上面我们提到的–cflags参数就是用来生成-I参数的





