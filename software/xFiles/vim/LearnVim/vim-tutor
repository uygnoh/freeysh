### ================================================================语言支持
说到多语言支持，最基本的概念有两个：一是文件的语言编码，2是环境的内部编码。
在较老的操作系统中，不管 Linux 还是 Windows，
这两个编码都是一样的，也就意味着，一次只能处理一种编码的文件：
要么只能处理西文编码（Latin1，即 ISO-8859-1 [5]），
要么只能处理中文编码（GB2312 [2]）。而在新的操作系统中，这两者可以是不一样的。
在 Linux 上，常见的情况是环境的内部编码使用 UTF-8 [6]，而 UTF-8 可以同任何一种语言编码作无损转换，
这就保证了系统的多语言处理能力。Vim 这方面秉承了 Unix/Linux 的传统，在内部编码使 UTF-8 的时候，
可以同时处理不同意语言编码的文件。

% 以下列出了和语言编码的相关的设置：
    环境变量 LANG（使用的语言）；
    环境变量 LC_CTYPE（使用的内部编码）；
    Vim 选项 encoding（Vim 的内部编码）；
    Vim 选项 termencoding（Vim 在与屏幕/键盘交互时使用的编码）；
    Vim 选项 fileencoding（Vim 当前编辑的文件在存储时的编码）；
    Vim 选项 fileencodings（Vim 打开文件时的尝试使用的编码）；
    Vim 选项 ambiwidth（对“不明宽度”字符的处理方式；Vim 6.1.455 后引入）。

如果你的环境只需要处理简体中文的话，那么，最简单的方式就是所有的设定全部使用简体中文。
只需要：设定 LANG=zh_CN.GB2312，不设定 LC_CTYPE（默认跟 LANG 一样），
不设定与编码相关的 Vim 选项（默认由 LANG 和 LC_CTYPE 决定），
也无需设定 Vim 选项 ambiwidth。也就是说，我们把语言设定为中国（CN）使用的中文（zh），
编码为 GB2312（注意：Vim 内部并不识别国标 GB18030 [3]，
所以此处只能设 GB2312；参看下面关于 UTF-8 的讨论）。

不过，如果按照目前 Linux 下的惯例，内部编码一律使用 UTF-8 的话，
会有一些额外的好处，其中之一就是在这种情况下 Vim 支持同时编辑多种不同编码的文件，
如简体中文和繁体中文（参见图 2）；另外，此时 Vim 也可以通过编码转换支持 GBK [4] 和 GB18030了。
这样，众多关于语言编码的 Vim 选项就有了用武之地了。下面进一步说明一下这些选项和推荐设定（如果适用的话）：


% encoding=utf-8
不管文件的编码如何，不管如何显示和输入，Vim 内部使用的编码是 UTF-8；这是国际化支持的基础。

% termencoding
取决于实际的终端或 X Window 的设定。
举例来说，如果选择语言简体中文登录到 X Window，
或者正在使用 CXTERM [10] 的话，那么该选项应被设为 GB2312；
如果使用缺省的语言（LANG=en_US.UTF-8）登录到 X Window，
或者使用 PuTTY [11] 远程访问 Linux 机器、并且设定里的字符编码
（配置中 Window-Translation）设为 UTF-8 的话，该选项就应该设为
 utf-8。从 Windows 下使用 PuTTY 远程连接 Linux 的请特别注意，测试表明，
 仅在使用 UTF-8 的情况下，PuTTY 才能可靠地支持中文的显示和输入（显示字体必须设成中文字体）。
 
% fileencoding
文件载入时，该选项被置为 Vim 认定的文件编码，因此，存储时文件的编码不会改变。
此处和下面 fileencodings 可使用的编码为 libiconv 支持的所有几百种编码（如果编译时包含了 iconv 特性的话），
与中文相关的有 gb2312、gbk、gb18030、hz-gb-2312、iso-2022-cn、big5、cp936、cp950 等。
如果创建新文件，你又不希望使用 UTF-8 作为文件编码时，那么，你可能需要手工设定该选项，
如“:set fileencoding=gb2312”。需要注意的一点是，使用“set”来设定该选项的话会改变以后新建文件的缺省编码，
而使用“setlocal”的话则只影响当前文件（参考“:help setlocal”）。
fileencodings=ucs-bom,utf-8,chinese：
Vim 会首先判断文件的开头是否是一个 Unicode [7] 的 BOM（byte order mark）字符 [8]，
是的话则把文件的其余内容解释成相应的 Unicode 序列；否的话再试图把文件内容解释成 UTF-8 的序列；
再失败的话，则把文件解释为简体中文（chinese 是一个跨平台的简体中文字符集的别名，
Linux 下相当于 gb2312 和 euc-cn；此处也可以根据需要以 gb2312、gbk 或 gb18030 等编码替代）。
需要注意的是，该顺序不能颠倒，并且在后面再添加其它编码如 big5、latin1 也是没有意义的，
因为 Vim 不能识别 8 比特编码中的错误，因此这些编码后列的编码永远不会被用到。

% ambiwidth=double
把所有的“不明宽度”字符 [9]——指的是在 Unicode 字符集中某些同时在东西方语言中使用的字符，
如省略号、破折号、书名号和全角引号，在西方文字中通常字符宽度等同于普通 ASCII 字符，
而在东方文字中通常字符宽度等同于两倍的普通 ASCII 字符，因而其宽度“不明”——的宽度置为双倍字符宽度（中文字符宽度）。
此数值只在 encoding 设为 utf-8 或某一 Unicode 编码时才有效。需要额外注意的是，如果你通过终端使用 Vim 的话，
需要令终端也将这些字符显示为双宽度。比如，XTERM [12] 的情况下应该使用选项“-cjk”，
即使用命令“uxterm -cjk”来启动使用双宽度显示这些字符的 Unicode X 终端；
使用 PuTTY 远程连接的话则应在配置的 Window-Translation 中选中
“Treat CJK ambiguous characters as wide”（参见图 3）。


% 需要设定的选项通常放在用户的 Vim 资源配置文件中，即在 ~/.vimrc 文件中加入：
set encoding=utf-8
set fileencoding=chinese
set fileencodings=ucs-bom,utf-8,chinese
set ambiwidth=double


% 空格、制表符和缩进
 shiftwidth（缩进的空格数）；
 tabstop（制表符的宽度）；
 expandtab（是否在缩进和遇到 Tab 键时使用空格替代；使用 noexpandtab 取消设置）；
 softtabstop（软制表符宽度，设置为非零数值后使用 Tab 键和 Backspace 时光标移动的格数等于该数值，
 但实际插入的字符仍受 tabstop 和 expandtab 控制）；
 autoindent（自动缩进，即每行的缩进值与上一行相等；使用 noautoindent 取消设置）；
 cindent（使用 C 语言的缩进方式，根据特殊字符如“{”、“}”、“:”和语句是否结束等信息自动调整缩进；
 在编辑 C/C++ 等类型文件时会自动设定；使用 nocindent）；
 cinoptions（C 语言缩进的具体方式，请参考“:help cinoptions-values”）；
 paste（粘贴模式，会取消所有上述选项的影响来保证后面的操作——
 通常是从剪贴板粘贴代码——保持原有代码的风格；使用 nopaste 取消设置）。


% 模式行（modeline）
没人愿意每次都手工输入一大堆的 Tab 和缩进设定。可是，放在 .vimrc 文件中似乎也不是个好主意：
如果我编辑的代码不止一种风格呢？——考虑一下，如果你参加开源软件项目，你能保证你参加的所有项目，
还有你公司里的软件项目，代码风格都一样吗？——Vim 是我用过的第一个支持在文件中记录代码风格设定的编辑器。
这个特性在 Vim 中叫做模式行，实际上，它所做的是在打开文件时根据文件中的 Vim 指令设定相关的 Vim 选项。
下面就是一个嵌在 C 源代码中的模式行：

/* vim: set tabstop=4 shiftwidth=4 expandtab: */

模式行有好几种形式。本文只介绍上面的这种形式（其它形式类似，请自行参考“:help modeline”）：
行首的“/*”和尾部的“*/”告诉 C 编译器这是一行注释，不是代码的一部分；而 Vim 可通过后面的“vim:”
识别出模式行的开始（必须出现在行首或前面有一个空白字符）；后面则是“set”和空格间隔开的一串 Vim 选项；“:”表示模式行结束。
这种方式非常简单，功能也非常强大。另外请注意，出于安全的考虑，模式行中的选项只影响当前文件
（“:help modeline-local”），也不能做任何设置选项以外的工作。


% 寄存器
通常的编辑器有一个剪贴板，以存储复制和剪切的内容。Vim 中的类似概念叫做寄存器（register）。
除了有一个无名寄存器外，Vim 还有一大堆有名的寄存器，可以通过“"”（参见“:help "”）或“Ctrl-R”
（参见“:help i_CTRL-R”和“:help c_CTRL-R”）加寄存器名（字母、数字和某些特殊字符，
参见“:help registers”；“无名”寄存器的名字是“"”）来访问。比如，你先使用“"ayy”复制了一行，
然后使用“dd”删掉了一行，然后移动光标到要复制到的位置，就可以使用“"aP”把先前复制的内容粘贴上去了。
手工编辑是有名寄存器的作用还不是很大，但当你想让 Vim 通过类似于宏的方式自动完成工作时，
有名寄存器就变成不可缺少的重要功能了。下面我们还会用到。

在使用 X Window 系统时，有两个特殊的寄存器是需要注意一下的：
“"*”访问的寄存器是 X 的主选择区域（primary selection），
“"+”访问的寄存器是 X 的剪贴板（clipboard）。
如果你要在 Vim 和其它的 X 应用程序之间复制文本内容，你可以试一下这两个寄存器。

还有一个很特殊的“寄存器”：“=”。在插入模式或命令模式中，
键入“Ctrl-R=”，Vim 会提示你输入一个表达式，普通的整数运算在此完全有效。
如果想要进行浮点运算，请参见第 3.2 节中的技巧。


% 自动完成和路径设定
Vim 支持单词的自动完成。比如，你前面使用了一个很长的变量名，叫 aLongVariable，下面你在输入时，
就不用完整键入了。很可能，你只需要键入“aL”，然后按下“Ctrl-P”（向前搜索可匹配的单词并完成）
就可以得到完整的变量名（没有得到想要的结果的话，多按几下“Ctrl-P”；或者前面多输入几个字符，如“aLongV”）。
类似的命令还有“Ctrl-N”（向后搜索可匹配的单词并完成）、“Ctrl-X Ctrl-L”（搜索可匹配的行并完成）、
“Ctrl-X Ctrl-F”（搜索可匹配的文件名并完成）等，具体可参看“:help ins-completion”。

如果你并不熟悉这些功能，但也并不觉得这有什么稀奇的话，下面这个例子可能会让你觉得吃惊。
请尝试打开一个空白的 C 文件（vim test.c），并输入：
	
#include <stdio.h>
int main()
{
    pri

最后一行不要回车，直接在“pri”后面输入“Ctrl-P”，你将看到“printf”出现。是的，
虽然文件里没有“printf”，但 Vim 知道到哪里去寻找它！在作关键字匹配完成时，
如果当前文件和其它打开的文件中没有想要的结果，Vim 会自动到“#include”的文件中进行进一步的搜索
（为什么是“#include”呢？请查阅“:help 'include'”），搜寻的目录则由选项 path 决定，
其缺省值在 Unix（含 Linux）下为“.,/usr/include,,”，代表搜索的目录依次是文件所在目录、
/usr/include 和当前目录。根据实际情况，你可能需要在 .vimrc 文件中设置该选项，
加入项目相关的包含目录，注意一般要保留最后的“,,”，除非你不需要在当前目录下搜索。
设置了合适的 path 后，另外带来的一个便利就是可以使用“gf”命令方便地跳转到光标下的文件名所代表的文件中。
在上面的例子中，把光标移到“stdio.h”的任一字符上，键入“gf”，则 Vim 会自动打开 /usr/include/stdio.h 文件。
使用“Ctrl-O”（参见“:help CTRL-O”）可返回到原先的文件中。



% 文件跳转和 Tags
大家一般都知道，在 Vim 的帮助窗口中的关键字上双击鼠标或者键入“Ctrl-]”即可跳转至该关键字相关的帮助主题。
不过，“跳转至匹配的关键字”这一功能并不仅仅局限于帮助文件。只要有合适的 tags 文件（参见“:help tags-file-format”），
我们同样可以在源代码中使用这个方便的功能，跳转到与关键字匹配的“标记”处（通常是源代码中某一函数、类型、变量或宏的定义位置）。

要产生 tags 文件，通常我们使用 Exuberant Ctags [15]。一般的 Linux 发布版中均带有这一工具。
Ctags 带有的选项数量极多，此处我们仅简单介绍如何在一个典型的多文件、多层目录的项目中使用其基本功能：
我们只需在项目的根目录处键入“ctags -R .”，Ctags 即可自动在文件中查找、识别支持的文件格式、
生成 tags 文件。目前 Exuberant Ctags 支持多达 33 种编程语言 [16]，包括了 Linux 下常用的 
C、C++、Java、Perl、PHP 等。有了 tags 文件，以下的 Vim 命令就可以方便使用了
% （进一步的信息可参考“:help tags-and-searches”）：
    :tag 关键字（跳转到与“关键字”匹配的标记处）
    :tselect [关键字]（显示与“关键字”匹配的标记列表，输入数字跳转到指定的标记）
    :tjump [关键字]（类似于“:tselect”，但当匹配项只有一个时直接跳转至标记处而不再显示列表）
    :tn（跳转到下一个匹配的标记处）
    :tp（跳转到上一个匹配的标记处）
    Ctrl-]（跳转到与光标下的关键字匹配的标记处；除“关键字”直接从光标位置自动获得外，功能与“:tags”相同）
    g]（与“Ctrl-]”功能类似，但使用的命令是“:tselect”）
    g Ctrl-]（与“Ctrl-]”功能类似，但使用的命令是“:tjump”）
    Ctrl-T（跳转回上次使用以上命令跳转前的位置）
当我们在项目的根目录下工作时，上面这些命令工作得很好。
但如果我们进到多层目录的里层再运行 Vim 打开文件时，
这些命令的执行结果通常就变成了错误信息“E433: No tags file”。
这是因为缺省 Vim 只在文件所在目录和当前目录下寻找 tags 文件，
而我们前面只在项目的根目录下生成了 tags 文件，Vim 无法找到该文件。解决方法有好几种，
我认为一般较简单的做法是对每个项目都在 .vimrc 文件中增加一个路径相关设定。假设我们有两个项目，
位置分别是 /home/my/proj1 和 /home/my/proj2，那我们可以使用：

au BufEnter /home/my/proj1/* setlocal tags+=/home/my/proj1/tags
au BufEnter /home/my/proj2/* setlocal tags+=/home/my/proj2/tags

Vim 选项 tags 用于控制检查的 tags 文件，缺省值为“./tags,tags”，
即前面所说的文件所在目录下和当前目录下的 tags 文件。上面两行自动命令告诉 Vim，
在打开项目目录下的文件时，tags 选项中的内容要增加项目的 tags 文件的路径。
进一步信息可参看“:help 'tags'”。


% 执行外部命令
在“:make”这样的命令中，Vim 会自动调用外部的程序。用户当然也可以自己执行外部的程序：
估计很多的人都已经知道了用“:!命令”可以在 Vim 中执行一个外部命令。不过，估计大部分人都不知道，
还有其它一些命令可以执行外部命令，并且，即使“:!”命令里面也有一些技巧可以使用。

最正规的执行外部命令的方法，如前所述，就是“:!”。比如，我们想要显示当前目录下的所有文件，
就可以直接执行：“:!ls”。Vim 会在一个终端窗口中进行文件列表，然后提示我们按键返回 Vim 中。
事实上，这种方式对于“cp”、“rm”这样基本不需要输出的命令比较实用，而对于“ls”这样关注于输出的命令并不太适用。

如果想把外部命令执行的结果插入到当前编辑的缓冲区中，可以考虑使用“:r!”。
比如，我们使用“:r!ls”，就可以把“ls”命令的执行结果插入到缓冲区中光标所在行下面。
在使用宏时，这可能会特别有用。

Vim 的“:!”命令还有一个特别强大的技巧可以使用。拿一个实际例子，
我们需要对在一个文件的每一行之前插入一个编号，该怎么做呢？
——用 Vim 的宏或者脚本可以完成这一工作，但这不是最高效、最灵活的工作方式。
Linux 下一般带有的 GNU 的 nl，可以用非常灵活的方式来完成这一任务——要对所有的非空行进行编号，
只需要“:%!nl”；要对包含空行的所有行进行编号？OK，“:%!nl -ba”。

稍作一点解释。当使用可视模式选中文本行后然后键入“:!”（命令行上将出现“:'<,'>!”，表示命令的范围是选定的文本），
或者使用“:%!”（表示命令的范围是整个缓冲区中的文本），Vim 在执行后面的命令时，
将把命令范围里的文本行作为后面执行的命令标准输入，并用命令执行后的标准输出替换当前缓冲区中的这些文本行。
这就是上面的命令行的工作原理。


% 其它小技巧,也许你会觉得这些很有用：
    %（跳转到与之匹配的括号处）
    .（重复上次的修改命令）
    `.（跳转到最近修改过的位置）
    ZQ（无条件退出）
    ZZ（存盘退出）
    ga（显示光标下的字符在当前使用的 encoding 下的内码）
    guw（光标下的单词变为小写）
    gUw（光标下的单词变为大写）
    :TOhtml（根据 Vim 的语法加亮的方式生成 HTML 代码；在图形界面中也可以使用菜单“Syntax—Convert to HTML”达到同样效果）


% taglist（源代码结构浏览）

